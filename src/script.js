 const i18n = {
    en: {
        pageTitle: "TDashcam Studio",
        headerTitle: "TDashcam Studio",
        toggleSidebar: "Toggle Sidebar",
        toggleTheme: "Toggle Theme",
        toggleLanguage: "ÂàáÊèõËá≥‰∏≠Êñá",
        drivingRecords: "Driving Records",
        date: "Date",
        eventType: "Event Type",
        allTypes: "üìÇ All Types",
        recentClips: "üïí Recent Clips",
        savedClips: "üíæ Saved Clips",
        sentryClips: "ü§ñ Sentry Clips",
        noRecordsFound: "No records found",
        selectFolder: "üìÅ Select Folder",
        selectFiles: "üìÅ Select Files",
        helpStep1: "Insert your Tesla USB drive into your PC",
        helpStep2: "Select or drag the 'TeslaCam' directory from the drive",
        helpStep1IOS: "Copy TeslaCam videos to your iPad/iPhone",
        helpStep2IOS: "Select the video files (e.g., 2024-01-15_12-30-00-front.mp4)",
        mapModalTitle: "View on Map",
        gaodeMap: "Gaode Map",
        googleMap: "Google Map",
        revealFile: "Show Path",
        downloadFile: "Download",
        filePathAlertTitle: "Current Video File Path",
        copiedToClipboard: "Copied to clipboard",
        noFilePath: "Could not determine file path for the active camera.",
        selectDate: "Select Date",
        minutes: "minutes",
        preview: "Preview",
        noSignal: "No Signal",
        front: "Front",
        back: "Back",
        left: "Left",
        right: "Right",
        leftPillar: "Left Pillar",
        rightPillar: "Right Pillar",
        play: "Play",
        pause: "Pause",
        toggleDay: "Switch to Day Mode",
        toggleNight: "Switch to Night Mode",
        invalidFolder: "This does not appear to be a valid TeslaCam directory. Please ensure you select the 'TeslaCam' directory which contains subfolders like RecentClips, SavedClips, etc.",
        clipVideo: "Clip Video",
        confirmClip: "Confirm Clip Range",
        exportClip: "Export Video Clip",
        clipDuration: "Duration:",
        clipStartTime: "Start Time:",
        clipEndTime: "End Time:",
        selectCameras: "Select Cameras:",
        addTimestamp: "Timestamp",
        addMetadata: "Driving Status",
        addBackgroundAudio: "Background Music",
        colorAdjust: "Color Adjustment",
        saturation: "Saturation",
        contrast: "Contrast",
        brightness: "Brightness",
        resetColorAdjust: "Reset",
        mergeVideos: "Merge as Grid Video",
        startExport: "Start Export",
        cancel: "Cancel",
        preparing: "Preparing...",
        processing: "Processing...",
        exporting: "Exporting...",
        complete: "Complete!",
        selectClipRange: "Select clip range on progress bar first",
        selectAtLeastOneCamera: "Please select at least one camera",
        exportFailed: "Export failed: ",
        metadata: "Drive Data",
        driveStats: "Drive Stats",
        loadingMetadata: "Loading...",
        noMetadata: "No metadata found",
        speed: "Speed",
        gear: "Gear",
        steering: "Steering",
        accelerator: "Accelerator",
        brake: "Brake",
        brakeApplied: "Applied",
        brakeNotApplied: "Not applied",
        blinker: "Blinker",

        autopilot: "Autopilot",
        gps: "GPS",
        heading: "Heading",
        acceleration: "Acceleration",
        gearPark: "Park",
        gearDrive: "Drive",
        gearReverse: "Reverse",
        gearNeutral: "Neutral",
        blinkerLeft: "Left",
        blinkerRight: "Right",
        blinkerBoth: "Both",
        blinkerOff: "Off",
        autopilotNone: "None",
        autopilotSelfDriving: "FSD",
        autopilotAutosteer: "Autosteer",
        autopilotTACC: "TACC",
        moreOptions: "More Options",
        metadataDetail: "Details",
        vehicleStatus: "Vehicle Status",
        drivingAssist: "Driving Assist",
        locationInfo: "Location Info",
        motionData: "Motion Data",
        latitude: "Latitude",
        longitude: "Longitude",
        accelX: "Accel X",
        accelY: "Accel Y",
        accelZ: "Accel Z",
        exportMetadata: "Export CSV",
        exportMetadataSuccess: "Metadata exported successfully",
        exportMetadataNoData: "No metadata available to export"
    },
    'zh-TW': {
        pageTitle: "TDashcam Studio",
        headerTitle: "TDashcam Studio",
        toggleSidebar: "ÂàáÊèõÂÅ¥ÈÇäÊ¨Ñ",
        toggleTheme: "ÂàáÊèõ‰∏ªÈ°å",
        toggleLanguage: "Switch to English",
        drivingRecords: "Ë°åËªäË®òÈåÑ",
        date: "Êó•Êúü",
        eventType: "‰∫ã‰ª∂È°ûÂûã",
        allTypes: "üé• ÊâÄÊúâÈ°ûÂûã",
        recentClips: "üïí ÊúÄËøëÁâáÊÆµ",
        savedClips: "üíæ Â∑≤ÂÑ≤Â≠òÁâáÊÆµ",
        sentryClips: "ü§ñ Âì®ÂÖµÊ®°Âºè",
        noRecordsFound: "Êâæ‰∏çÂà∞Á¨¶ÂêàÁöÑË®òÈåÑ",
        selectFolder: "üìÅ ÈÅ∏ÊìáË≥áÊñôÂ§æ",
        selectFiles: "üìÅ ÈÅ∏ÊìáÊ™îÊ°à",
        helpStep1: "Â∞á Tesla USB Èö®Ë∫´Á¢üÊèíÂÖ•ÈõªËÖ¶",
        helpStep2: "ÈÅ∏ÊìáÊàñÊãñÊõ≥Èö®Ë∫´Á¢ü‰∏≠ÁöÑ TeslaCam ÁõÆÈåÑ",
        helpStep1IOS: "Â∞á TeslaCam ÂΩ±ÁâáË§áË£ΩÂà∞ iPad/iPhone",
        helpStep2IOS: "ÈÅ∏ÊìáÂΩ±ÁâáÊ™îÊ°àÔºàÂ¶Ç 2024-01-15_12-30-00-front.mp4Ôºâ",
        mapModalTitle: "Âú®Âú∞Âúñ‰∏äÊ™¢Ë¶ñ",
        gaodeMap: "È´òÂæ∑Âú∞Âúñ",
        googleMap: "Google Âú∞Âúñ",
        revealFile: "È°ØÁ§∫Ë∑ØÂæë",
        downloadFile: "‰∏ãËºâÂΩ±Áâá",
        filePathAlertTitle: "ÁõÆÂâçÂΩ±ÁâáÊ™îÊ°àË∑ØÂæë",
        copiedToClipboard: "Â∑≤Ë§áË£ΩÂà∞Ââ™Ë≤ºÁ∞ø",
        noFilePath: "ÁÑ°Ê≥ïÂèñÂæóÁõÆÂâçÊîùÂΩ±Ê©üÁöÑÊ™îÊ°àË∑ØÂæë",
        selectDate: "ÈÅ∏ÊìáÊó•Êúü",
        minutes: "ÂàÜÈêò",
        preview: "È†êË¶ΩÂúñ",
        noSignal: "ÁÑ°Ë®äËôü",
        grid6: "6 ÂÆÆÊ†º",
        grid4: "4 ÂÆÆÊ†º",
        legacy: "Â≠êÊØçÁï´Èù¢",
        front: "Ââç",
        back: "Âæå",
        left: "Â∑¶",
        right: "Âè≥",
        leftPillar: "Â∑¶Êü±",
        rightPillar: "Âè≥Êü±",
        play: "Êí≠Êîæ",
        pause: "Êö´ÂÅú",
        toggleDay: "ÂàáÊèõËá≥Êó•ÈñìÊ®°Âºè",
        toggleNight: "ÂàáÊèõËá≥Â§úÈñìÊ®°Âºè",
        invalidFolder: "ÈÄô‰ºº‰πé‰∏çÊòØÊúâÊïàÁöÑ TeslaCam ÁõÆÈåÑ„ÄÇË´ãÁ¢∫Ë™çÊÇ®ÈÅ∏ÊìáÁöÑÊòØÂåÖÂê´ RecentClips„ÄÅSavedClips Á≠âÂ≠êË≥áÊñôÂ§æÁöÑ TeslaCam ÁõÆÈåÑ„ÄÇ",
        clipVideo: "Ââ™ËºØÂΩ±Áâá",
        confirmClip: "Á¢∫Ë™çÂâ™ËºØÁØÑÂúç",
        exportClip: "ÂåØÂá∫ÂΩ±ÁâáÁâáÊÆµ",
        clipDuration: "ÈÅ∏ÂèñÊôÇÈï∑:",
        clipStartTime: "Ëµ∑ÂßãÊôÇÈñì:",
        clipEndTime: "ÁµêÊùüÊôÇÈñì:",
        selectCameras: "ÈÅ∏ÊìáÊîùÂΩ±Ê©ü:",
        addTimestamp: "ÊôÇÈñìÊà≥Á´†",
        addMetadata: "Ë°åËªäÁãÄÊÖã",
        addBackgroundAudio: "ËÉåÊôØÈü≥Ê®Ç",
        colorAdjust: "Ëâ≤ÂΩ©Ë™øÊï¥",
        saturation: "È£ΩÂíåÂ∫¶",
        contrast: "Â∞çÊØî",
        brightness: "‰∫ÆÂ∫¶",
        resetColorAdjust: "ÈáçÁΩÆ",
        mergeVideos: "ÂêàÊàêÂõõÂÆÆÊ†ºÂΩ±Áâá",
        startExport: "ÈñãÂßãÂåØÂá∫",
        cancel: "ÂèñÊ∂à",
        preparing: "Ê∫ñÂÇô‰∏≠...",
        processing: "ËôïÁêÜ‰∏≠...",
        exporting: "ÂåØÂá∫‰∏≠...",
        complete: "ÂÆåÊàêÔºÅ",
        selectClipRange: "Ë´ãÂÖàÂú®ÈÄ≤Â∫¶Ê¢ù‰∏äÈÅ∏ÊìáÂâ™ËºØÁØÑÂúç",
        selectAtLeastOneCamera: "Ë´ãËá≥Â∞ëÈÅ∏Êìá‰∏ÄÂÄãÊîùÂΩ±Ê©ü",
        exportFailed: "ÂåØÂá∫Â§±ÊïóÔºö",
        metadata: "Ë°åËªäÊï∏Êìö",
        driveStats: "Ë°åËªäÊï∏Êìö",
        loadingMetadata: "ËºâÂÖ•‰∏≠...",
        noMetadata: "ÁÑ°‰∏≠ÁπºË≥áÊñô",
        speed: "ÈÄüÂ∫¶",
        gear: "Ê™î‰Ωç",
        steering: "ÊñπÂêëÁõ§ËßíÂ∫¶",
        accelerator: "Ê≤πÈñÄË∏èÊùø",
        brake: "ÁÖûËªä",
        brakeApplied: "Ë∏©‰∏ã",
        brakeNotApplied: "Êú™Ë∏©",
        blinker: "ÊñπÂêëÁáà",
        autopilot: "Ëá™ÂãïÈßïÈßõ",
        gps: "GPS Â∫ßÊ®ô",
        heading: "Ëà™Âêë",
        acceleration: "Âä†ÈÄüÂ∫¶",
        gearPark: "ÈßêËªä (P)",
        gearDrive: "ÂâçÈÄ≤ (D)",
        gearReverse: "ÂÄíËªä (R)",
        gearNeutral: "Á©∫Ê™î (N)",
        blinkerLeft: "Â∑¶",
        blinkerRight: "Âè≥",
        blinkerBoth: "ÈõôÈñÉ",
        blinkerOff: "Èóú",
        autopilotNone: "ÁÑ°",
        autopilotSelfDriving: "ÂÖ®Ëá™ÂãïËºîÂä©ÈßïÈßõ (FSD)",
        autopilotAutosteer: "Ëá™ÂãïËºîÂä©ËΩâÂêë",
        autopilotTACC: "‰∏ªÂãïÂºèÂÆöÈÄüÂ∑°Ëà™",
        moreOptions: "Êõ¥Â§öÈÅ∏È†Ö",
        metadataDetail: "Ë©≥Á¥∞Êï∏Êìö",
        vehicleStatus: "ËªäËºõÁãÄÊÖã",
        drivingAssist: "ÈßïÈßõËºîÂä©",
        locationInfo: "‰ΩçÁΩÆË≥áË®ä",
        motionData: "ÈÅãÂãïÊï∏Êìö",
        latitude: "Á∑ØÂ∫¶",
        longitude: "Á∂ìÂ∫¶",
        accelX: "Âä†ÈÄüÂ∫¶ X",
        accelY: "Âä†ÈÄüÂ∫¶ Y",
        accelZ: "Âä†ÈÄüÂ∫¶ Z",
        exportMetadata: "ÂåØÂá∫ CSV",
        exportMetadataSuccess: "‰∏≠ÁπºË≥áÊñôÂåØÂá∫ÊàêÂäü",
        exportMetadataNoData: "Ê≤íÊúâÂèØÂåØÂá∫ÁöÑ‰∏≠ÁπºË≥áÊñô"
    }
};

// --- Tauri Helper Functions ---
function getTauri() {
    return window.__TAURI__;
}

// Get system temp directory for temporary files
async function getTempDir() {
    const tauri = getTauri();
    if (tauri && tauri.path && tauri.path.tempDir) {
        try {
            const tempDir = await tauri.path.tempDir();
            // Ensure no trailing separator for consistency
            return tempDir.replace(/[\/\\]$/, '');
        } catch (e) {
            console.warn('[getTempDir] Failed to get temp dir:', e);
        }
    }
    // Fallback for different OS
    if (typeof process !== 'undefined' && process.env) {
        return process.env.TEMP || process.env.TMP || '/tmp';
    }
    return '/tmp';
}

function getFileUrl(file) {
    const tauri = getTauri();
    if (tauri && file.path) {
        // Tauri 2: use core.convertFileSrc
        let convertFn = null;
        if (tauri.core && tauri.core.convertFileSrc) {
            convertFn = tauri.core.convertFileSrc;
        } else if (tauri.tauri && tauri.tauri.convertFileSrc) {
            convertFn = tauri.tauri.convertFileSrc;
        } else if (tauri.convertFileSrc) {
            convertFn = tauri.convertFileSrc;
        }
        
        if (convertFn) {
            const url = convertFn(file.path);
            console.log('[getFileUrl] path:', file.path, '-> url:', url);
            return url;
        }
        
        // Fallback: return path directly (won't work but helps debug)
        console.warn('[getFileUrl] No convertFileSrc found, returning raw path');
        return file.path;
    }
    return URL.createObjectURL(file);
}

class TauriFile {
    constructor(entry, rootPath) {
        this.name = entry.name;
        this.path = entry.path; 
        
        // Calculate webkitRelativePath - must use forward slashes
        if (this.path && rootPath) {
             // Normalize all separators to forward slashes
             const normalizedPath = this.path.replace(/\\/g, '/');
             const normalizedRoot = rootPath.replace(/\\/g, '/');
             
             // Get the root folder name (e.g., "TeslaCam")
             const rootName = normalizedRoot.split('/').filter(Boolean).pop();
             
             // Get the relative part after the root path
             const relativePart = normalizedPath.substring(normalizedRoot.length);
             const cleanRelative = relativePart.startsWith('/') ? relativePart.slice(1) : relativePart;
             
             if (cleanRelative) {
                 // Ensure forward slashes in the final path
                 this.webkitRelativePath = (rootName + '/' + cleanRelative).replace(/\\/g, '/');
             } else {
                 this.webkitRelativePath = this.name;
             }
             
             console.log('[TauriFile] path:', this.path, '-> webkitRelativePath:', this.webkitRelativePath);
        } else {
             this.webkitRelativePath = this.name;
        }

        this.lastModified = 0;
        this.size = 0; 
        this.type = this.guessType(this.name);
    }
    
    guessType(name) {
        if (name.endsWith('.mp4')) return 'video/mp4';
        if (name.endsWith('.json')) return 'application/json';
        if (name.endsWith('.png')) return 'image/png';
        return '';
    }

    async text() {
        const tauri = getTauri();
        if (!tauri) throw new Error("Tauri API not found");
        return await tauri.fs.readTextFile(this.path);
    }
    
    async arrayBuffer() {
        const tauri = getTauri();
        if (!tauri) throw new Error("Tauri API not found");
        const binary = await tauri.fs.readFile(this.path);
        return binary.buffer;
    }
}
// --- End Tauri Helper ---

// ============================================================
// Metadata Overlay Generator for FFmpeg (PNG icons + overlay filter)
// ============================================================
class MetadataOverlayGenerator {
    constructor() {
        // Gear mapping
        this.gearMap = {
            'GEAR_PARK': 'P',
            'GEAR_DRIVE': 'D',
            'GEAR_REVERSE': 'R',
            'GEAR_NEUTRAL': 'N'
        };
        
        // Autopilot mapping
        this.autopilotMap = {
            'NONE': '',
            'SELF_DRIVING': 'FSD',
            'AUTOSTEER': 'AP',
            'TACC': 'TACC'
        };
        
        // È¢ÑÂä†ËΩΩÂàπËΩ¶Ë∏èÊùøÂõæÊ†á
        this.brakeIconLoaded = false;
        this.brakeIconImg = null;
        this.loadBrakeIcon();
        
        // Colors for FFmpeg (hex format)
        this.colors = {
            white: 'ffffff',
            gray: '808080',
            green: '52c41a',
            red: 'ff4d4f',
            blue: '1890ff',
            orange: 'ffa500',
            dimGray: '606060'
        };
        
        // Icon size for overlay
        this.iconSize = 28;
        this.iconSpacing = 8;
        
        // Cache for generated PNG icons
        this.iconCache = new Map();
    }
    
    /**
     * Get font file path based on operating system
     */
    getFontPath() {
        if (typeof navigator !== 'undefined') {
            if (navigator.userAgent.includes('Windows')) {
                return "C\\\\:/Windows/Fonts/msyh.ttc";
            } else if (navigator.userAgent.includes('Mac')) {
                // Escape spaces for FFmpeg filter
                return "/System/Library/Fonts/Hiragino\\ Sans\\ GB.ttc";
            } else {
                return "/usr/share/fonts/truetype/dejavu/DejaVuSans.ttf";
            }
        }
        return "";
    }
    
    /**
     * Generate SVG icon as data URL
     */
    getSvgDataUrl(svgContent) {
        const encoded = encodeURIComponent(svgContent);
        return `data:image/svg+xml,${encoded}`;
    }
    
    /**
     * Create SVG for left blinker arrow
     */
    createBlinkerLeftSvg(active, size = 28) {
        const color = active ? '#52c41a' : 'rgba(255,255,255,0.3)';
        const stroke = active ? '#52c41a' : 'rgba(255,255,255,0.5)';
        return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" width="${size}" height="${size}">
            <path d="M20 8 L6 24 L20 40 L20 30 L42 30 L42 18 L20 18 Z" 
                  fill="${color}" stroke="${stroke}" stroke-width="2" stroke-linejoin="round"/>
        </svg>`;
    }
    
    /**
     * Create SVG for right blinker arrow
     */
    createBlinkerRightSvg(active, size = 28) {
        const color = active ? '#52c41a' : 'rgba(255,255,255,0.3)';
        const stroke = active ? '#52c41a' : 'rgba(255,255,255,0.5)';
        return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" width="${size}" height="${size}">
            <path d="M28 8 L42 24 L28 40 L28 30 L6 30 L6 18 L28 18 Z" 
                  fill="${color}" stroke="${stroke}" stroke-width="2" stroke-linejoin="round"/>
        </svg>`;
    }
    
    /**
     * Create SVG for brake icon
     */
    createBrakeSvg(active, size = 28) {
        const color = active ? '#ff4d4f' : 'rgba(255,255,255,0.4)';
        return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" width="${size}" height="${size}">
            <circle cx="24" cy="24" r="20" fill="none" stroke="${color}" stroke-width="2"/>
            <circle cx="24" cy="24" r="10" fill="none" stroke="${color}" stroke-width="2"/>
            <circle cx="24" cy="24" r="3" fill="${color}"/>
            <path d="M8 14 C2 18, 2 30, 8 34" fill="none" stroke="${color}" stroke-width="3" stroke-linecap="round"/>
        </svg>`;
    }
    
    /**
     * Create SVG for accelerator/throttle icon
     */
    createAcceleratorSvg(percent, size = 28) {
        const fillHeight = (percent / 100) * 20;
        const yPos = 26 - fillHeight;
        const color = percent > 0 ? '#73d13d' : 'rgba(255,255,255,0.4)';
        const fillRect = percent > 0 ? `<rect x="10" y="${yPos}" width="12" height="${fillHeight}" rx="2" fill="#73d13d" opacity="0.9"/>` : '';
        return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="${size}" height="${size}">
            <rect x="8" y="4" width="16" height="24" rx="3" fill="none" stroke="rgba(255,255,255,0.5)" stroke-width="2"/>
            <path d="M18 8 L13 16 L16 16 L14 24 L19 15 L16 15 L18 8 Z" fill="${color}"/>
            ${fillRect}
        </svg>`;
    }
    
    /**
     * Create SVG for autopilot/steering wheel icon
     */
    createAutopilotSvg(active, size = 28) {
        const color = active ? '#1890ff' : 'rgba(255,255,255,0.6)';
        return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="${size}" height="${size}">
            <circle cx="32" cy="32" r="26" fill="none" stroke="${color}" stroke-width="4"/>
            <circle cx="32" cy="32" r="8" fill="${color}"/>
            <rect x="6" y="29" width="17" height="6" rx="2" fill="${color}"/>
            <rect x="41" y="29" width="17" height="6" rx="2" fill="${color}"/>
            <rect x="29" y="41" width="6" height="17" rx="2" fill="${color}"/>
        </svg>`;
    }
    
    /**
     * Convert SVG to PNG using Canvas and return as base64
     */
    async svgToPngBase64(svgContent, size = 28) {
        return new Promise((resolve, reject) => {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');
            
            const img = new Image();
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            img.onload = () => {
                ctx.drawImage(img, 0, 0, size, size);
                URL.revokeObjectURL(url);
                // Get PNG as base64 (without data:image/png;base64, prefix)
                const dataUrl = canvas.toDataURL('image/png');
                const base64 = dataUrl.split(',')[1];
                resolve(base64);
            };
            
            img.onerror = () => {
                URL.revokeObjectURL(url);
                reject(new Error('Failed to load SVG'));
            };
            
            img.src = url;
        });
    }
    
    /**
     * Generate a complete metadata overlay PNG for a single frame
     * Uses bucket values for display to match the state key
     * Returns PNG as Uint8Array
     */
    /**
     * Generate a static background PNG for the overlay bar
     */
    async generateBackgroundPng() {
        const barWidth = 460;
        const barHeight = 65;
        const canvas = document.createElement('canvas');
        canvas.width = barWidth;
        canvas.height = barHeight;
        const ctx = canvas.getContext('2d');
        
        // Glassmorphism effect background (less transparent)
        ctx.save();
        const gradient = ctx.createLinearGradient(0, 0, 0, barHeight);
        gradient.addColorStop(0, 'rgba(20, 20, 20, 0.5)');
        gradient.addColorStop(1, 'rgba(5, 5, 5, 0.55)');
        ctx.fillStyle = gradient;
        
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(0, 0, barWidth, barHeight, 16);
        } else {
            const r = 16;
            ctx.moveTo(r, 0); ctx.lineTo(barWidth - r, 0); ctx.quadraticCurveTo(barWidth, 0, barWidth, r);
            ctx.lineTo(barWidth, barHeight - r); ctx.quadraticCurveTo(barWidth, barHeight, barWidth - r, barHeight);
            ctx.lineTo(r, barHeight); ctx.quadraticCurveTo(0, barHeight, 0, barHeight - r);
            ctx.lineTo(0, r); ctx.quadraticCurveTo(0, 0, r, 0);
        }
        ctx.fill();
        ctx.restore();
        
        return new Promise((resolve) => {
            canvas.toBlob((blob) => {
                blob.arrayBuffer().then(buffer => {
                    resolve({ data: new Uint8Array(buffer), width: barWidth, height: barHeight });
                });
            }, 'image/png');
        });
    }

    /**
     * Generate a complete metadata overlay PNG for a single frame
     * Returns an object { data: Uint8Array, width, height }
     */
    async generateMetadataOverlayPng(data) {
        // We use a fixed height for the bar - increased size
        const barHeight = 65;
        const barWidth = 460;
        const iconSize = 30;

        // Get values with fallbacks
        const speedKmh = Math.round((data.vehicleSpeedMps || 0) * 3.6);
        const speedDisplay = speedKmh >= 150 ? '150+' : `${speedKmh}`;
        const speedText = `${speedDisplay} km/h`;
        
        const gear = this.gearMap[data.gearState] || '--';
        const gearText = `[${gear}]`;
        
        // Autopilot state for steering wheel color
        const autopilotState = data.autopilotState || 'NONE';
        
        // Accelerator: use 10% bucket for both display and icon to match state key
        const accelPercent = Math.round(data.acceleratorPedalPosition || 0);
        const accelBucket = Math.floor(accelPercent / 10) * 10;
        
        // Steering angle: use 10¬∞ bucket to match state key
        const steeringAngle = Math.round(data.steeringWheelAngle || 0);
        const steeringBucket = Math.round(steeringAngle / 10) * 10;

        // Create actual canvas for drawing
        const canvas = document.createElement('canvas');
        canvas.width = barWidth;
        canvas.height = barHeight;
        const ctx = canvas.getContext('2d');
        
        // NO BACKGROUND DRAWN HERE - IT WILL BE OVERLAID SEPARATELY IN FFMPEG

        // Draw items (Using FIXED COORDINATES to prevent jittering)
        ctx.font = 'bold 24px "Noto Sans SC", Arial, sans-serif';
        ctx.textBaseline = 'middle';
        const yCenter = barHeight / 2;
        
        // Layout: Speed -> Gear -> Blinkers -> Brake -> Accel -> Steering Wheel
        
        // Speed (Fixed area, right-aligned at 125)
        ctx.fillStyle = '#ffffff';
        ctx.textAlign = 'right';
        ctx.fillText(speedText, 125, yCenter);
        
        // Gear (Fixed at 145)
        ctx.textAlign = 'left';
        let gearColor = '#ffffff';
        if (gear === 'D') gearColor = '#52c41a';
        else if (gear === 'R') gearColor = '#ff4d4f';
        ctx.fillStyle = gearColor;
        ctx.fillText(gearText, 145, yCenter);

        // Blinkers (Tightened gaps)
        try { this.drawLeftArrow(ctx, 200, yCenter, iconSize, data.blinkerOnLeft); } catch (e) { console.error('[drawLeftArrow]', e); }
        try { this.drawRightArrow(ctx, 240, yCenter, iconSize, data.blinkerOnRight); } catch (e) { console.error('[drawRightArrow]', e); }

        // Brake (Fixed at 290)
        try { this.drawBrakeIcon(ctx, 290, yCenter, iconSize, data.brakeApplied); } catch (e) { console.error('[drawBrakeIcon]', e); }

        // Accel / Power (Fixed at 340)
        // Use bucket value for icon fill (10% granularity), no percentage text
        try { this.drawAcceleratorIcon(ctx, 340, yCenter, iconSize, accelBucket); } catch (e) { console.error('[drawAcceleratorIcon]', e); }

        // Steering Wheel (Fixed at 390) - color based on autopilot state
        try { this.drawSteeringWheelIcon(ctx, 390, yCenter, iconSize, steeringBucket, autopilotState); } catch (e) { console.error('[drawSteeringWheelIcon]', e); }
        
        return new Promise((resolve, reject) => {
            canvas.toBlob((blob) => {
                if (!blob) {
                    reject(new Error('Failed to create PNG blob'));
                    return;
                }
                blob.arrayBuffer().then(buffer => {
                    resolve({ data: new Uint8Array(buffer), width: barWidth, height: barHeight });
                }).catch(reject);
            }, 'image/png');
        });
    }
    
    // Draw left arrow icon using Canvas
    drawLeftArrow(ctx, x, y, size, active) {
        const color = active ? '#52c41a' : 'rgba(255,255,255,0.2)';
        const shadowColor = active ? 'rgba(82, 196, 26, 0.4)' : 'transparent';
        
        ctx.save();
        if (active) {
            ctx.shadowBlur = 6;
            ctx.shadowColor = shadowColor;
        }
        ctx.fillStyle = color;
        ctx.beginPath();
        const halfSize = size / 2;
        // More stylish arrow
        ctx.moveTo(x + size * 0.9, y - halfSize * 0.4);
        ctx.lineTo(x + halfSize * 1.1, y - halfSize * 0.4);
        ctx.lineTo(x + halfSize * 1.1, y - halfSize * 0.8);
        ctx.lineTo(x + size * 0.1, y);
        ctx.lineTo(x + halfSize * 1.1, y + halfSize * 0.8);
        ctx.lineTo(x + halfSize * 1.1, y + halfSize * 0.4);
        ctx.lineTo(x + size * 0.9, y + halfSize * 0.4);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
    
    // Draw right arrow icon using Canvas
    drawRightArrow(ctx, x, y, size, active) {
        const color = active ? '#52c41a' : 'rgba(255,255,255,0.2)';
        const shadowColor = active ? 'rgba(82, 196, 26, 0.4)' : 'transparent';
        
        ctx.save();
        if (active) {
            ctx.shadowBlur = 6;
            ctx.shadowColor = shadowColor;
        }
        ctx.fillStyle = color;
        ctx.beginPath();
        const halfSize = size / 2;
        // More stylish arrow
        ctx.moveTo(x + size * 0.1, y - halfSize * 0.4);
        ctx.lineTo(x + halfSize * 0.9, y - halfSize * 0.4);
        ctx.lineTo(x + halfSize * 0.9, y - halfSize * 0.8);
        ctx.lineTo(x + size * 0.9, y);
        ctx.lineTo(x + halfSize * 0.9, y + halfSize * 0.8);
        ctx.lineTo(x + halfSize * 0.9, y + halfSize * 0.4);
        ctx.lineTo(x + size * 0.1, y + halfSize * 0.4);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }
    
    // Draw autopilot icon (steering wheel)
    drawAutopilotIcon(ctx, x, y, size) {
        ctx.save();
        ctx.strokeStyle = '#1890ff';
        ctx.fillStyle = '#1890ff';
        ctx.lineWidth = 2.5;
        const r = size / 2 - 2;
        const cx = x + size / 2;
        const cy = y;
        
        // Outer circle with glow
        ctx.shadowBlur = 4;
        ctx.shadowColor = 'rgba(24, 144, 255, 0.5)';
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.stroke();
        
        // Center dot
        ctx.beginPath();
        ctx.arc(cx, cy, 3.5, 0, Math.PI * 2);
        ctx.fill();
        
        // Spokes (more like a Tesla steering wheel)
        ctx.beginPath();
        ctx.moveTo(cx - r + 3, cy);
        ctx.lineTo(cx - 4, cy);
        ctx.moveTo(cx + 4, cy);
        ctx.lineTo(cx + r - 3, cy);
        ctx.moveTo(cx, cy + 4);
        ctx.lineTo(cx, cy + r - 3);
        ctx.stroke();
        ctx.restore();
    }
    
    // Draw accelerator icon (rectangle with fill level like web version)
    drawAcceleratorIcon(ctx, x, y, size, percent) {
        const active = percent > 0;
        
        ctx.save();
        
        // Rectangle dimensions
        const rectWidth = size * 0.6;
        const rectHeight = size * 0.9;
        const rectX = x + (size - rectWidth) / 2;
        const rectY = y - rectHeight / 2;
        const cornerRadius = 3;
        
        // Draw outer rectangle border
        ctx.strokeStyle = active ? '#52c41a' : 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(rectX, rectY, rectWidth, rectHeight, cornerRadius);
        } else {
            // Fallback for older browsers
            ctx.moveTo(rectX + cornerRadius, rectY);
            ctx.lineTo(rectX + rectWidth - cornerRadius, rectY);
            ctx.quadraticCurveTo(rectX + rectWidth, rectY, rectX + rectWidth, rectY + cornerRadius);
            ctx.lineTo(rectX + rectWidth, rectY + rectHeight - cornerRadius);
            ctx.quadraticCurveTo(rectX + rectWidth, rectY + rectHeight, rectX + rectWidth - cornerRadius, rectY + rectHeight);
            ctx.lineTo(rectX + cornerRadius, rectY + rectHeight);
            ctx.quadraticCurveTo(rectX, rectY + rectHeight, rectX, rectY + rectHeight - cornerRadius);
            ctx.lineTo(rectX, rectY + cornerRadius);
            ctx.quadraticCurveTo(rectX, rectY, rectX + cornerRadius, rectY);
        }
        ctx.stroke();
        
        // Draw fill level from bottom
        if (active && percent > 0) {
            const fillHeight = (percent / 100) * (rectHeight - 4);
            const fillY = rectY + rectHeight - 2 - fillHeight;
            
            ctx.shadowBlur = 4;
            ctx.shadowColor = 'rgba(82, 196, 26, 0.5)';
            ctx.fillStyle = '#52c41a';
            ctx.beginPath();
            if (ctx.roundRect) {
                ctx.roundRect(rectX + 2, fillY, rectWidth - 4, fillHeight, Math.min(cornerRadius - 1, 2));
            } else {
                ctx.rect(rectX + 2, fillY, rectWidth - 4, fillHeight);
            }
            ctx.fill();
        }
        
        // Draw small lightning bolt icon inside (smaller, at top)
        const boltSize = size * 0.35;
        const boltX = x + size / 2;
        const boltY = rectY + boltSize / 2 + 3;
        ctx.fillStyle = active ? '#ffffff' : 'rgba(255,255,255,0.4)';
        ctx.beginPath();
        ctx.moveTo(boltX + boltSize * 0.1, boltY - boltSize * 0.4);
        ctx.lineTo(boltX - boltSize * 0.15, boltY + boltSize * 0.05);
        ctx.lineTo(boltX + boltSize * 0.02, boltY + boltSize * 0.05);
        ctx.lineTo(boltX - boltSize * 0.1, boltY + boltSize * 0.4);
        ctx.lineTo(boltX + boltSize * 0.15, boltY - boltSize * 0.05);
        ctx.lineTo(boltX - boltSize * 0.02, boltY - boltSize * 0.05);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
    }
    
    // È¢ÑÂä†ËΩΩÂàπËΩ¶Ë∏èÊùøSVGÂõæÊ†á
    loadBrakeIcon() {
        const svgContent = `<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path d="M821.394 861.482H200.242c-23.709 0-44.013-20.191-45.124-44.975 0 0-30.555-129.896-30.044-166.228 0.325-23.102 15.23-164.3 15.23-164.3 2.449-27.739 18.019-48.258 42.686-48.258h646.233c24.667 0 44.357 21.769 43.759 48.258l14.579 163.622-22.043 166.906c-0.56 24.784-20.414 44.975-44.124 44.975z m24.716-358.364l0.292-10.498c0.23-8.275-6.452-15.059-14.85-15.059H186.497c-8.397 0-14.828 6.784-14.291 15.059l0.681 10.498c0.534 8.232 7.802 14.954 16.153 14.954h641.472c8.35 0 15.37-6.722 15.598-14.954z m8.739 81.304l0.296-10.264c0.233-8.091-6.628-14.724-15.248-14.724H177.735c-8.62 0-15.226 6.633-14.681 14.724l0.691 10.264c0.542 8.049 7.999 14.622 16.571 14.622H838.84c8.574 0 15.777-6.572 16.009-14.622z m6.172 79.506l0.298-10.038c0.235-7.912-6.747-14.399-15.516-14.399H172.234c-8.769 0-15.494 6.487-14.945 14.399l0.695 10.038c0.545 7.872 8.126 14.3 16.847 14.3h669.91c8.721 0 16.047-6.428 16.28-14.3z m-14.901 77.765l0.282-9.819c0.222-7.74-6.466-14.085-14.863-14.085H186.526c-8.397 0-14.841 6.345-14.322 14.085l0.659 9.819c0.517 7.701 7.772 13.989 16.123 13.989h641.548c8.351 0 15.365-6.288 15.586-13.989z m-8.749 76.081l0.267-9.608c0.21-7.573-6.189-13.781-14.222-13.781H206.385c-8.033 0-14.202 6.208-13.711 13.781l0.623 9.608c0.489 7.535 7.425 13.688 15.415 13.688h613.751c7.99 0.001 14.698-6.152 14.908-13.688z m1.869-378.856l36.038-94.167 21.623-119.775H785.183L752.749 356.56l-118.926 82.358H839.24z" fill="#ffffff"/></svg>`;
        const blob = new Blob([svgContent], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        this.brakeIconImg = new Image();
        this.brakeIconImg.onload = () => {
            this.brakeIconLoaded = true;
            URL.revokeObjectURL(url);
        };
        this.brakeIconImg.src = url;
    }
    
    // Draw brake icon (brake pedal shape from SVG image)
    drawBrakeIcon(ctx, x, y, size, active) {
        ctx.save();
        
        try {
            if (active) {
                ctx.shadowBlur = 6;
                ctx.shadowColor = 'rgba(255, 77, 79, 0.5)';
            }
            
            // ÁªòÂà∂ÂõæÊ†áÔºåÂ±Ö‰∏≠ÂØπÈΩê - ‰ΩøÁî®ËæÉÂ§ßÂ∞∫ÂØ∏
            const iconSize = size * 1.5;
            const iconX = x + (size - iconSize) / 2;
            const iconY = y - iconSize / 2;
            
            // ‰ΩøÁî®Path2DÁªòÂà∂SVGË∑ØÂæÑ
            const color = active ? '#ff4d4f' : 'rgba(255,255,255,0.2)';
            ctx.fillStyle = color;
            
            // SVG viewBoxÊòØ0 0 1024 1024ÔºåË∑ØÂæÑÂÆûÈôÖËåÉÂõ¥Á∫¶ x:140-880, y:162-861
            // ÈúÄË¶ÅË∞ÉÊï¥ÂÅèÁßª‰ΩøÂÖ∂Â±Ö‰∏≠
            const svgSize = 1024;
            const pathWidth = 880 - 140; // Á∫¶740
            const pathHeight = 861 - 162; // Á∫¶699
            const pathCenterX = 140 + pathWidth / 2; // Á∫¶510
            const pathCenterY = 162 + pathHeight / 2; // Á∫¶511
            
            const scale = iconSize / svgSize;
            
            // Â∞ÜË∑ØÂæÑ‰∏≠ÂøÉÁßªÂà∞ÂõæÊ†á‰∏≠ÂøÉ
            ctx.translate(iconX + iconSize / 2, iconY + iconSize / 2);
            ctx.scale(scale, scale);
            ctx.translate(-pathCenterX, -pathCenterY);
            
            const path = new Path2D('M821.394 861.482H200.242c-23.709 0-44.013-20.191-45.124-44.975 0 0-30.555-129.896-30.044-166.228 0.325-23.102 15.23-164.3 15.23-164.3 2.449-27.739 18.019-48.258 42.686-48.258h646.233c24.667 0 44.357 21.769 43.759 48.258l14.579 163.622-22.043 166.906c-0.56 24.784-20.414 44.975-44.124 44.975z m24.716-358.364l0.292-10.498c0.23-8.275-6.452-15.059-14.85-15.059H186.497c-8.397 0-14.828 6.784-14.291 15.059l0.681 10.498c0.534 8.232 7.802 14.954 16.153 14.954h641.472c8.35 0 15.37-6.722 15.598-14.954z m8.739 81.304l0.296-10.264c0.233-8.091-6.628-14.724-15.248-14.724H177.735c-8.62 0-15.226 6.633-14.681 14.724l0.691 10.264c0.542 8.049 7.999 14.622 16.571 14.622H838.84c8.574 0 15.777-6.572 16.009-14.622z m6.172 79.506l0.298-10.038c0.235-7.912-6.747-14.399-15.516-14.399H172.234c-8.769 0-15.494 6.487-14.945 14.399l0.695 10.038c0.545 7.872 8.126 14.3 16.847 14.3h669.91c8.721 0 16.047-6.428 16.28-14.3z m-14.901 77.765l0.282-9.819c0.222-7.74-6.466-14.085-14.863-14.085H186.526c-8.397 0-14.841 6.345-14.322 14.085l0.659 9.819c0.517 7.701 7.772 13.989 16.123 13.989h641.548c8.351 0 15.365-6.288 15.586-13.989z m-8.749 76.081l0.267-9.608c0.21-7.573-6.189-13.781-14.222-13.781H206.385c-8.033 0-14.202 6.208-13.711 13.781l0.623 9.608c0.489 7.535 7.425 13.688 15.415 13.688h613.751c7.99 0.001 14.698-6.152 14.908-13.688z m1.869-378.856l36.038-94.167 21.623-119.775H785.183L752.749 356.56l-118.926 82.358H839.24z');
            ctx.fill(path);
        } catch (err) {
            console.error('[drawBrakeIcon] Error:', err);
        }
        
        ctx.restore();
    }
    
    // Draw steering wheel icon with rotation and autopilot color (matches web version)
    drawSteeringWheelIcon(ctx, x, y, size, angle, autopilotState) {
        // Determine color based on autopilot state
        let color = 'rgba(255,255,255,0.9)'; // Default: white
        let shadowColor = 'transparent';
        
        if (autopilotState === 'SELF_DRIVING') {
            color = '#52c41a'; // Green for full self-driving
            shadowColor = 'rgba(82, 196, 26, 0.5)';
        } else if (autopilotState === 'AUTOSTEER' || autopilotState === 'TACC') {
            color = '#1890ff'; // Blue for autopilot/TACC
            shadowColor = 'rgba(24, 144, 255, 0.5)';
        }
        
        ctx.save();
        
        // Apply shadow for active states
        if (shadowColor !== 'transparent') {
            ctx.shadowBlur = 6;
            ctx.shadowColor = shadowColor;
        }
        
        // Move to center of icon and rotate
        const cx = x + size / 2;
        const cy = y;
        ctx.translate(cx, cy);
        ctx.rotate((angle * Math.PI) / 180);
        
        // Scale factor: SVG viewBox is 64x64, we scale to fit 'size'
        const scale = size / 64;
        const r = 28 * scale; // outer ring radius (from SVG: r="28")
        const hubR = 9 * scale; // hub radius (from SVG: r="9")
        const strokeWidth = 5 * scale;
        const spokeHeight = 8 * scale;
        const spokeWidth = 19 * scale;
        const spokeRx = 2 * scale;
        
        // Draw outer ring (steering wheel rim)
        ctx.strokeStyle = color;
        ctx.lineWidth = strokeWidth;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.stroke();
        
        // Draw center hub circle
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(0, 0, hubR, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw three spokes as rounded rectangles (like web SVG)
        ctx.fillStyle = color;
        
        // Left spoke: rect x="4" y="28" width="19" height="8" (centered at y=32)
        // In our coordinate system (centered at 0,0): x from -28 to -9, y from -4 to +4
        const leftSpokeX = -r - strokeWidth / 2;
        const leftSpokeY = -spokeHeight / 2;
        this.drawRoundedRect(ctx, leftSpokeX, leftSpokeY, spokeWidth, spokeHeight, spokeRx);
        ctx.fill();
        
        // Right spoke: rect x="41" y="28" width="19" height="8"
        // In our coordinate system: x from +9 to +28, y from -4 to +4
        const rightSpokeX = r - spokeWidth + strokeWidth / 2;
        const rightSpokeY = -spokeHeight / 2;
        this.drawRoundedRect(ctx, rightSpokeX, rightSpokeY, spokeWidth, spokeHeight, spokeRx);
        ctx.fill();
        
        // Bottom spoke: rect x="28" y="41" width="8" height="19"
        // In our coordinate system: x from -4 to +4, y from +9 to +28
        const bottomSpokeX = -spokeHeight / 2;
        const bottomSpokeY = hubR;
        this.drawRoundedRect(ctx, bottomSpokeX, bottomSpokeY, spokeHeight, spokeWidth, spokeRx);
        ctx.fill();
        
        ctx.restore();
    }
    
    // Helper: draw rounded rectangle
    drawRoundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(x, y, width, height, radius);
        } else {
            // Fallback for older browsers
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }
    }
    
    /**
     * Generate unique key for metadata state (for caching overlay PNGs)
     */
    getMetadataStateKey(data) {
        // Real speed (1 km/h granularity)
        const speedKmh = Math.round((data.vehicleSpeedMps || 0) * 3.6);
        
        const gear = this.gearMap[data.gearState] || '--';
        
        // Accelerator bucket: 10% granularity (0, 10, 20, ..., 100) to reduce unique states
        // while maintaining reasonable visual accuracy
        const accelPercent = Math.round(data.acceleratorPedalPosition || 0);
        const accelBucket = Math.floor(accelPercent / 10) * 10;
        
        // Steering angle bucket: 10¬∞ granularity to reduce unique states
        const steeringAngle = Math.round(data.steeringWheelAngle || 0);
        const steeringBucket = Math.round(steeringAngle / 10) * 10;
        
        return `${speedKmh}_${gear}_${data.blinkerOnLeft ? 1 : 0}_${data.blinkerOnRight ? 1 : 0}_${data.autopilotState || 'NONE'}_${accelBucket}_${data.brakeApplied ? 1 : 0}_${steeringBucket}`;
    }
    
    /**
     * Get display values from state key
     */
    parseStateKey(key) {
        const parts = key.split('_');
        return {
            speedBucket: parseInt(parts[0]),
            gear: parts[1],
            blinkerLeft: parts[2] === '1',
            blinkerRight: parts[3] === '1',
            autopilotState: parts[4],
            accelBucket: parseInt(parts[5]),
            brakeApplied: parts[6] === '1',
            steeringBucket: parseInt(parts[7] || '0')
        };
    }
    
    /**
     * Generate all unique overlay PNGs needed for the video and save them
     * Returns a map of stateKey -> pngPath, or null if too many unique states
     */
    async generateOverlayPngs(allMetadata, clipSegments, workDir, width = 1920, height = 1080, progressCallback = null, language = 'zh-TW') {
        const tauri = window.__TAURI__;
        const fs = tauri.fs;
        
        const pathSeparator = workDir.includes('\\') ? '\\' : '/';
        const timestamp = Date.now();
        const pngDir = `${workDir}${pathSeparator}overlay_pngs_${timestamp}`;
        
        // Collect all unique metadata states first
        const uniqueStates = new Map();
        
        for (const segMeta of allMetadata) {
            if (!segMeta.metadata) continue;
            for (const item of segMeta.metadata) {
                if (!item.data) continue;
                const key = this.getMetadataStateKey(item.data);
                if (!uniqueStates.has(key)) {
                    uniqueStates.set(key, item.data);
                }
            }
        }
        
        // Limit the number of unique PNGs to avoid FFmpeg command line length issues
        const MAX_UNIQUE_PNGS = 500;
        if (uniqueStates.size > MAX_UNIQUE_PNGS) {
            console.warn(`[MetadataOverlay] Too many unique states (${uniqueStates.size}), falling back to ASS subtitles`);
            return null;
        }
        
        progressCallback?.(language === 'zh-TW' ? `ÁîüÊàê ${uniqueStates.size} ÂÄã‰∏≠ÁπºË≥áÊñôË¶ÜËìãÂ±§...` : `Generating ${uniqueStates.size} metadata overlays...`);
        
        // Create directory for PNGs
        await fs.mkdir(pngDir, { recursive: true });
        
        // Generate and save background PNG first
        const bgResult = await this.generateBackgroundPng();
        const bgPath = `${pngDir}${pathSeparator}background.png`;
        await fs.writeFile(bgPath, bgResult.data);

        // Generate PNG for each unique state
        const pngPaths = new Map();
        pngPaths.set('__background__', bgPath);
        let idx = 0;
        
        for (const [key, data] of uniqueStates) {
            try {
                const result = await this.generateMetadataOverlayPng(data);
                const pngPath = `${pngDir}${pathSeparator}overlay_${idx}.png`;
                
                await fs.writeFile(pngPath, result.data);
                pngPaths.set(key, pngPath);
                idx++;
                
                if (idx % 20 === 0) {
                    progressCallback?.(language === 'zh-TW' ? `ÁîüÊàêË¶ÜËìãÂ±§ ${idx}/${uniqueStates.size}...` : `Generating overlay ${idx}/${uniqueStates.size}...`);
                    // Short sleep to yield main thread
                    await new Promise(r => setTimeout(r, 0));
                }
            } catch (err) {
                console.error(`[MetadataOverlay] Failed to generate PNG for key ${key}:`, err);
                // Continue with next state instead of failing entirely
            }
        }
        
        return { pngDir, pngPaths };
    }

    /**
     * Generate FFmpeg filter for metadata overlay using concat demuxer (STABLE & FAST)
     */
    async generateOverlayFilter(allMetadata, clipSegments, pngPaths, workDir, videoInputCount = 1) {
        const pathSeparator = workDir.includes('\\') ? '\\' : '/';
        const concatFilePath = `${workDir}${pathSeparator}metadata_concat.txt`;
        const tauri = window.__TAURI__;
        
        // Build timeline of metadata changes
        const timeline = [];
        let accumulatedTime = 0;
        let totalVideoDuration = 0;
        
        for (let segIdx = 0; segIdx < clipSegments.length; segIdx++) {
            const clipSeg = clipSegments[segIdx];
            const clipStart = clipSeg.clipStart || 0;
            const clipEnd = clipSeg.clipEnd || (clipSeg.clipDuration || 60);
            totalVideoDuration += (clipEnd - clipStart);
        }

        // Create a transparent PNG for empty gaps (same size as metadata overlay)
        const transparentPngPath = `${workDir}${pathSeparator}empty_transparent.png`;
        const transCanvas = document.createElement('canvas');
        // Must match metadata overlay dimensions (460x65) for concat demuxer
        transCanvas.width = 460;
        transCanvas.height = 65;
        const transBlob = await new Promise(r => transCanvas.toBlob(r, 'image/png'));
        await tauri.fs.writeFile(transparentPngPath, new Uint8Array(await transBlob.arrayBuffer()));

        // Debug: log pngPaths content
        console.log(`[Metadata Overlay] pngPaths size: ${pngPaths.size}`);
        const pngPathKeys = Array.from(pngPaths.keys()).slice(0, 10);
        console.log(`[Metadata Overlay] First 10 pngPath keys:`, pngPathKeys);

        accumulatedTime = 0;
        let lastEndTime = 0;
        let concatLines = [];
        const safeTransPath = transparentPngPath.replace(/\\/g, '/').replace(/'/g, "'\\''");

        for (let segIdx = 0; segIdx < clipSegments.length; segIdx++) {
            const clipSeg = clipSegments[segIdx];
            const segmentMetadata = allMetadata.find(m => m.segmentIndex === segIdx);
            const clipStart = clipSeg.clipStart || 0;
            const clipEnd = clipSeg.clipEnd || (clipSeg.clipDuration || 60);
            const segmentDuration = clipEnd - clipStart;
            
            console.log(`[Metadata Overlay] Segment ${segIdx}: clipStart=${clipStart}, clipEnd=${clipEnd}, duration=${segmentDuration}`);
            console.log(`[Metadata Overlay] Segment ${segIdx}: hasMetadata=${!!segmentMetadata}, metadataCount=${segmentMetadata?.metadata?.length || 0}`);
            
            if (segmentMetadata && segmentMetadata.metadata && segmentMetadata.metadata.length > 0) {
                const metadata = segmentMetadata.metadata;
                console.log(`[Metadata Overlay] Segment ${segIdx}: metadata time range: ${metadata[0]?.time} to ${metadata[metadata.length-1]?.time}`);
                
                // Fixed 0.5 second update interval
                const updateInterval = 0.5;
                const numIntervals = Math.ceil(segmentDuration / updateInterval);
                console.log(`[Metadata Overlay] Segment ${segIdx}: numIntervals=${numIntervals}`);
                
                // Track last valid metadata for fallback when no match found
                let lastValidItem = metadata.find(m => m && m.data) || null;
                let matchCount = 0;
                
                // Debug: log some metadata samples to verify data variety
                const sampleIndices = [0, Math.floor(metadata.length/4), Math.floor(metadata.length/2), Math.floor(metadata.length*3/4), metadata.length-1];
                console.log(`[Metadata Overlay] Sample metadata items:`);
                for (const idx of sampleIndices) {
                    const item = metadata[idx];
                    if (item && item.data) {
                        const key = this.getMetadataStateKey(item.data);
                        console.log(`  [${idx}] time=${item.time?.toFixed(2)}, speed=${(item.data.vehicleSpeedMps*3.6).toFixed(1)}km/h, gear=${item.data.gearState}, key=${key}`);
                    }
                }
                
                for (let i = 0; i < numIntervals; i++) {
                    const intervalStart = clipStart + i * updateInterval;
                    const intervalEnd = Math.min(clipStart + (i + 1) * updateInterval, clipEnd);
                    const intervalDuration = intervalEnd - intervalStart;
                    
                    if (intervalDuration <= 0) continue;
                    
                    // Find the best metadata item for this interval
                    // Priority: latest item <= intervalStart, then closest, then last valid
                    let bestItem = null;
                    let closestItem = null;
                    let closestDist = Infinity;
                    for (const item of metadata) {
                        if (!item || !item.data) continue;
                        const dist = Math.abs(item.time - intervalStart);
                        if (dist < closestDist) {
                            closestDist = dist;
                            closestItem = item;
                        }
                        if (item.time <= intervalStart && (!bestItem || item.time > bestItem.time)) {
                            bestItem = item;
                        }
                    }
                    
                    const selectedItem = bestItem || closestItem || lastValidItem;
                    if (!selectedItem || !selectedItem.data) continue;
                    lastValidItem = selectedItem;
                    matchCount++;
                    
                    const relativeStart = accumulatedTime + (intervalStart - clipStart);
                    
                    // Fill gap before this interval if exists
                    if (relativeStart > lastEndTime + 0.001) {
                        concatLines.push(`file '${safeTransPath}'`);
                        concatLines.push(`duration ${(relativeStart - lastEndTime).toFixed(4)}`);
                    }

                    const key = this.getMetadataStateKey(selectedItem.data);
                    const pngPath = pngPaths.get(key);
                    
                    // Debug: log first 5, last 5, and any key changes
                    const isFirst5 = i < 5;
                    const isLast5 = i >= numIntervals - 5;
                    const prevKey = i > 0 ? this._lastLoggedKey : null;
                    const keyChanged = prevKey && key !== prevKey;
                    this._lastLoggedKey = key;
                    
                    if (isFirst5 || isLast5 || keyChanged) {
                        console.log(`[Metadata Overlay] Interval ${i}: time=${intervalStart.toFixed(2)}, selectedTime=${selectedItem.time?.toFixed(2)}, key=${key}, pngPath=${pngPath ? 'found' : 'NOT FOUND'}`);
                    }
                    
                    if (pngPath) {
                        // FFmpeg concat demuxer needs forward slashes even on Windows
                        const safePath = pngPath.replace(/\\/g, '/').replace(/'/g, "'\\''");
                        concatLines.push(`file '${safePath}'`);
                        concatLines.push(`duration ${intervalDuration.toFixed(4)}`);
                        lastEndTime = relativeStart + intervalDuration;
                    } else {
                        // PNG not found for this key, use transparent placeholder but still advance time
                        console.log(`[Metadata Overlay] PNG not found for key: ${key}, using transparent`);
                        concatLines.push(`file '${safeTransPath}'`);
                        concatLines.push(`duration ${intervalDuration.toFixed(4)}`);
                        lastEndTime = relativeStart + intervalDuration;
                    }
                }
                console.log(`[Metadata Overlay] Segment ${segIdx}: matched ${matchCount} intervals`);
            }
            // Use actual clipped duration, not full segment duration
            accumulatedTime += segmentDuration;
        }

        console.log(`[Metadata Overlay] Generated ${concatLines.length / 2} entries, lastEndTime: ${lastEndTime}, totalDuration: ${totalVideoDuration}`);
        console.log(`[Metadata Overlay] Concat file content (first 10 lines):`, concatLines.slice(0, 20).join('\n'));
        console.log(`[Metadata Overlay] Concat file content (last 10 lines):`, concatLines.slice(-20).join('\n'));

        // FFmpeg concat demuxer requires entries to cover the full duration
        if (lastEndTime < totalVideoDuration) {
            const remaining = totalVideoDuration - lastEndTime;
            if (remaining > 0.001) {
                console.log(`[Metadata Overlay] Filling remaining time: ${remaining.toFixed(4)}s`);
                concatLines.push(`file '${safeTransPath}'`);
                concatLines.push(`duration ${remaining.toFixed(4)}`);
            }
        }
        
        // Final line for concat demuxer bug - needs one last file entry without duration
        // for images to ensure the last duration is respected
        if (concatLines.length > 0) {
            concatLines.push(`file '${safeTransPath}'`);
        }

        await tauri.fs.writeFile(concatFilePath, new TextEncoder().encode(concatLines.join('\n')));

        // FFmpeg position (center bottom 97%)
        const xExpr = '(W-w)/2';
        const yExpr = '(H*0.97-h/2)';

        // Return the concat input and a SIMPLE overlay filter
        return {
            concatFile: concatFilePath,
            filter: `overlay=x=${xExpr}:y=${yExpr}`,
            inputIdx: videoInputCount // This will be the next input index
        };
    }
}

// ============================================================
// ASS Subtitle Generator for FFmpeg Metadata Overlay (Fallback)
// ============================================================
class AssSubtitleGenerator {
    constructor() {
        // ASS style constants
        this.styles = {
            // Style for metadata display at bottom center
            metadata: {
                name: 'Metadata',
                fontName: 'Microsoft YaHei',  // Will be overridden based on OS
                fontSize: 26,
                primaryColor: '&H00FFFFFF',   // White
                outlineColor: '&H00000000',   // Black outline
                backColor: '&H80000000',      // Semi-transparent black background
                bold: 1,
                outline: 2,
                shadow: 0,
                alignment: 2,  // Bottom center
                marginV: 25
            }
        };
        
        // Gear mapping
        this.gearMap = {
            'GEAR_PARK': 'P',
            'GEAR_DRIVE': 'D',
            'GEAR_REVERSE': 'R',
            'GEAR_NEUTRAL': 'N'
        };
        
        // Autopilot mapping
        this.autopilotMap = {
            'NONE': '',
            'SELF_DRIVING': 'FSD',
            'AUTOSTEER': 'AP',
            'TACC': 'TACC'
        };
        
        // ASS colors in BGR format (&HBBGGRR)
        this.colors = {
            white: '&H00FFFFFF',
            gray: '&H00808080',
            green: '&H001AC452',      // #52C41A
            red: '&H004F4DFF',         // #FF4D4F
            blue: '&H00FF9018',        // #1890FF
            orange: '&H0000A5FF',      // #FFA500
            dimGray: '&H00606060'
        };
    }
    
    /**
     * Get font name based on operating system
     */
    getFontName() {
        if (typeof navigator !== 'undefined') {
            if (navigator.userAgent.includes('Windows')) {
                return 'Microsoft YaHei';
            } else if (navigator.userAgent.includes('Mac')) {
                return 'Hiragino Sans GB';
            }
        }
        return 'Arial';
    }
    
    /**
     * Generate ASS header with styles
     * @param {number} width - Video width
     * @param {number} height - Video height
     * @returns {string} ASS header
     */
    generateHeader(width = 1920, height = 1080) {
        const fontName = this.getFontName();
        const style = this.styles.metadata;
        
        return `[Script Info]
Title: TeslaCam Metadata Overlay
ScriptType: v4.00+
PlayResX: ${width}
PlayResY: ${height}
ScaledBorderAndShadow: yes

[V4+ Styles]
Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding
Style: ${style.name},${fontName},${style.fontSize},${style.primaryColor},${style.primaryColor},${style.outlineColor},${style.backColor},${style.bold},0,0,0,100,100,0,0,3,${style.outline},${style.shadow},${style.alignment},10,10,${style.marginV},1

[Events]
Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text
`;
    }
    
    /**
     * Format time for ASS (H:MM:SS.cc format)
     * @param {number} seconds - Time in seconds
     * @returns {string} Formatted time string
     */
    formatAssTime(seconds) {
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        const cs = Math.floor((seconds % 1) * 100);
        return `${h}:${String(m).padStart(2, '0')}:${String(s).padStart(2, '0')}.${String(cs).padStart(2, '0')}`;
    }
    
    /**
     * Create colored text with ASS tags
     * @param {string} text - Text content
     * @param {string} color - ASS color
     * @returns {string} Colored text with ASS tags
     */
    colorText(text, color) {
        return `{\\c${color}}${text}{\\c${this.colors.white}}`;
    }
    
    /**
     * Format metadata to display text with colors (no ASS drawing, reliable text only)
     * @param {Object} data - Metadata object
     * @param {string} lang - Language code ('en' or 'zh-TW')
     * @returns {string} Formatted display text with ASS color commands
     */
    formatMetadataText(data, lang = 'zh-TW') {
        if (!data) return '';
        
        const parts = [];
        const c = this.colors;
        
        // Speed
        const speedKmh = Math.round((data.vehicleSpeedMps || 0) * 3.6);
        parts.push(`${speedKmh} km/h`);
        
        // Gear with color
        const gear = this.gearMap[data.gearState] || '--';
        let gearColor = c.white;
        if (gear === 'D') gearColor = c.green;
        else if (gear === 'R') gearColor = c.red;
        parts.push(this.colorText(`[${gear}]`, gearColor));
        
        // Blinkers using simple arrow symbols with colors
        // Left blinker: use colored arrow
        const leftArrow = data.blinkerOnLeft 
            ? this.colorText('‚óÑ', c.green)
            : this.colorText('‚óÑ', c.dimGray);
        // Right blinker
        const rightArrow = data.blinkerOnRight 
            ? this.colorText('‚ñ∫', c.green)
            : this.colorText('‚ñ∫', c.dimGray);
        parts.push(leftArrow);
        parts.push(rightArrow);
        
        // Autopilot (if active)
        const autopilot = this.autopilotMap[data.autopilotState] || '';
        if (autopilot && data.autopilotState !== 'NONE') {
            parts.push(this.colorText(`@${autopilot}`, c.blue));
        }
        
        // Accelerator with lightning symbol and percentage
        const accelPercent = Math.round(data.acceleratorPedalPosition || 0);
        if (accelPercent > 0) {
            parts.push(this.colorText(`‚Üë${accelPercent}%`, c.green));
        } else {
            parts.push(this.colorText('‚Üë', c.dimGray));
        }
        
        // Brake with symbol
        if (data.brakeApplied) {
            parts.push(this.colorText('‚óèBRAKE', c.red));
        } else {
            parts.push(this.colorText('‚óã', c.dimGray));
        }
        
        return parts.join('  ');
    }
    
    /**
     * Generate a single dialogue line for ASS
     * @param {number} startTime - Start time in seconds
     * @param {number} endTime - End time in seconds
     * @param {string} text - Text to display
     * @returns {string} ASS dialogue line
     */
    generateDialogue(startTime, endTime, text) {
        const start = this.formatAssTime(startTime);
        const end = this.formatAssTime(endTime);
        // Escape special ASS characters
        const escapedText = text.replace(/\\/g, '\\\\').replace(/\{/g, '\\{').replace(/\}/g, '\\}');
        return `Dialogue: 0,${start},${end},Metadata,,0,0,0,,${escapedText}`;
    }
    
    /**
     * Generate complete ASS subtitle file content from metadata
     * @param {Array} allMetadata - Array of segment metadata from loadMetadataForSegments
     * @param {Array} clipSegments - Array of clip segments with timing info
     * @param {string} lang - Language code
     * @param {number} width - Video width
     * @param {number} height - Video height
     * @returns {string} Complete ASS file content
     */
    generateAssContent(allMetadata, clipSegments, lang = 'zh-TW', width = 1920, height = 1080) {
        let content = this.generateHeader(width, height);
        const dialogues = [];
        
        // Track accumulated time across segments
        let accumulatedTime = 0;
        
        for (let segIdx = 0; segIdx < clipSegments.length; segIdx++) {
            const clipSeg = clipSegments[segIdx];
            const segmentMetadata = allMetadata.find(m => m.segmentIndex === segIdx);
            
            if (!segmentMetadata || !segmentMetadata.metadata || segmentMetadata.metadata.length === 0) {
                accumulatedTime += clipSeg.clipDuration;
                continue;
            }
            
            const metadata = segmentMetadata.metadata;
            const clipStart = clipSeg.clipStart;
            const clipEnd = clipSeg.clipEnd;
            
            // Filter metadata within clip range and generate dialogues
            for (let i = 0; i < metadata.length; i++) {
                const item = metadata[i];
                const itemTime = item.time;
                
                // Skip if outside clip range
                if (itemTime < clipStart || itemTime > clipEnd) continue;
                
                // Calculate relative time in output video
                const relativeStart = accumulatedTime + (itemTime - clipStart);
                
                // Find end time (next metadata item or segment end)
                let relativeEnd;
                if (i + 1 < metadata.length && metadata[i + 1].time <= clipEnd) {
                    relativeEnd = accumulatedTime + (metadata[i + 1].time - clipStart);
                } else {
                    relativeEnd = accumulatedTime + (clipEnd - clipStart);
                }
                
                // Ensure minimum duration of 0.1s
                if (relativeEnd - relativeStart < 0.1) {
                    relativeEnd = relativeStart + 0.1;
                }
                
                const text = this.formatMetadataText(item.data, lang);
                if (text) {
                    dialogues.push(this.generateDialogue(relativeStart, relativeEnd, text));
                }
            }
            
            accumulatedTime += clipSeg.clipDuration;
        }
        
        content += dialogues.join('\n');
        return content;
    }
    
    /**
     * Generate ASS file for single camera export
     * @param {Array} allMetadata - Metadata array
     * @param {Array} clipSegments - Clip segments
     * @param {string} lang - Language
     * @returns {string} ASS content
     */
    generateForSingleCamera(allMetadata, clipSegments, lang = 'zh-TW') {
        return this.generateAssContent(allMetadata, clipSegments, lang, 1920, 1080);
    }
    
    /**
     * Generate ASS file for grid video export
     * @param {Array} allMetadata - Metadata array
     * @param {Array} clipSegments - Clip segments
     * @param {number} cameraCount - Number of cameras in grid
     * @param {string} lang - Language
     * @returns {string} ASS content
     */
    generateForGrid(allMetadata, clipSegments, cameraCount, lang = 'zh-TW') {
        // Calculate grid dimensions
        let width, height;
        if (cameraCount <= 2) {
            width = 1920;
            height = 540;
        } else if (cameraCount <= 4) {
            width = 1920;
            height = 1080;
        } else {
            width = 2880;
            height = 1080;
        }
        
        return this.generateAssContent(allMetadata, clipSegments, lang, width, height);
    }
}

// Global instance for ASS generation
// Global instances for metadata overlay generation
const assSubtitleGenerator = new AssSubtitleGenerator();
const metadataOverlayGenerator = new MetadataOverlayGenerator();

class MetadataManager {
    constructor(viewer) {
        this.viewer = viewer;
        this.protoRoot = null;
        this.SeiMetadata = null;
        this.currentMetadata = []; // Array of metadata objects for the current segment
        this.isLoading = false;
        this.detailModalOpen = false;
        this.lastDetailData = null;
        
        this.dom = {
            panel: document.getElementById('metadataPanel'),
            switchBtn: document.getElementById('metaSwitchBtn'),
            detailBtn: document.getElementById('metaDetailBtn'),
            statsOverlay: document.getElementById('metaDetailOverlay'),
            closeStatsBtn: document.getElementById('closeStatsBtn'),
            statsTitle: document.getElementById('statsTitle'),
            loading: document.getElementById('metadataLoading'),
            empty: document.getElementById('metadataEmpty'),
            items: document.getElementById('metadataItems'),
            values: {
                speed: document.getElementById('metaSpeed'),
                gear: document.getElementById('metaGear'),
                steering: document.getElementById('metaSteering'),
                steeringIcon: document.getElementById('metaSteeringIcon'),
                steeringContainer: document.getElementById('metaSteeringContainer'),
                blinkerLeft: document.getElementById('metaBlinkerLeft'),
                blinkerRight: document.getElementById('metaBlinkerRight'),
                brakeIcon: document.getElementById('metaBrakeIcon'),
                brakeActiveGroup: document.querySelector('#metaBrakeIcon .brake-active'),
                brakeInactiveGroup: document.querySelector('#metaBrakeIcon .brake-inactive'),
                acceleratorIcon: document.getElementById('metaAcceleratorIcon'),
                accelFillRect: document.getElementById('accelFillRect'),
                autopilot: document.getElementById('metaAutopilot'),
                gps: document.getElementById('metaGPS'),
                heading: document.getElementById('metaHeading'),
                acceleration: document.getElementById('metaAcceleration')
            },
            stats: {
                speed: document.getElementById('statsSpeed'),
                gear: document.getElementById('statsGear'),
                steering: document.getElementById('statsSteering'),
                accelerator: document.getElementById('statsAccelerator'),
                brake: document.getElementById('statsBrake'),
                blinker: document.getElementById('statsBlinker'),
                autopilot: document.getElementById('statsAutopilot'),
                gps: document.getElementById('statsGPS'),
                heading: document.getElementById('statsHeading'),
                accel: document.getElementById('statsAccel')
            }
        };
        
        this.initializeProtobuf();
        this.bindEvents();
    }
    
    async initializeProtobuf() {
        try {
            if (typeof protobuf === 'undefined') {
                console.warn("[MetadataManager] protobuf.js not loaded yet, retrying in 1s");
                setTimeout(() => this.initializeProtobuf(), 1000);
                return;
            }
            this.protoRoot = await protobuf.load("dashcam.proto");
            this.SeiMetadata = this.protoRoot.lookupType("SeiMetadata");
            console.log("[MetadataManager] Protobuf initialized");
        } catch (err) {
            console.error("[MetadataManager] Failed to load protobuf:", err);
        }
    }
    
    bindEvents() {
        // Toggle from header button
        if (this.dom.switchBtn) {
            this.dom.switchBtn.addEventListener('click', () => {
                const isCollapsed = this.dom.panel.classList.contains('collapsed');
                this.setCollapsed(!isCollapsed);
            });
        }

        // Stats overlay button click (toggle)
        if (this.dom.detailBtn) {
            this.dom.detailBtn.addEventListener('click', () => {
                this.toggleStatsOverlay();
            });
        }

        // Close stats overlay
        if (this.dom.closeStatsBtn) {
            this.dom.closeStatsBtn.addEventListener('click', () => {
                this.hideStatsOverlay();
            });
        }

        // Stats overlay draggable logic
        this.initStatsOverlayDrag();

        // Draggable logic
        let isDragging = false;
        let offsetX, offsetY;

        this.dom.panel.addEventListener('mousedown', (e) => {
            // Only drag if left click
            if (e.button !== 0) return;
            if (this.dom.panel.classList.contains('collapsed')) return;

            isDragging = true;
            this.dom.panel.classList.add('dragging');
            
            // Get the container's bounding box to calculate relative coordinates
            const parentRect = this.dom.panel.parentElement.getBoundingClientRect();
            const rect = this.dom.panel.getBoundingClientRect();
            
            // Calculate the offset of the mouse relative to the panel's top-left corner
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;

            // Add global mouse listeners
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            
            e.preventDefault();
        });

        const onMouseMove = (e) => {
            if (!isDragging) return;

            const parentRect = this.dom.panel.parentElement.getBoundingClientRect();
            
            // Calculate new position relative to the parent container
            let newLeft = e.clientX - parentRect.left - offsetX;
            let newTop = e.clientY - parentRect.top - offsetY;

            // Boundary checks
            const panelRect = this.dom.panel.getBoundingClientRect();
            newLeft = Math.max(0, Math.min(newLeft, parentRect.width - panelRect.width));
            newTop = Math.max(0, Math.min(newTop, parentRect.height - panelRect.height));

            this.dom.panel.style.left = `${newLeft}px`;
            this.dom.panel.style.top = `${newTop}px`;
            this.dom.panel.classList.add('is-moved');
            this.dom.panel.style.transform = 'none'; 
            this.dom.panel.style.margin = '0';
        };

        const onMouseUp = () => {
            isDragging = false;
            this.dom.panel.classList.remove('dragging');
            this.dom.panel.style.transform = ''; // Allow CSS to handle scale/transitions
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);

            // Convert to percentages for responsiveness
            const parentRect = this.dom.panel.parentElement.getBoundingClientRect();
            const panelRect = this.dom.panel.getBoundingClientRect();
            
            if (parentRect.width > 0 && parentRect.height > 0) {
                const leftPct = ((panelRect.left - parentRect.left) / parentRect.width) * 100;
                const topPct = ((panelRect.top - parentRect.top) / parentRect.height) * 100;
                
                this.dom.panel.style.left = `${leftPct}%`;
                this.dom.panel.style.top = `${topPct}%`;
            }
        };

        // Handle window resize to keep panel in bounds
        window.addEventListener('resize', () => {
            if (this.dom.panel.style.left && this.dom.panel.style.left.includes('%')) {
                this.ensureInBounds();
            }
        });
    }

    ensureInBounds() {
        const parentRect = this.dom.panel.parentElement.getBoundingClientRect();
        const panelRect = this.dom.panel.getBoundingClientRect();
        
        if (panelRect.right > parentRect.right) {
            const newLeft = Math.max(0, parentRect.width - panelRect.width);
            this.dom.panel.style.left = `${(newLeft / parentRect.width) * 100}%`;
        }
        if (panelRect.bottom > parentRect.bottom) {
            const newTop = Math.max(0, parentRect.height - panelRect.height);
            this.dom.panel.style.top = `${(newTop / parentRect.height) * 100}%`;
        }
    }

    setCollapsed(collapsed) {
        if (collapsed) {
            this.dom.panel.classList.add('collapsed');
            if (this.dom.switchBtn) this.dom.switchBtn.classList.remove('active');
        } else {
            this.dom.panel.classList.remove('collapsed');
            if (this.dom.switchBtn) this.dom.switchBtn.classList.add('active');
        }
    }
    
    async loadMetadata(file) {
        if (!this.SeiMetadata) {
            console.warn("[MetadataManager] Protobuf not ready, skipping metadata load");
            return;
        }
        
        this.isLoading = true;
        this.updateUIStatus();
        this.currentMetadata = [];
        
        try {
            let buffer;
            if (file instanceof File) {
                buffer = await file.arrayBuffer();
            } else if (file instanceof TauriFile) {
                buffer = await file.arrayBuffer();
            } else if (file && file.path) {
                // If it's a file-like object but not instance of File/TauriFile
                const response = await fetch(getFileUrl(file));
                buffer = await response.arrayBuffer();
            } else {
                console.warn("[MetadataManager] Unknown file type for metadata loading");
                return;
            }

            const parser = new DashcamMP4(buffer);
            const rawMetadata = parser.parseMetadata();
            
            this.currentMetadata = rawMetadata.map(item => {
                try {
                    const decoded = this.SeiMetadata.decode(item.data);
                    return {
                        time: item.time,
                        data: this.SeiMetadata.toObject(decoded, { enums: String, longs: String })
                    };
                } catch (e) {
                    console.warn("[MetadataManager] Failed to decode SEI item:", e);
                    return null;
                }
            }).filter(Boolean);
            
            console.log(`[MetadataManager] Loaded ${this.currentMetadata.length} metadata points`);
            
            // Auto expand panel if metadata is loaded
            if (this.currentMetadata.length > 0 && this.dom.panel.classList.contains('collapsed')) {
                this.setCollapsed(false);
            }
        } catch (err) {

            console.error("[MetadataManager] Error parsing metadata:", err);
            this.currentMetadata = [];
        } finally {
            this.isLoading = false;
            this.updateUIStatus();
        }
    }
    
    updateUIStatus() {
        if (!this.dom.loading) return;
        this.dom.loading.style.display = this.isLoading ? 'block' : 'none';
        this.dom.empty.style.display = (!this.isLoading && this.currentMetadata.length === 0) ? 'block' : 'none';
        this.dom.items.style.display = (!this.isLoading && this.currentMetadata.length > 0) ? 'flex' : 'none';
    }
    
    updateDisplay(currentTime) {
        if (this.currentMetadata.length === 0) return;
        
        const lang = this.viewer.currentLanguage;
        
        // Find the metadata item closest to current playback time
        let bestMatch = this.currentMetadata[0];
        for (let i = 0; i < this.currentMetadata.length; i++) {
            if (this.currentMetadata[i].time <= currentTime) {
                bestMatch = this.currentMetadata[i];
            } else {
                break;
            }
        }
        
        if (!bestMatch || !bestMatch.data) return;
        
        const d = bestMatch.data;
        const v = this.dom.values;
        
        // Update speed (just the number, unit is separate)
        const speedKmh = (d.vehicleSpeedMps || 0) * 3.6;
        const speedDisplay = Math.round(speedKmh);
        v.speed.textContent = speedDisplay === 0 ? '0' : speedDisplay;
        
        // Update gear (single letter: P, D, R, N)
        const gearLetterMap = {
            'GEAR_PARK': 'P',
            'GEAR_DRIVE': 'D',
            'GEAR_REVERSE': 'R',
            'GEAR_NEUTRAL': 'N'
        };
        v.gear.textContent = gearLetterMap[d.gearState] || '--';
        
        // Update steering wheel angle and rotation
        const steeringAngle = d.steeringWheelAngle || 0;
        v.steering.textContent = `${steeringAngle.toFixed(0)}¬∞`;
        // Rotate the steering wheel icon - allow full rotation (can exceed 360¬∞)
        v.steeringIcon.style.transform = `rotate(${steeringAngle}deg)`;
        
        // Update steering wheel color based on autopilot state
        v.steeringIcon.classList.remove('autopilot-active', 'autopilot-self-driving');
        if (d.autopilotState === 'SELF_DRIVING') {
            v.steeringIcon.classList.add('autopilot-self-driving');
        } else if (d.autopilotState === 'AUTOSTEER' || d.autopilotState === 'TACC') {
            v.steeringIcon.classList.add('autopilot-active');
        }
        
        // Update accelerator pedal - fill height based on pedal position (grows from bottom)
        const accelPercent = d.acceleratorPedalPosition || 0;
        if (v.accelFillRect) {
            const maxHeight = 20; // max fill height
            const fillHeight = (accelPercent / 100) * maxHeight;
            const yPos = 26 - fillHeight; // start from bottom (y=26) and grow upward
            v.accelFillRect.setAttribute('y', yPos);
            v.accelFillRect.setAttribute('height', fillHeight);
            v.accelFillRect.setAttribute('opacity', accelPercent > 0 ? 0.9 : 0);
        }
        v.acceleratorIcon.classList.toggle('active', accelPercent > 5);
        
        // Update brake - use CSS class to toggle active state
        const brakeApplied = d.brakeApplied || false;
        v.brakeIcon.classList.toggle('active', brakeApplied);
        
        // Update blinkers
        v.blinkerLeft.classList.toggle('active', d.blinkerOnLeft || false);
        v.blinkerRight.classList.toggle('active', d.blinkerOnRight || false);
        
        // Update autopilot
        const apMap = {
            'NONE': 'autopilotNone',
            'SELF_DRIVING': 'autopilotSelfDriving',
            'AUTOSTEER': 'autopilotAutosteer',
            'TACC': 'autopilotTACC'
        };
        v.autopilot.textContent = i18n[lang][apMap[d.autopilotState] || d.autopilotState] || d.autopilotState || '--';
        v.autopilot.style.color = d.autopilotState !== 'NONE' ? '#1890ff' : '';
        
        // Update GPS
        v.gps.textContent = (typeof d.latitudeDeg === 'number' && typeof d.longitudeDeg === 'number') 
            ? `${d.latitudeDeg.toFixed(6)}, ${d.longitudeDeg.toFixed(6)}` 
            : '--';
        
        // Update Heading
        v.heading.textContent = (typeof d.headingDeg === 'number') ? `${d.headingDeg.toFixed(0)}¬∞` : '--';
        
        // Update Acceleration
        v.acceleration.textContent = (typeof d.linearAccelerationMps2X === 'number' && 
                                     typeof d.linearAccelerationMps2Y === 'number' && 
                                     typeof d.linearAccelerationMps2Z === 'number') 
            ? `X:${d.linearAccelerationMps2X.toFixed(2)} Y:${d.linearAccelerationMps2Y.toFixed(2)} Z:${d.linearAccelerationMps2Z.toFixed(2)}` 
            : '--';

        // Store for detail modal
        this.lastDetailData = d;
        
        // Update stats overlay if open
        if (this.detailModalOpen) {
            this.updateStatsDisplay(d);
        }
    }
    
    toggleStatsOverlay() {
        if (this.detailModalOpen) {
            this.hideStatsOverlay();
        } else {
            this.showStatsOverlay();
        }
    }
    
    showStatsOverlay() {
        if (!this.dom.statsOverlay) return;
        this.dom.statsOverlay.classList.add('show');
        this.detailModalOpen = true;
        
        // Update title based on language
        const lang = this.viewer.currentLanguage;
        if (this.dom.statsTitle) {
            this.dom.statsTitle.textContent = i18n[lang].driveStats;
        }
        
        // Update with latest data
        if (this.lastDetailData) {
            this.updateStatsDisplay(this.lastDetailData);
        }
    }
    
    hideStatsOverlay() {
        if (!this.dom.statsOverlay) return;
        this.dom.statsOverlay.classList.remove('show');
        this.detailModalOpen = false;
    }
    
    initStatsOverlayDrag() {
        if (!this.dom.statsOverlay) return;
        
        let isDragging = false;
        let offsetX, offsetY;
        
        const onMouseDown = (e) => {
            if (e.button !== 0) return;
            
            isDragging = true;
            this.dom.statsOverlay.classList.add('dragging');
            
            const rect = this.dom.statsOverlay.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            
            e.preventDefault();
        };
        
        const onMouseMove = (e) => {
            if (!isDragging) return;
            
            let newLeft = e.clientX - offsetX;
            let newTop = e.clientY - offsetY;
            
            // Boundary checks
            const panelRect = this.dom.statsOverlay.getBoundingClientRect();
            newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - panelRect.width));
            newTop = Math.max(0, Math.min(newTop, window.innerHeight - panelRect.height));
            
            this.dom.statsOverlay.style.left = `${newLeft}px`;
            this.dom.statsOverlay.style.top = `${newTop}px`;
        };
        
        const onMouseUp = () => {
            isDragging = false;
            this.dom.statsOverlay.classList.remove('dragging');
            document.removeEventListener('mousemove', onMouseMove);
            document.removeEventListener('mouseup', onMouseUp);
        };
        
        // Touch support for mobile
        const onTouchStart = (e) => {
            if (e.touches.length !== 1) return;
            
            isDragging = true;
            this.dom.statsOverlay.classList.add('dragging');
            
            const touch = e.touches[0];
            const rect = this.dom.statsOverlay.getBoundingClientRect();
            offsetX = touch.clientX - rect.left;
            offsetY = touch.clientY - rect.top;
            
            document.addEventListener('touchmove', onTouchMove, { passive: false });
            document.addEventListener('touchend', onTouchEnd);
        };
        
        const onTouchMove = (e) => {
            if (!isDragging || e.touches.length !== 1) return;
            e.preventDefault();
            
            const touch = e.touches[0];
            let newLeft = touch.clientX - offsetX;
            let newTop = touch.clientY - offsetY;
            
            const panelRect = this.dom.statsOverlay.getBoundingClientRect();
            newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - panelRect.width));
            newTop = Math.max(0, Math.min(newTop, window.innerHeight - panelRect.height));
            
            this.dom.statsOverlay.style.left = `${newLeft}px`;
            this.dom.statsOverlay.style.top = `${newTop}px`;
        };
        
        const onTouchEnd = () => {
            isDragging = false;
            this.dom.statsOverlay.classList.remove('dragging');
            document.removeEventListener('touchmove', onTouchMove);
            document.removeEventListener('touchend', onTouchEnd);
        };
        
        this.dom.statsOverlay.addEventListener('mousedown', onMouseDown);
        this.dom.statsOverlay.addEventListener('touchstart', onTouchStart, { passive: true });
    }
    
    updateStatsDisplay(d) {
        const lang = this.viewer.currentLanguage;
        const s = this.dom.stats;
        if (!s.speed) return;
        
        // Speed
        const speedKmh = (d.vehicleSpeedMps || 0) * 3.6;
        s.speed.textContent = `${speedKmh.toFixed(1)} km/h`;
        
        // Gear
        const gearMap = {
            'GEAR_PARK': 'P',
            'GEAR_DRIVE': 'D',
            'GEAR_REVERSE': 'R',
            'GEAR_NEUTRAL': 'N'
        };
        s.gear.textContent = gearMap[d.gearState] || '--';
        
        // Steering
        const steeringAngle = d.steeringWheelAngle || 0;
        s.steering.textContent = `${steeringAngle.toFixed(1)}¬∞`;
        
        // Accelerator
        const accelPercent = d.acceleratorPedalPosition || 0;
        s.accelerator.textContent = `${accelPercent.toFixed(1)}%`;
        
        // Brake
        s.brake.textContent = d.brakeApplied 
            ? (lang === 'zh-TW' ? 'Ë∏©‰∏ã' : 'Applied') 
            : (lang === 'zh-TW' ? 'Êú™Ë∏©' : 'Released');
        s.brake.className = 'stats-value' + (d.brakeApplied ? ' highlight-red' : '');
        
        // Blinker
        const blinkerLeft = d.blinkerOnLeft || false;
        const blinkerRight = d.blinkerOnRight || false;
        if (blinkerLeft && blinkerRight) {
            s.blinker.textContent = lang === 'zh-TW' ? 'ÈõôÈñÉ' : 'Hazard';
            s.blinker.className = 'stats-value highlight-yellow';
        } else if (blinkerLeft) {
            s.blinker.textContent = lang === 'zh-TW' ? '‚Üê Â∑¶ËΩâ' : '‚Üê Left';
            s.blinker.className = 'stats-value highlight-green';
        } else if (blinkerRight) {
            s.blinker.textContent = lang === 'zh-TW' ? 'Âè≥ËΩâ ‚Üí' : 'Right ‚Üí';
            s.blinker.className = 'stats-value highlight-green';
        } else {
            s.blinker.textContent = lang === 'zh-TW' ? 'Èóú' : 'Off';
            s.blinker.className = 'stats-value';
        }
        
        // Autopilot
        const apMap = {
            'NONE': lang === 'zh-TW' ? 'ÁÑ°' : 'None',
            'SELF_DRIVING': 'FSD',
            'AUTOSTEER': lang === 'zh-TW' ? 'Ëá™ÂãïËΩâÂêë' : 'Autosteer',
            'TACC': 'TACC'
        };
        s.autopilot.textContent = apMap[d.autopilotState] || d.autopilotState || '--';
        s.autopilot.className = 'stats-value' + (d.autopilotState && d.autopilotState !== 'NONE' ? ' highlight-blue' : '');
        
        // GPS
        if (typeof d.latitudeDeg === 'number' && typeof d.longitudeDeg === 'number') {
            s.gps.textContent = `${d.latitudeDeg.toFixed(6)}, ${d.longitudeDeg.toFixed(6)}`;
        } else {
            s.gps.textContent = '--';
        }
        
        // Heading
        s.heading.textContent = typeof d.headingDeg === 'number' ? `${d.headingDeg.toFixed(1)}¬∞` : '--';
        
        // Acceleration (combined)
        if (typeof d.linearAccelerationMps2X === 'number') {
            s.accel.textContent = `X:${d.linearAccelerationMps2X.toFixed(2)} Y:${d.linearAccelerationMps2Y.toFixed(2)} Z:${d.linearAccelerationMps2Z.toFixed(2)}`;
        } else {
            s.accel.textContent = '--';
        }
    }
    
    clear() {
        this.currentMetadata = [];
        this.lastDetailData = null;
        this.hideStatsOverlay();
        this.updateUIStatus();
    }
}

// --- Device Detection ---
function isIOSDevice() {
    // Detect iOS/iPadOS (including Chrome on iPad which uses WebKit)
    return /iPad|iPhone|iPod/.test(navigator.userAgent) || 
           (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1) ||
           (navigator.userAgent.includes('CriOS')) || // Chrome on iOS
           (navigator.userAgent.includes('Mobile') && navigator.maxTouchPoints > 1);
}

function supportsDirectoryPicker() {
    // Check if webkitdirectory is actually supported and works
    const input = document.createElement('input');
    return 'webkitdirectory' in input && !isIOSDevice();
}

// Check if File System Access API is supported (for persistent directory handle)
function supportsFileSystemAccess() {
    return 'showDirectoryPicker' in window && !isIOSDevice();
}

// --- IndexedDB helpers for storing directory handle ---
const DB_NAME = 'TeslaCamPlayerDB';
const DB_VERSION = 1;
const STORE_NAME = 'directoryHandles';

function openDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(DB_NAME, DB_VERSION);
        request.onerror = () => reject(request.error);
        request.onsuccess = () => resolve(request.result);
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(STORE_NAME)) {
                db.createObjectStore(STORE_NAME, { keyPath: 'id' });
            }
        };
    });
}

async function saveDirectoryHandle(handle) {
    try {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        await new Promise((resolve, reject) => {
            const request = store.put({ id: 'lastDirectory', handle });
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
        db.close();
        console.log('[IndexedDB] Directory handle saved');
    } catch (e) {
        console.warn('[IndexedDB] Failed to save directory handle:', e);
    }
}

async function getDirectoryHandle() {
    try {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, 'readonly');
        const store = tx.objectStore(STORE_NAME);
        const result = await new Promise((resolve, reject) => {
            const request = store.get('lastDirectory');
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
        db.close();
        return result?.handle || null;
    } catch (e) {
        console.warn('[IndexedDB] Failed to get directory handle:', e);
        return null;
    }
}

async function clearDirectoryHandle() {
    try {
        const db = await openDB();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        const store = tx.objectStore(STORE_NAME);
        await new Promise((resolve, reject) => {
            const request = store.delete('lastDirectory');
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
        });
        db.close();
        console.log('[IndexedDB] Directory handle cleared');
    } catch (e) {
        console.warn('[IndexedDB] Failed to clear directory handle:', e);
    }
}
// --- End IndexedDB helpers ---

// --- End Device Detection ---

// --- Coordinate Conversion Functions ---
const x_pi = 3.14159265358979324 * 3000.0 / 180.0;
const PI = 3.1415926535897932384626;
const a = 6378245.0;
const ee = 0.00669342162296594323;

function transformlat(lng, lat) {
    let ret = -100.0 + 2.0 * lng + 3.0 * lat + 0.2 * lat * lat + 0.1 * lng * lat + 0.2 * Math.sqrt(Math.abs(lng));
    ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0;
    ret += (20.0 * Math.sin(lat * PI) + 40.0 * Math.sin(lat / 3.0 * PI)) * 2.0 / 3.0;
    ret += (160.0 * Math.sin(lat / 12.0 * PI) + 320 * Math.sin(lat * PI / 30.0)) * 2.0 / 3.0;
    return ret;
}

function transformlng(lng, lat) {
    let ret = 300.0 + lng + 2.0 * lat + 0.1 * lng * lng + 0.1 * lng * lat + 0.1 * Math.sqrt(Math.abs(lng));
    ret += (20.0 * Math.sin(6.0 * lng * PI) + 20.0 * Math.sin(2.0 * lng * PI)) * 2.0 / 3.0;
    ret += (20.0 * Math.sin(lng * PI) + 40.0 * Math.sin(lng / 3.0 * PI)) * 2.0 / 3.0;
    ret += (150.0 * Math.sin(lng / 12.0 * PI) + 300.0 * Math.sin(lng / 30.0 * PI)) * 2.0 / 3.0;
    return ret;
}

function wgs84togcj02(lng, lat) {
    let dlat = transformlat(lng - 105.0, lat - 35.0);
    let dlng = transformlng(lng - 105.0, lat - 35.0);
    const radlat = lat / 180.0 * PI;
    let magic = Math.sin(radlat);
    magic = 1 - ee * magic * magic;
    const sqrtmagic = Math.sqrt(magic);
    dlat = (dlat * 180.0) / ((a * (1 - ee)) / (magic * sqrtmagic) * PI);
    dlng = (dlng * 180.0) / (a / sqrtmagic * Math.cos(radlat) * PI);
    const mglat = lat + dlat;
    const mglng = lng + dlng;
    return [mglng, mglat];
}

function gcj02tobd09(lng, lat) {
    const z = Math.sqrt(lng * lng + lat * lat) + 0.00002 * Math.sin(lat * x_pi);
    const theta = Math.atan2(lat, lng) + 0.000003 * Math.cos(lng * x_pi);
    const bd_lng = z * Math.cos(theta) + 0.0065;
    const bd_lat = z * Math.sin(theta) + 0.006;
    return [bd_lng, bd_lat];
}
// --- End Coordinate Conversion ---

class VideoListComponent {
    constructor(elementId, eventHandler, viewer) {
        this.container = document.getElementById(elementId);
        this.eventHandler = eventHandler;
        this.viewer = viewer;
        if (!this.container) {
            throw new Error(`Element with id "${elementId}" not found.`);
        }
    }

    render(events) {
        const lang = this.viewer.currentLanguage;
        const translations = i18n[lang];
        this.container.innerHTML = '';
        if (!events || events.length === 0) {
            if (this.viewer.allFiles.length > 0) {
                this.container.innerHTML = `<div class="empty-state"><p>${translations.noRecordsFound}</p></div>`;
            } else {
                this.viewer.showInitialHelpMessage();
            }
            return;
        }
        const fragment = document.createDocumentFragment();
        events.forEach(event => {
            const card = this.createVideoCard(event);
            if (card) fragment.appendChild(card);
        });
        this.container.appendChild(fragment);
    }

    createVideoCard(event) {
        if (!event || !event.segments || event.segments.length === 0) return null;
        const firstSegment = event.segments[0];
        const card = document.createElement('div');
        card.className = 'video-card';
        card.dataset.eventId = event.eventId;
        
        const thumbnailDiv = document.createElement('div');
        thumbnailDiv.className = 'video-thumbnail';
        if (event.thumbFile) {
            const thumbUrl = getFileUrl(event.thumbFile);
            const img = document.createElement('img');
            img.src = thumbUrl;
            img.alt = 'È¢ÑËßàÂõæ';
            img.onload = () => URL.revokeObjectURL(img.src);
            thumbnailDiv.appendChild(img);
        } else {
            thumbnailDiv.innerHTML = `<div class="no-thumb">${this.getEventTypeLabel(event.eventType)}</div>`;
        }
        const durationDiv = document.createElement('div');
        durationDiv.className = 'video-duration';
        durationDiv.textContent = `${event.segments.length} ${i18n[this.viewer.currentLanguage].minutes}`;
        thumbnailDiv.appendChild(durationDiv);
        card.appendChild(thumbnailDiv);

        const infoDiv = document.createElement('div');
        infoDiv.className = 'video-info';
        const startTime = this.parseTimestamp(event.startTime);
        const timeString = startTime.toLocaleString('zh-CN', { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' });
        
        let cityHtml = '';
        if (event.city && event.lat && event.lon) {
            const locationText = event.street ? `${event.city} ¬∑ ${event.street}` : event.city;
            cityHtml = `<span class="city-link" data-lat="${event.lat}" data-lon="${event.lon}">${locationText}</span> `;
        } else if (event.city) {
            const locationText = event.street ? `${event.city} ¬∑ ${event.street}` : event.city;
            cityHtml = `${locationText} `;
        }

        const eventTypeLabel = this.getEventTypeLabel(event.eventType);

        infoDiv.innerHTML = `
            <div class="video-time">
                <span class="video-type-tag" title="${eventTypeLabel}">${eventTypeLabel.split(' ')[0]}</span>
                ${cityHtml}${timeString}
            </div>
        `;
        card.appendChild(infoDiv);
        
        // Attach event listener to the card, but check for city-link target
        card.onclick = (e) => {
            if (e.target.classList.contains('city-link')) {
                e.stopPropagation(); // Prevent card click from firing
                this.viewer.showMapModal(e.target.dataset.lat, e.target.dataset.lon);
            } else {
                this.eventHandler(event.eventId);
            }
        };

        return card;
    }

    getEventTypeLabel(type) {
        const lang = this.viewer.currentLanguage;
        return i18n[lang][type.charAt(0).toLowerCase() + type.slice(1)] || type;
    }

    parseTimestamp(timestamp) {
        // Handles "2024-01-01_12-00-00" format
        const [datePart, timePart] = timestamp.split('_');
        return new Date(`${datePart}T${timePart.replace(/-/g, ':')}`);
    }
}

class MultiCameraPlayer {
    constructor() {
        this.players = {
            front: document.getElementById('front-player'),
            back: document.getElementById('back-player'),
            left: document.getElementById('left-player'),
            right: document.getElementById('right-player'),
            left_pillar: document.getElementById('left-pillar-player'),
            right_pillar: document.getElementById('right-pillar-player')
        };
        this.playerContainers = {
            front: document.getElementById('front-container'),
            back: document.getElementById('back-container'),
            left: document.getElementById('left-container'),
            right: document.getElementById('right-container'),
            left_pillar: document.getElementById('left-pillar-container'),
            right_pillar: document.getElementById('right-pillar-container')
        };
        this.currentUrls = { front: null, back: null, left: null, right: null, left_pillar: null, right_pillar: null };
        this.activeCamera = 'front';
        this.layoutMode = 'grid4'; // Default to 4-Grid
        this.isPlaying = false;
        this.isSeeking = false;
        this.playbackRate = 1.0;
        this.lastSyncTime = 0;
        
        // Start label loop
        this.startRenderLoop();
    }
    
    // Start render loop for labels
    startRenderLoop() {
        if (this.renderLoopRunning) return;
        this.renderLoopRunning = true;
        this.renderLoop();
    }

    renderLoop() {
        const isGrid = ['grid', 'grid4'].includes(this.layoutMode);
        
        if (isGrid) {
            // Check active views to determine layout
            const views = this.layoutMode === 'grid' ?
                ['left_pillar', 'front', 'right_pillar', 'left', 'back', 'right'] : // 6-grid (grid)
                ['front', 'back', 'left', 'right']; // 4-grid (grid4)

            // Iterate over each view container and add/update labels
            views.forEach(camera => {
                const container = this.playerContainers[camera];
                if (container) {
                     let label = container.querySelector('.camera-label');
                     if (!label) {
                         label = document.createElement('div');
                         label.className = 'camera-label';
                         // Style is handled in CSS, but ensure it exists
                         label.style.position = 'absolute';
                         label.style.top = '10px';
                         label.style.left = '10px';
                         label.style.color = 'white';
                         label.style.backgroundColor = 'rgba(0,0,0,0.5)';
                         label.style.padding = '5px 10px';
                         label.style.fontSize = '14px';
                         label.style.pointerEvents = 'none';
                         label.style.zIndex = '10';
                         container.appendChild(label);
                     }
                     // Set localized text (Simple check for window.viewer global or fallback)
                     // Note: We access window.viewer carefully
                     const lang = (window.viewer && window.viewer.currentLanguage) || 'zh-TW';
                     const cameraNames = {
                        front: { en: 'Front', zh: 'ÂâçËßÜ' },
                        left_pillar: { en: 'Left Pillar', zh: 'Â∑¶Êü±' },
                        right_pillar: { en: 'Right Pillar', zh: 'Âè≥Êü±' },
                        back: { en: 'Back', zh: 'ÂêéËßÜ' },
                        left: { en: 'Left', zh: 'Â∑¶‰æß' },
                        right: { en: 'Right', zh: 'Âè≥‰æß' }
                     };
                     label.innerText = cameraNames[camera]?.[lang] || camera;
                     label.style.display = 'block';
                }
            });
            
             // Hide labels for inactive cameras in the grid
             Object.keys(this.playerContainers).forEach(key => {
                 if (!views.includes(key)) {
                     const container = this.playerContainers[key];
                     if (container) {
                        const label = container.querySelector('.camera-label');
                        if (label) label.style.display = 'none';
                     }
                 }
             });

        } else {
             // Single/Legacy view mode: Revert to CSS control (Single hidden by opacity, Legacy PIP shown by opacity)
             Object.values(this.playerContainers).forEach(container => {
                 if (container) {
                    const label = container.querySelector('.camera-label');
                    if (label) label.style.display = '';
                 }
             });
        }

        requestAnimationFrame(() => this.renderLoop());
    }

    setLayout(mode) {
        this.layoutMode = mode;
        this.updateLayout();
    }

    setCamera(camera) {
        if (this.players[camera]) {
            this.activeCamera = camera;
            this.updateLayout();
        }
    }

    updateLayout() {
        const playerArea = document.getElementById('playerArea');
        if (!playerArea) return;

        // Reset Player Area Classes
        playerArea.classList.remove('grid-view', 'grid4-view', 'legacy-view', 'single-view');

        // Reset Container Classes
        const positionClasses = ['pos-top-left', 'pos-top-right', 'pos-bottom-left', 'pos-bottom-right'];
        Object.keys(this.playerContainers).forEach(key => {
            const container = this.playerContainers[key];
            if (!container) return;
            container.classList.remove('is-main', 'is-pip', 'hidden', 'is-grid', 'is-active-single', ...positionClasses);
            container.style.display = ''; // Reset inline display
        });

        // Apply Logic based on Layout Mode
        if (this.layoutMode === 'grid') {
            playerArea.classList.add('grid-view');
            Object.values(this.playerContainers).forEach(c => { if(c) c.classList.add('is-grid'); });
        } 
        else if (this.layoutMode === 'grid4') {
            playerArea.classList.add('grid4-view');
            Object.keys(this.playerContainers).forEach(key => {
                const c = this.playerContainers[key];
                if (!c) return;
                // Only Front, Back, Left, Right are standard grid4
                if (['front', 'back', 'left', 'right'].includes(key)) {
                    c.classList.add('is-grid');
                } else {
                    // Pillars are hidden via CSS for grid4-view, but we can ensure it
                }
            });
        }
        else if (this.layoutMode === 'single') {
            playerArea.classList.add('single-view');
            const activeC = this.playerContainers[this.activeCamera];
            if (activeC) activeC.classList.add('is-active-single');
        }
        else if (this.layoutMode === 'legacy') {
            playerArea.classList.add('legacy-view');
            
            const layouts = {
                front: { back: 'top-right', left: 'bottom-left', right: 'bottom-right' },
                back: { front: 'top-left', left: 'bottom-left', right: 'bottom-right' },
                left: { front: 'top-left', back: 'top-right', right: 'bottom-right' },
                right: { front: 'top-left', back: 'top-right', left: 'bottom-left' },
                left_pillar: { front: 'top-left', back: 'top-right', left: 'bottom-left' },
                right_pillar: { front: 'top-left', back: 'top-right', right: 'bottom-right' }
            };
            const pipMapping = layouts[this.activeCamera] || {};

            Object.keys(this.playerContainers).forEach(key => {
                const container = this.playerContainers[key];
                if (!container) return;

                if (key === this.activeCamera) {
                    container.classList.add('is-main');
                } else if (pipMapping[key]) {
                    container.classList.add('is-pip', `pos-${pipMapping[key]}`);
                } else {
                    container.classList.add('is-pip', 'hidden');
                }
            });
        }
    }

    // Deprecated but kept for compatibility if needed, aliased to setCamera + Single Mode
    setActive(cameraType) {
        if (['grid', 'grid4', 'legacy'].includes(cameraType)) {
            this.setLayout(cameraType);
        } else {
            this.setCamera(cameraType);
            this.setLayout('single');
        }
    }

    async loadSegmentForAllCameras(segment) {
        this.cleanup();
        const cameras = ['front', 'back', 'left', 'right', 'left_pillar', 'right_pillar'];
        let activeCount = 0;

        for (const camera of cameras) {
            const file = segment.files[camera];
            const player = this.players[camera];
            const cameraView = this.playerContainers[camera];

            if (file && player) {
                activeCount++;
                this.currentUrls[camera] = getFileUrl(file);
                player.src = this.currentUrls[camera];
                // Re-apply the rate here as cleanup() / .src change resets the player state.
                player.defaultPlaybackRate = this.playbackRate;
                player.playbackRate = this.playbackRate;
                if(cameraView) cameraView.classList.remove('error', 'empty');
            } else {
                if (player) player.src = '';
                if(cameraView) cameraView.classList.add('empty');
            }
        }

        // Adjust Grid Layout based on active cameras
        // Logic removed: User explicitly selects layout now.
        
        await this.waitForAllVideosLoaded();

        // Load SEI metadata from front camera
        if (segment.files['front'] && window.viewer && window.viewer.metadataManager) {
            window.viewer.metadataManager.loadMetadata(segment.files['front']);
        } else if (window.viewer && window.viewer.metadataManager) {
            window.viewer.metadataManager.clear();
        }
    }


    async waitForAllVideosLoaded() {
        const loadPromises = Object.values(this.players).filter(p => p.src).map(player =>
            new Promise((resolve) => {
                if (player.readyState >= 2) resolve();
                else {
                    player.addEventListener('loadeddata', resolve, { once: true });
                    player.addEventListener('error', resolve, { once: true });
                }
            })
        );
        await Promise.all(loadPromises);
    }

    async syncAllPlayers() {
        if (this.isSeeking) return;

        const now = performance.now();
        if (now - this.lastSyncTime < 100) { // Throttle to max 10 times per second
            return;
        }
        this.lastSyncTime = now;

        const mainPlayer = this.players[this.activeCamera];
        if (!mainPlayer || !mainPlayer.src) return;
        const currentTime = mainPlayer.currentTime;

        // Update metadata display
        if (window.viewer && window.viewer.metadataManager) {
            window.viewer.metadataManager.updateDisplay(currentTime);
        }

        Object.keys(this.players).forEach(key => {
            if (key !== this.activeCamera && this.players[key] && this.players[key].src) {
                const player = this.players[key];
                if (Math.abs(player.currentTime - currentTime) > 0.1) {
                    player.currentTime = currentTime;
                }
            }
        });
    }

    async playAll() {
        const playPromises = Object.values(this.players).filter(p => p.src).map(p => p.play().catch(e => console.warn('Play failed:', e)));
        await Promise.all(playPromises);
    }

    pauseAll() {
        Object.values(this.players).forEach(p => { if (p.src) p.pause(); });
    }

    seekAll(time) {
        this.isSeeking = true;
        Object.values(this.players).forEach(p => { if (p.src) p.currentTime = time; });
        setTimeout(() => { this.isSeeking = false; }, 100);
    }

    cleanup() {
        this.pauseAll();
        Object.values(this.players).forEach(player => {
            player.src = '';
            player.removeAttribute('src');
            player.load();
        });
        Object.keys(this.currentUrls).forEach(key => {
            if (this.currentUrls[key]) {
                URL.revokeObjectURL(this.currentUrls[key]);
                this.currentUrls[key] = null;
            }
        });
    }

    setPlaybackRate(rate) {
        this.playbackRate = rate;
        Object.values(this.players).forEach(p => {
            if (p) {
                p.defaultPlaybackRate = rate;
                p.playbackRate = rate;
            }
        });
    }
}

class ContinuousVideoPlayer {
    constructor(multiCameraPlayer) {
        this.multiCameraPlayer = multiCameraPlayer;
        this.currentEvent = null;
        this.currentSegmentIndex = 0;
        this.totalDuration = 0;
        this.segmentDurations = [];
        this.segmentStartTimes = [];
        this.isTransitioning = false;
        this.bindEvents();
    }

    bindEvents() {
        const refPlayer = this.multiCameraPlayer.players.front;
        if (!refPlayer) return;
        refPlayer.addEventListener('ended', () => { if (!this.isTransitioning) this.playNextSegment(); });
        refPlayer.addEventListener('timeupdate', () => this.multiCameraPlayer.syncAllPlayers());
    }

    async calculateEventDurations(event) {
        if (!event.segments || event.segments.length === 0) {
            event.totalDuration = 0;
            event.segmentDurations = [];
            event.segmentStartTimes = [];
            return;
        }
        const getVideoDuration = (file) => new Promise((resolve) => {
            if (!file) { resolve(60); return; }
            const video = document.createElement('video');
            const url = getFileUrl(file);
            const cleanup = () => {
                video.onloadedmetadata = null;
                video.onerror = null;
                video.src = '';
                URL.revokeObjectURL(url);
            };
            video.preload = 'metadata';
            video.onloadedmetadata = () => {
                const duration = video.duration;
                cleanup();
                resolve(isFinite(duration) ? duration : 60);
            };
            video.onerror = () => { cleanup(); resolve(60); };
            video.src = url;
        });
        const segmentCount = event.segments.length;
        const durations = new Array(segmentCount).fill(60);
        if (segmentCount > 0) {
            const lastSegment = event.segments[segmentCount - 1];
            const repFile = lastSegment.files.front || lastSegment.files.back || lastSegment.files.left || lastSegment.files.right || lastSegment.files.left_pillar || lastSegment.files.right_pillar;
            durations[segmentCount - 1] = await getVideoDuration(repFile);
        }
        event.segmentDurations = [];
        event.segmentStartTimes = [];
        let accumulatedTime = 0;
        for (let i = 0; i < segmentCount; i++) {
            event.segmentStartTimes[i] = accumulatedTime;
            const segmentDuration = durations[i];
            event.segmentDurations[i] = segmentDuration;
            accumulatedTime += segmentDuration;
        }
        event.totalDuration = accumulatedTime;
    }

    async loadEvent(event) {
        this.currentEvent = event;
        this.currentSegmentIndex = 0;
        this.segmentDurations = event.segmentDurations || [];
        this.segmentStartTimes = event.segmentStartTimes || [];
        this.totalDuration = event.totalDuration || 0;
        await this.loadSegment(0);
    }

    async loadSegment(index) {
        if (!this.currentEvent || index < 0 || index >= this.currentEvent.segments.length) return;
        this.currentSegmentIndex = index;
        const segment = this.currentEvent.segments[index];
        await this.multiCameraPlayer.loadSegmentForAllCameras(segment);
    }

    async playNextSegment() {
        if (this.currentSegmentIndex < this.currentEvent.segments.length - 1) {
            this.isTransitioning = true;
            await this.loadSegment(this.currentSegmentIndex + 1);
            await this.multiCameraPlayer.playAll();
            this.isTransitioning = false;
        } else {
            console.log("All segments played.");
            this.multiCameraPlayer.pauseAll();
        }
    }

    getCurrentTime() {
        if (!this.currentEvent) return 0;
        const segmentStartTime = this.segmentStartTimes[this.currentSegmentIndex] || 0;
        const activePlayer = this.multiCameraPlayer.players[this.multiCameraPlayer.activeCamera];
        const segmentCurrentTime = activePlayer ? activePlayer.currentTime : 0;
        return segmentStartTime + segmentCurrentTime;
    }

    async seekToTime(targetTime) {
        if (!this.currentEvent) return;
        let targetSegmentIndex = 0;
        for (let i = 0; i < this.segmentStartTimes.length; i++) {
            if (targetTime >= this.segmentStartTimes[i]) targetSegmentIndex = i;
            else break;
        }
        const segmentStartTime = this.segmentStartTimes[targetSegmentIndex];
        const segmentTime = targetTime - segmentStartTime;
        if (targetSegmentIndex !== this.currentSegmentIndex) {
            await this.loadSegment(targetSegmentIndex);
        }
        this.multiCameraPlayer.seekAll(segmentTime);
    }

    getTotalDuration() { return this.totalDuration; }
}

class ModernVideoControls {
    constructor(continuousPlayer, viewer) {
        this.continuousPlayer = continuousPlayer;
        this.multiCameraPlayer = continuousPlayer.multiCameraPlayer;
        this.viewer = viewer;
        this.player = this.multiCameraPlayer.players.front;
        this.container = document.getElementById('playerArea');
        this.totalDuration = 0;
        this.isPlaying = false;
        this.isDragging = false;
        this.wasPlaying = false;
        this.currentEventStartTime = null;
        
        // Clip selection state
        this.clipStartTime = null;
        this.clipEndTime = null;
        this.isDraggingClipStart = false;
        this.isDraggingClipEnd = false;
        this.clipModeActive = false;
        
        this.hideControlsTimer = null;
        
        this.initializeElements();
        this.bindEvents();
    }

    initializeElements() {
        if (!this.container) return;
        this.overlay = this.container.querySelector('#videoControlsOverlay');
        this.playPauseBtn = this.container.querySelector('#playPauseBtn');
        this.playPauseIcon = this.container.querySelector('#playPauseIcon');
        this.progressContainer = this.container.querySelector('#progressContainer');
        this.progressPlayed = this.container.querySelector('#progressPlayed');
        this.progressHandle = this.container.querySelector('#progressHandle');
        this.videoTimeDisplay = this.container.querySelector('#videoTimeDisplay');
        this.timePreview = this.container.querySelector('#timePreview');
        this.realTimeClock = document.getElementById('realTimeClock');
        this.speedControl = this.container.querySelector('#speedControl');
        this.speedBtn = this.container.querySelector('#speedBtn');
        this.speedOptions = this.container.querySelector('.speed-options');
        
        // Speed graph elements
        this.speedGraphContainer = this.container.querySelector('#speedGraphContainer');
        this.speedGraphCanvas = this.container.querySelector('#speedGraphCanvas');
        
        // Clip elements
        this.clipBtn = this.container.querySelector('#clipBtn');
        this.confirmClipBtn = this.container.querySelector('#confirmClipBtn');
        this.clipSelection = this.container.querySelector('#clipSelection');
        this.clipStartHandle = this.container.querySelector('#clipStartHandle');
        this.clipEndHandle = this.container.querySelector('#clipEndHandle');
        this.viewSwitcher = this.container.querySelector('#viewSwitcher');
    }

    bindEvents() {
        if (this.viewSwitcher) {
            this.viewSwitcher.addEventListener('click', (e) => {
                const btn = e.target.closest('.view-btn');
                if (btn && btn.dataset.view) {
                    this.viewer.switchCamera(btn.dataset.view);
                }
            });
        }

        if (this.playPauseBtn) this.playPauseBtn.addEventListener('click', () => this.togglePlayPause());

        if (this.progressContainer) {
            this.progressContainer.addEventListener('mousedown', (e) => this.startDrag(e));
            document.addEventListener('mousemove', (e) => this.onDrag(e));
            document.addEventListener('mouseup', (e) => this.stopDrag(e));

            this.progressContainer.addEventListener('mousemove', (e) => {
                if (!this.isDragging && !this.isDraggingClipStart && !this.isDraggingClipEnd) this.showTimePreview(e);
            });
            this.progressContainer.addEventListener('mouseleave', () => {
                if (!this.isDragging && !this.isDraggingClipStart && !this.isDraggingClipEnd) this.hideTimePreview();
            });
        }
        
        // Clip handle events
        if (this.clipStartHandle) {
            this.clipStartHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                this.isDraggingClipStart = true;
                this.wasPlaying = this.multiCameraPlayer.isPlaying;
                if (this.wasPlaying) this.multiCameraPlayer.pauseAll();
            });
        }
        
        if (this.clipEndHandle) {
            this.clipEndHandle.addEventListener('mousedown', (e) => {
                e.stopPropagation();
                this.isDraggingClipEnd = true;
                this.wasPlaying = this.multiCameraPlayer.isPlaying;
                if (this.wasPlaying) this.multiCameraPlayer.pauseAll();
            });
        }
        
        // Clip button
        if (this.clipBtn) {
            this.clipBtn.addEventListener('click', () => {
                if (!this.clipModeActive) {
                    // Enter clip mode
                    this.toggleClipMode();
                } else {
                    // Exit clip mode
                    this.toggleClipMode();
                }
            });
        }
        
        // Confirm clip button
        if (this.confirmClipBtn) {
            this.confirmClipBtn.addEventListener('click', () => {
                this.viewer.showClipModal();
            });
        }

        if (this.player) {
            this.player.addEventListener('timeupdate', () => {
                if (!this.isDragging) this.updateProgress();
            });
            this.player.addEventListener('play', () => this.updatePlayState(true));
            this.player.addEventListener('pause', () => this.updatePlayState(false));
        }

        if (this.container) {
            const resetTimer = () => this.resetHideTimer();
            this.container.addEventListener('mousemove', resetTimer);
            this.container.addEventListener('click', resetTimer);
            this.container.addEventListener('touchstart', resetTimer);
            this.container.addEventListener('mouseenter', resetTimer);
            this.container.addEventListener('mouseleave', () => {
                // If playing, hide immediately on mouse leave (standard behavior)
                // But keep showing if paused or interacting
                if (this.isPlaying && !this.isDragging && !this.speedControl?.classList.contains('active')) {
                    this.hideControls();
                }
            });
        }

        if (this.speedBtn) {
            this.speedBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.speedControl.classList.toggle('active');
            });
        }

        if (this.speedOptions) {
            this.speedOptions.addEventListener('click', (e) => {
                e.stopPropagation();
                if (e.target.dataset.speed) {
                    this.setSpeed(parseFloat(e.target.dataset.speed));
                    this.speedControl.classList.remove('active');
                }
            });
        }

        document.addEventListener('click', (e) => {
            if (this.speedControl && this.speedControl.classList.contains('active') && !this.speedControl.contains(e.target)) {
                this.speedControl.classList.remove('active');
            }
        });
        
        // Handle resize for speed graph redraw
        let resizeTimeout;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                if (this.lastSpeedGraphData) {
                    this.drawSpeedGraph(this.lastSpeedGraphData.metadata, this.lastSpeedGraphData.durations);
                }
            }, 100);
        });
    }
    
    updateViewSwitcherUI(cameraType) {
        if (!this.viewSwitcher) return;
        this.viewSwitcher.querySelectorAll('.view-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.view === cameraType);
        });
    }

    updatePillarButtons(show) {
        if (!this.viewSwitcher) return;
        
        // Always show Pillar Buttons (User Request)
        const pillarBtns = this.viewSwitcher.querySelectorAll('[data-view="left_pillar"], [data-view="right_pillar"]');
        pillarBtns.forEach(btn => {
            btn.style.display = 'flex';
        });

        // Always show 6-Grid Button
        const grid6Btn = this.viewSwitcher.querySelector('[data-view="grid"]');
        if (grid6Btn) {
            grid6Btn.style.display = 'flex';
        }
    }

    toggleClipMode() {
        this.clipModeActive = !this.clipModeActive;
        
        if (this.clipModeActive) {
            // Enter clip mode - pause video first
            if (this.multiCameraPlayer.isPlaying) {
                this.multiCameraPlayer.pauseAll();
                this.updatePlayState(false);
            }
            
            // Initialize selection
            const currentTime = this.continuousPlayer.getCurrentTime();
            const duration = this.totalDuration;
            
            // Set default selection: current time ¬± 30 seconds (or bounds)
            this.clipStartTime = Math.max(0, currentTime - 30);
            this.clipEndTime = Math.min(duration, currentTime + 30);
            
            this.updateClipSelection();
            this.clipSelection.classList.add('active');
            this.clipStartHandle.classList.add('active');
            this.clipEndHandle.classList.add('active');
            this.clipBtn.style.color = '#f0c040';
            
            // Show confirm button, hide clip button
            if (this.confirmClipBtn) {
                this.confirmClipBtn.style.display = 'block';
            }
        } else {
            // Exit clip mode
            this.clipSelection.classList.remove('active');
            this.clipStartHandle.classList.remove('active');
            this.clipEndHandle.classList.remove('active');
            this.clipBtn.style.color = '';
            this.clipStartTime = null;
            this.clipEndTime = null;
            
            // Hide confirm button
            if (this.confirmClipBtn) {
                this.confirmClipBtn.style.display = 'none';
            }
        }
    }
    
    updateClipSelection() {
        if (!this.clipStartTime && this.clipStartTime !== 0) return;
        if (!this.clipEndTime) return;
        
        const startPercent = (this.clipStartTime / this.totalDuration) * 100;
        const endPercent = (this.clipEndTime / this.totalDuration) * 100;
        const widthPercent = endPercent - startPercent;
        
        this.clipSelection.style.left = `${startPercent}%`;
        this.clipSelection.style.width = `${widthPercent}%`;
        
        this.clipStartHandle.style.left = `${startPercent}%`;
        this.clipEndHandle.style.left = `${endPercent}%`;
    }

    setTotalDuration(duration) {
        this.totalDuration = duration || 0;
        this.updateProgress();
    }

    async togglePlayPause() {
        if (!this.multiCameraPlayer.isPlaying) await this.multiCameraPlayer.playAll();
        else this.multiCameraPlayer.pauseAll();
    }

    startDrag(e) {
        e.preventDefault();
        this.isDragging = true;
        this.wasPlaying = this.multiCameraPlayer.isPlaying;
        if (this.wasPlaying) {
            this.multiCameraPlayer.pauseAll();
        }
        this.timePreview.classList.remove('show');
    }

    onDrag(e) {
        if (this.isDraggingClipStart) {
            e.preventDefault();
            const rect = this.progressContainer.getBoundingClientRect();
            const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            const newTime = pos * this.totalDuration;
            
            // Don't let start go past end
            if (newTime < this.clipEndTime) {
                this.clipStartTime = newTime;
                this.updateClipSelection();
            }
            return;
        }
        
        if (this.isDraggingClipEnd) {
            e.preventDefault();
            const rect = this.progressContainer.getBoundingClientRect();
            const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            const newTime = pos * this.totalDuration;
            
            // Don't let end go before start
            if (newTime > this.clipStartTime) {
                this.clipEndTime = newTime;
                this.updateClipSelection();
            }
            return;
        }
        
        if (!this.isDragging) return;
        e.preventDefault();
        const rect = this.progressContainer.getBoundingClientRect();
        const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
        
        const currentTime = pos * this.totalDuration;

        this.progressPlayed.style.width = `${pos * 100}%`;
        this.progressHandle.style.left = `${pos * 100}%`;
        this.videoTimeDisplay.textContent = `${this.formatTime(currentTime)} / ${this.formatTime(this.totalDuration)}`;
    }

    async stopDrag(e) {
        if (this.isDraggingClipStart || this.isDraggingClipEnd) {
            this.isDraggingClipStart = false;
            this.isDraggingClipEnd = false;
            if (this.wasPlaying) {
                await this.multiCameraPlayer.playAll();
            }
            return;
        }
        
        if (!this.isDragging) return;
        this.isDragging = false;

        const rect = this.progressContainer.getBoundingClientRect();
        const pos = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));

        if (this.totalDuration > 0) {
            const targetTime = pos * this.totalDuration;
            
            this.progressPlayed.style.width = `${pos * 100}%`;
            this.progressHandle.style.left = `${pos * 100}%`;
            this.videoTimeDisplay.textContent = `${this.formatTime(targetTime)} / ${this.formatTime(this.totalDuration)}`;

            await this.continuousPlayer.seekToTime(targetTime);
        }

        if (this.wasPlaying) {
            await this.multiCameraPlayer.playAll();
        }
    }

    showTimePreview(e) {
        const rect = this.progressContainer.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const pos = Math.max(0, Math.min(1, mouseX / rect.width));
        const time = pos * this.totalDuration;
        this.timePreview.style.left = `${pos * 100}%`;
        this.timePreview.querySelector('.time-preview-time').textContent = this.formatTime(time);
        this.timePreview.classList.add('show');
    }

    hideTimePreview() {
        this.timePreview.classList.remove('show');
        this.updateProgress();
    }

    updateProgress() {
        const currentTime = this.continuousPlayer.getCurrentTime();
        if (this.totalDuration > 0) {
            const progress = (currentTime / this.totalDuration) * 100;
            this.progressPlayed.style.width = `${progress}%`;
            this.progressHandle.style.left = `${progress}%`;
        }
        this.updateTimeDisplay();
        this.updateRealTimeClock();
    }

    setEventStartTime(startTime) {
        this.currentEventStartTime = startTime ? this.parseTimestamp(startTime) : null;
        this.updateRealTimeClock();
    }

    parseTimestamp(timestamp) {
        // Handles "2024-01-01_12-00-00" format
        const [datePart, timePart] = timestamp.split('_');
        return new Date(`${datePart}T${timePart.replace(/-/g, ':')}`);
    }

    updateRealTimeClock() {
        if (!this.realTimeClock) return;

        const currentEvent = this.continuousPlayer.currentEvent;
        if (!currentEvent) {
            this.realTimeClock.classList.remove('visible');
            return;
        }
        
        // Show the clock when there's an event
        this.realTimeClock.classList.add('visible');

        try {
            let newTime;
            const activePlayer = this.multiCameraPlayer.players[this.multiCameraPlayer.activeCamera];
            const segmentTime = activePlayer ? activePlayer.currentTime : 0;

            if (currentEvent.eventType === 'RecentClips') {
                const currentSegmentIndex = this.continuousPlayer.currentSegmentIndex;
                const segment = currentEvent.segments[currentSegmentIndex];
                const activeCameraFile = segment.files[this.multiCameraPlayer.activeCamera];

                if (activeCameraFile && activeCameraFile.name) {
                    const timestampMatch = activeCameraFile.name.match(/(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})/);
                    if (timestampMatch) {
                        const segmentStartTime = this.parseTimestamp(timestampMatch[0]);
                        if (segmentStartTime) {
                            newTime = new Date(segmentStartTime.getTime());
                            newTime.setSeconds(newTime.getSeconds() + segmentTime);
                        }
                    }
                }
            } 
            
            // Fallback or default behavior for Sentry/Saved and if RecentClips logic fails
            if (!newTime) {
                if (!this.currentEventStartTime) {
                    this.realTimeClock.classList.remove('visible');
                    return;
                }
                newTime = new Date(this.currentEventStartTime.getTime());
                const totalElapsedTime = this.continuousPlayer.getCurrentTime();
                newTime.setSeconds(newTime.getSeconds() + totalElapsedTime);
            }

            const locale = this.viewer.currentLanguage === 'zh-TW' ? 'zh-TW' : 'en-CA';
            this.realTimeClock.textContent = newTime.toLocaleString(locale, {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            }).replace(/\//g, '-').replace(',', '');

        } catch (e) {
            this.realTimeClock.textContent = 'ÈåØË™§';
            console.error("Error updating real-time clock:", e);
        }
    }

    updatePlayState(playing) {
        this.isPlaying = playing;
        this.multiCameraPlayer.isPlaying = playing;
        this.playPauseIcon.src = playing ? 'assets/icons/pause.svg' : 'assets/icons/play.svg';
        this.playPauseIcon.alt = i18n[this.viewer.currentLanguage][playing ? 'pause' : 'play'];
        
        this.resetHideTimer();

        const revealBtn = this.viewer.dom.revealFileBtn;
        if (revealBtn) {
            revealBtn.disabled = playing || !this.viewer.currentEvent;
        }
        const downloadBtn = this.viewer.dom.downloadFileBtn;
        if (downloadBtn) {
            downloadBtn.disabled = playing || !this.viewer.currentEvent;
        }
        
        // Enable/disable metadata button
        const metadataBtn = this.viewer.dom.metadataSwitchBtn;
        if (metadataBtn) {
            metadataBtn.disabled = !this.viewer.currentEvent;
        }
        
        // Enable/disable metadata detail button
        const metadataDetailBtn = document.getElementById('metaDetailBtn');
        if (metadataDetailBtn) {
            metadataDetailBtn.disabled = !this.viewer.currentEvent;
        }
        
        // Enable/disable export metadata button
        const exportMetadataBtn = document.getElementById('exportMetadataBtn');
        if (exportMetadataBtn) {
            exportMetadataBtn.disabled = !this.viewer.currentEvent;
        }
        
        // Enable/disable clip button
        if (this.clipBtn) {
            this.clipBtn.disabled = !this.viewer.currentEvent;
            this.clipBtn.title = i18n[this.viewer.currentLanguage].clipVideo;
        }
        
        // Update confirm clip button title
        if (this.confirmClipBtn) {
            this.confirmClipBtn.title = i18n[this.viewer.currentLanguage].confirmClip;
        }
    }

    updateTimeDisplay() {
        const current = this.formatTime(this.continuousPlayer.getCurrentTime());
        const total = this.formatTime(this.totalDuration);
        this.videoTimeDisplay.textContent = `${current} / ${total}`;
    }

    formatTime(seconds) {
        if (isNaN(seconds)) return '--:--';
        const mins = Math.floor(seconds / 60);
        const secs = Math.floor(seconds % 60);
        return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    }

    showControls() {
        this.overlay.classList.add('show');
        if (this.container) {
            this.container.classList.remove('hide-cursor');
        }
    }

    hideControls() {
        // Don't hide if paused, speed menu is open, or dragging
        if (!this.isPlaying ||
            this.speedControl?.classList.contains('active') || 
            this.isDragging || 
            this.isDraggingClipStart || 
            this.isDraggingClipEnd) {
            return;
        }
        this.overlay.classList.remove('show');
        if (this.container) {
            this.container.classList.add('hide-cursor');
        }
    }
    
    resetHideTimer() {
        this.showControls();
        
        if (this.hideControlsTimer) {
            clearTimeout(this.hideControlsTimer);
            this.hideControlsTimer = null;
        }

        if (this.isPlaying) {
            this.hideControlsTimer = setTimeout(() => {
                this.hideControls();
            }, 3000); // 3 seconds auto-hide
        }
    }

    setSpeed(rate) {
        this.multiCameraPlayer.setPlaybackRate(rate);
        this.speedBtn.textContent = `${rate.toFixed(1)}x`;
        
        this.speedOptions.querySelectorAll('div').forEach(div => {
            div.classList.remove('active');
        });
        const activeOption = this.speedOptions.querySelector(`[data-speed="${rate.toFixed(1)}"]`);
        if (activeOption) {
            activeOption.classList.add('active');
        }
    }

    addEventMarkers(event) {
        if (!this.progressContainer) return;
        // Clear previous markers
        this.progressContainer.querySelectorAll('.event-marker').forEach(m => m.remove());

        if (!event.eventTimestamp || !event.startTime || !this.totalDuration) {
            return;
        }

        try {
            const eventTime = new Date(event.eventTimestamp);
            const videoStartTime = this.parseTimestamp(event.startTime);
            
            const timeOffset = (eventTime.getTime() - videoStartTime.getTime()) / 1000;

            if (timeOffset >= 0 && timeOffset <= this.totalDuration) {
                const positionPercent = (timeOffset / this.totalDuration) * 100;
                
                const marker = document.createElement('div');
                marker.className = 'event-marker';
                marker.style.left = `${positionPercent}%`;
                marker.title = `Event: ${eventTime.toLocaleTimeString()}`;
                this.progressContainer.appendChild(marker);
            }
        } catch (e) {
            console.error("Error creating event marker:", e);
        }
    }
    
    /**
     * Draw speed graph based on metadata for the entire event
     * @param {Array} allSegmentsMetadata - Array of metadata arrays for each segment
     * @param {Array} segmentDurations - Duration of each segment
     */
    drawSpeedGraph(allSegmentsMetadata, segmentDurations) {
        if (!this.speedGraphCanvas || !this.speedGraphContainer) return;
        
        // Store data for resize redraw
        this.lastSpeedGraphData = { metadata: allSegmentsMetadata, durations: segmentDurations };
        
        if (!allSegmentsMetadata || allSegmentsMetadata.length === 0) {
            this.speedGraphContainer.classList.remove('visible');
            return;
        }
        
        const canvas = this.speedGraphCanvas;
        const ctx = canvas.getContext('2d');
        
        // Set canvas size for high DPI
        const rect = canvas.getBoundingClientRect();
        const dpr = window.devicePixelRatio || 1;
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        ctx.scale(dpr, dpr);
        
        const width = rect.width;
        const height = rect.height;
        
        // Clear canvas
        ctx.clearRect(0, 0, width, height);
        
        // Collect all speed data with normalized time
        const speedData = [];
        let totalDuration = 0;
        
        for (let i = 0; i < allSegmentsMetadata.length; i++) {
            const segmentMeta = allSegmentsMetadata[i];
            const segmentDuration = segmentDurations[i] || 60;
            const segmentStartTime = totalDuration;
            
            if (segmentMeta && segmentMeta.length > 0) {
                for (const item of segmentMeta) {
                    const speedKmh = (item.data?.vehicleSpeedMps || 0) * 3.6;
                    const timeInEvent = segmentStartTime + (item.time || 0);
                    speedData.push({ time: timeInEvent, speed: speedKmh });
                }
            }
            totalDuration += segmentDuration;
        }
        
        if (speedData.length < 2 || totalDuration === 0) {
            this.speedGraphContainer.classList.remove('visible');
            return;
        }
        
        // Sort by time
        speedData.sort((a, b) => a.time - b.time);
        
        // Find max speed for scaling
        const maxSpeed = Math.max(...speedData.map(d => d.speed), 1);
        const padding = { top: 2, bottom: 4 };
        const graphHeight = height - padding.top - padding.bottom;
        
        // Create gradient fill
        const gradient = ctx.createLinearGradient(0, 0, 0, height);
        gradient.addColorStop(0, 'rgba(66, 165, 245, 0.5)');
        gradient.addColorStop(1, 'rgba(66, 165, 245, 0.05)');
        
        // Draw filled area
        ctx.beginPath();
        ctx.moveTo(0, height);
        
        for (let i = 0; i < speedData.length; i++) {
            const x = (speedData[i].time / totalDuration) * width;
            const y = height - padding.bottom - (speedData[i].speed / maxSpeed) * graphHeight;
            
            if (i === 0) {
                ctx.lineTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        // Close the path
        const lastX = (speedData[speedData.length - 1].time / totalDuration) * width;
        ctx.lineTo(lastX, height);
        ctx.closePath();
        
        ctx.fillStyle = gradient;
        ctx.fill();
        
        // Draw the line on top
        ctx.beginPath();
        for (let i = 0; i < speedData.length; i++) {
            const x = (speedData[i].time / totalDuration) * width;
            const y = height - padding.bottom - (speedData[i].speed / maxSpeed) * graphHeight;
            
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
        }
        
        ctx.strokeStyle = 'rgba(66, 165, 245, 0.8)';
        ctx.lineWidth = 1.5;
        ctx.stroke();
        
        this.speedGraphContainer.classList.add('visible');
    }
    
    clearSpeedGraph() {
        if (!this.speedGraphCanvas || !this.speedGraphContainer) return;
        const ctx = this.speedGraphCanvas.getContext('2d');
        ctx.clearRect(0, 0, this.speedGraphCanvas.width, this.speedGraphCanvas.height);
        this.speedGraphContainer.classList.remove('visible');
        this.lastSpeedGraphData = null;
    }
}

// WebM Duration Fixer
// MediaRecorder ÁîüÊàêÁöÑ webm Êñá‰ª∂Áº∫Â∞ëÊ≠£Á°ÆÁöÑ duration ÂÖÉÊï∞ÊçÆ
// Ëøô‰∏™Á±ªÈÄöËøáËß£ÊûêÂíå‰øÆÊîπ EBML ÁªìÊûÑÊù•‰øÆÂ§ç duration
class WebmDurationFixer {
    constructor() {
        // EBML Element IDs
        this.EBML_ID = 0x1A45DFA3;
        this.SEGMENT_ID = 0x18538067;
        this.INFO_ID = 0x1549A966;
        this.DURATION_ID = 0x4489;
        this.TIMECODE_SCALE_ID = 0x2AD7B1;
        this.CLUSTER_ID = 0x1F43B675;
        this.TIMECODE_ID = 0xE7;
    }

    async fixDuration(blob, durationMs) {
        console.log('[WebmFixer] Starting duration fix, blob size:', blob.size, 'duration:', durationMs, 'ms');
        
        try {
            const buffer = await blob.arrayBuffer();
            const view = new DataView(buffer);
            
            // Êü•Êâæ Segment Âíå Info ÂÖÉÁ¥†ÁöÑ‰ΩçÁΩÆ
            const segmentInfo = this.findElement(view, 0, this.SEGMENT_ID);
            if (!segmentInfo) {
                console.warn('[WebmFixer] Segment not found, returning original blob');
                return blob;
            }
            
            const infoInfo = this.findElement(view, segmentInfo.dataStart, this.INFO_ID);
            if (!infoInfo) {
                console.warn('[WebmFixer] Info not found, returning original blob');
                return blob;
            }
            
            // Êü•Êâæ TimecodeScaleÔºàÈªòËÆ§ 1000000 Á∫≥Áßí = 1 ÊØ´ÁßíÔºâ
            let timecodeScale = 1000000;
            const timecodeScaleInfo = this.findElement(view, infoInfo.dataStart, this.TIMECODE_SCALE_ID, infoInfo.dataStart + infoInfo.dataSize);
            if (timecodeScaleInfo) {
                timecodeScale = this.readUint(view, timecodeScaleInfo.dataStart, timecodeScaleInfo.dataSize);
            }
            
            // Â¶ÇÊûúÊ≤°ÊúâÊèê‰æõ durationÔºåÂ∞ùËØï‰ªéÊúÄÂêé‰∏Ä‰∏™ Cluster ÁöÑ Timecode ËÆ°ÁÆó
            if (!durationMs || durationMs <= 0) {
                durationMs = this.calculateDurationFromClusters(view, segmentInfo.dataStart);
            }
            
            if (!durationMs || durationMs <= 0) {
                console.warn('[WebmFixer] Could not determine duration, returning original blob');
                return blob;
            }
            
            // Â∞ÜÊØ´ÁßíËΩ¨Êç¢‰∏∫ WebM Êó∂Èó¥Âçï‰Ωç
            const durationWebm = (durationMs * 1000000) / timecodeScale;
            
            // Êü•ÊâæÁé∞ÊúâÁöÑ Duration ÂÖÉÁ¥†
            const durationInfo = this.findElement(view, infoInfo.dataStart, this.DURATION_ID, infoInfo.dataStart + infoInfo.dataSize);
            
            if (durationInfo) {
                // Duration Â∑≤Â≠òÂú®ÔºåÁõ¥Êé•‰øÆÊîπ
                console.log('[WebmFixer] Duration element found, modifying in place');
                const newBuffer = buffer.slice(0);
                const newView = new DataView(newBuffer);
                this.writeFloat64(newView, durationInfo.dataStart, durationWebm);
                const fixedBlob = new Blob([newBuffer], { type: 'video/webm' });
                console.log('[WebmFixer] Duration fixed successfully');
                return fixedBlob;
            } else {
                // Duration ‰∏çÂ≠òÂú®ÔºåÈúÄË¶ÅÊèíÂÖ•
                console.log('[WebmFixer] Duration element not found, inserting new element');
                return this.insertDurationElement(buffer, infoInfo, durationWebm);
            }
        } catch (error) {
            console.error('[WebmFixer] Error fixing duration:', error);
            return blob;
        }
    }
    
    // ‰ªé Cluster ÁöÑ Timecode ËÆ°ÁÆóÊÄªÊó∂Èïø
    calculateDurationFromClusters(view, segmentStart) {
        let maxTimecode = 0;
        let offset = segmentStart;
        const endOffset = view.byteLength;
        
        while (offset < endOffset - 4) {
            const clusterInfo = this.findElement(view, offset, this.CLUSTER_ID, endOffset);
            if (!clusterInfo) break;
            
            // Êü•Êâæ Cluster ‰∏≠ÁöÑ Timecode
            const timecodeInfo = this.findElement(view, clusterInfo.dataStart, this.TIMECODE_ID, clusterInfo.dataStart + Math.min(clusterInfo.dataSize, 100));
            if (timecodeInfo) {
                const timecode = this.readUint(view, timecodeInfo.dataStart, timecodeInfo.dataSize);
                if (timecode > maxTimecode) {
                    maxTimecode = timecode;
                }
            }
            
            offset = clusterInfo.dataStart + clusterInfo.dataSize;
        }
        
        // Ê∑ªÂä†‰∏Ä‰∫õÈ¢ùÂ§ñÊó∂Èó¥ÔºàÊúÄÂêé‰∏Ä‰∏™ cluster ÁöÑÂ§ßÊ¶ÇÊó∂ÈïøÔºâ
        return maxTimecode > 0 ? maxTimecode + 1000 : 0;
    }
    
    // ÊèíÂÖ• Duration ÂÖÉÁ¥†Âà∞ Info ‰∏≠
    insertDurationElement(buffer, infoInfo, durationWebm) {
        // Duration ÂÖÉÁ¥†: ID (2 bytes) + Size (1 byte) + Float64 (8 bytes) = 11 bytes
        const durationElementSize = 11;
        const durationElement = new Uint8Array(durationElementSize);
        const durationView = new DataView(durationElement.buffer);
        
        // ÂÜôÂÖ• Duration ID (0x4489)
        durationElement[0] = 0x44;
        durationElement[1] = 0x89;
        // ÂÜôÂÖ• Size (8 bytes for float64)
        durationElement[2] = 0x88; // VINT for 8
        // ÂÜôÂÖ• Float64 ÂÄº
        durationView.setFloat64(3, durationWebm, false);
        
        // ÂàõÂª∫Êñ∞ÁöÑ buffer
        const insertPosition = infoInfo.dataStart;
        const newBuffer = new Uint8Array(buffer.byteLength + durationElementSize);
        
        // Â§çÂà∂ÊèíÂÖ•ÁÇπ‰πãÂâçÁöÑÊï∞ÊçÆ
        newBuffer.set(new Uint8Array(buffer, 0, insertPosition), 0);
        // ÊèíÂÖ• Duration ÂÖÉÁ¥†
        newBuffer.set(durationElement, insertPosition);
        // Â§çÂà∂ÊèíÂÖ•ÁÇπ‰πãÂêéÁöÑÊï∞ÊçÆ
        newBuffer.set(new Uint8Array(buffer, insertPosition), insertPosition + durationElementSize);
        
        // Êõ¥Êñ∞ Info ÂÖÉÁ¥†ÁöÑÂ§ßÂ∞è
        this.updateElementSize(newBuffer, infoInfo.sizeStart, infoInfo.sizeLength, infoInfo.dataSize + durationElementSize);
        
        const fixedBlob = new Blob([newBuffer], { type: 'video/webm' });
        console.log('[WebmFixer] Duration element inserted, new size:', fixedBlob.size);
        return fixedBlob;
    }
    
    // Êõ¥Êñ∞ÂÖÉÁ¥†Â§ßÂ∞èÔºàVINT ÁºñÁ†ÅÔºâ
    updateElementSize(buffer, sizeStart, sizeLength, newSize) {
        // ÁÆÄÂçïÂÆûÁé∞ÔºöÂè™ÊîØÊåÅÂõ∫ÂÆöÈïøÂ∫¶ÁöÑ size Êõ¥Êñ∞
        const view = new DataView(buffer.buffer);
        if (sizeLength === 1) {
            buffer[sizeStart] = 0x80 | newSize;
        } else if (sizeLength === 2) {
            buffer[sizeStart] = 0x40 | (newSize >> 8);
            buffer[sizeStart + 1] = newSize & 0xFF;
        } else if (sizeLength === 3) {
            buffer[sizeStart] = 0x20 | (newSize >> 16);
            buffer[sizeStart + 1] = (newSize >> 8) & 0xFF;
            buffer[sizeStart + 2] = newSize & 0xFF;
        } else if (sizeLength === 4) {
            buffer[sizeStart] = 0x10 | (newSize >> 24);
            buffer[sizeStart + 1] = (newSize >> 16) & 0xFF;
            buffer[sizeStart + 2] = (newSize >> 8) & 0xFF;
            buffer[sizeStart + 3] = newSize & 0xFF;
        }
    }
    
    // Êü•Êâæ EBML ÂÖÉÁ¥†
    findElement(view, startOffset, targetId, endOffset) {
        endOffset = endOffset || view.byteLength;
        let offset = startOffset;
        
        while (offset < endOffset - 4) {
            const { id, idLength } = this.readVintId(view, offset);
            if (idLength === 0) break;
            
            const sizeStart = offset + idLength;
            const { value: size, length: sizeLength } = this.readVint(view, sizeStart);
            if (sizeLength === 0) break;
            
            const dataStart = sizeStart + sizeLength;
            
            if (id === targetId) {
                return {
                    offset,
                    idLength,
                    sizeStart,
                    sizeLength,
                    dataStart,
                    dataSize: size
                };
            }
            
            // ÂØπ‰∫éÂÆπÂô®ÂÖÉÁ¥†ÔºàSegment, InfoÔºâÔºå‰∏çË∑≥ËøáÂÜÖÂÆπ
            if (id === this.SEGMENT_ID || id === this.INFO_ID) {
                offset = dataStart;
            } else {
                offset = dataStart + size;
            }
        }
        
        return null;
    }
    
    // ËØªÂèñ VINT ID
    readVintId(view, offset) {
        if (offset >= view.byteLength) return { id: 0, idLength: 0 };
        
        const first = view.getUint8(offset);
        let idLength = 1;
        let id = first;
        
        if (first >= 0x80) {
            idLength = 1;
        } else if (first >= 0x40) {
            idLength = 2;
        } else if (first >= 0x20) {
            idLength = 3;
        } else if (first >= 0x10) {
            idLength = 4;
        } else {
            return { id: 0, idLength: 0 };
        }
        
        for (let i = 1; i < idLength; i++) {
            id = (id << 8) | view.getUint8(offset + i);
        }
        
        return { id, idLength };
    }
    
    // ËØªÂèñ VINT Â§ßÂ∞è
    readVint(view, offset) {
        if (offset >= view.byteLength) return { value: 0, length: 0 };
        
        const first = view.getUint8(offset);
        let length = 1;
        let value = first;
        
        if (first >= 0x80) {
            length = 1;
            value = first & 0x7F;
        } else if (first >= 0x40) {
            length = 2;
            value = first & 0x3F;
        } else if (first >= 0x20) {
            length = 3;
            value = first & 0x1F;
        } else if (first >= 0x10) {
            length = 4;
            value = first & 0x0F;
        } else if (first >= 0x08) {
            length = 5;
            value = first & 0x07;
        } else if (first >= 0x04) {
            length = 6;
            value = first & 0x03;
        } else if (first >= 0x02) {
            length = 7;
            value = first & 0x01;
        } else if (first >= 0x01) {
            length = 8;
            value = 0;
        } else {
            return { value: 0, length: 0 };
        }
        
        for (let i = 1; i < length; i++) {
            value = (value << 8) | view.getUint8(offset + i);
        }
        
        return { value, length };
    }
    
    // ËØªÂèñÊó†Á¨¶Âè∑Êï¥Êï∞
    readUint(view, offset, length) {
        let value = 0;
        for (let i = 0; i < length; i++) {
            value = (value << 8) | view.getUint8(offset + i);
        }
        return value;
    }
    
    // ÂÜôÂÖ• Float64
    writeFloat64(view, offset, value) {
        view.setFloat64(offset, value, false); // big-endian
    }
}

// ÂÖ®Â±Ä WebM Duration Fixer ÂÆû‰æãÔºàÂçï‰æãÔºâ
const webmDurationFixer = new WebmDurationFixer();

// Video Clip Processor using Canvas API
class VideoClipProcessor {
    constructor() {
        this.canvas = null;
        this.ctx = null;
        this.mediaRecorder = null;
        this.recordingStartTime = null;
        this.ffmpegFixerLoaded = false;
        this.ffmpeg = null;
        // SVG icon cache for metadata overlay
        this.metadataIcons = null;
        this.iconsLoaded = false;
        this.ffmpegChild = null;
        this.isCancelled = false;
    }

    cancelExport() {
        console.warn('[VideoClipProcessor] Cancelling export...');
        this.isCancelled = true;
        if (this.ffmpegChild) {
            try {
                this.ffmpegChild.kill();
                console.log('[VideoClipProcessor] FFmpeg process killed');
            } catch (e) {
                console.error('[VideoClipProcessor] Failed to kill FFmpeg process:', e);
            }
            this.ffmpegChild = null;
        }
        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
            try {
                this.mediaRecorder.stop();
            } catch (e) {}
        }
    }

    /**
     * Create SVG icon as Image object
     * @param {string} svgContent - SVG markup string
     * @param {number} size - Icon size in pixels
     * @returns {Promise<HTMLImageElement>}
     */
    createSvgIcon(svgContent, size = 24) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            const blob = new Blob([svgContent], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            img.onload = () => {
                URL.revokeObjectURL(url);
                resolve(img);
            };
            img.onerror = (e) => {
                URL.revokeObjectURL(url);
                reject(e);
            };
            img.src = url;
        });
    }

    /**
     * Load all metadata icons for video export
     */
    async loadMetadataIcons() {
        if (this.iconsLoaded && this.metadataIcons) {
            return this.metadataIcons;
        }

        const iconSize = 24;
        
        // SVG definitions for each icon
        const svgDefs = {
            // Left blinker arrow (green when active)
            blinkerLeft: (active) => `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" width="${iconSize}" height="${iconSize}">
                    <path d="M20 8 L6 24 L20 40 L20 30 L42 30 L42 18 L20 18 Z" 
                          fill="${active ? '#52c41a' : 'rgba(255,255,255,0.3)'}" 
                          stroke="${active ? '#52c41a' : 'rgba(255,255,255,0.5)'}" 
                          stroke-width="2" stroke-linejoin="round"/>
                </svg>`,
            // Right blinker arrow (green when active)
            blinkerRight: (active) => `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48" width="${iconSize}" height="${iconSize}">
                    <path d="M28 8 L42 24 L28 40 L28 30 L6 30 L6 18 L28 18 Z" 
                          fill="${active ? '#52c41a' : 'rgba(255,255,255,0.3)'}" 
                          stroke="${active ? '#52c41a' : 'rgba(255,255,255,0.5)'}" 
                          stroke-width="2" stroke-linejoin="round"/>
                </svg>`,
            // Brake icon (brake pedal - red when active)
            brake: (active) => `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="${iconSize}" height="${iconSize}">
                    <path d="M821.394 861.482H200.242c-23.709 0-44.013-20.191-45.124-44.975 0 0-30.555-129.896-30.044-166.228 0.325-23.102 15.23-164.3 15.23-164.3 2.449-27.739 18.019-48.258 42.686-48.258h646.233c24.667 0 44.357 21.769 43.759 48.258l14.579 163.622-22.043 166.906c-0.56 24.784-20.414 44.975-44.124 44.975z m24.716-358.364l0.292-10.498c0.23-8.275-6.452-15.059-14.85-15.059H186.497c-8.397 0-14.828 6.784-14.291 15.059l0.681 10.498c0.534 8.232 7.802 14.954 16.153 14.954h641.472c8.35 0 15.37-6.722 15.598-14.954z m8.739 81.304l0.296-10.264c0.233-8.091-6.628-14.724-15.248-14.724H177.735c-8.62 0-15.226 6.633-14.681 14.724l0.691 10.264c0.542 8.049 7.999 14.622 16.571 14.622H838.84c8.574 0 15.777-6.572 16.009-14.622z m6.172 79.506l0.298-10.038c0.235-7.912-6.747-14.399-15.516-14.399H172.234c-8.769 0-15.494 6.487-14.945 14.399l0.695 10.038c0.545 7.872 8.126 14.3 16.847 14.3h669.91c8.721 0 16.047-6.428 16.28-14.3z m-14.901 77.765l0.282-9.819c0.222-7.74-6.466-14.085-14.863-14.085H186.526c-8.397 0-14.841 6.345-14.322 14.085l0.659 9.819c0.517 7.701 7.772 13.989 16.123 13.989h641.548c8.351 0 15.365-6.288 15.586-13.989z m-8.749 76.081l0.267-9.608c0.21-7.573-6.189-13.781-14.222-13.781H206.385c-8.033 0-14.202 6.208-13.711 13.781l0.623 9.608c0.489 7.535 7.425 13.688 15.415 13.688h613.751c7.99 0.001 14.698-6.152 14.908-13.688z m1.869-378.856l36.038-94.167 21.623-119.775H785.183L752.749 356.56l-118.926 82.358H839.24z" fill="${active ? '#ff4d4f' : 'rgba(255,255,255,0.3)'}"/>
                </svg>`,
            // Accelerator/throttle icon (green fill based on percentage)
            accelerator: (percent) => {
                const fillHeight = (percent / 100) * 20;
                const yPos = 26 - fillHeight;
                const color = percent > 0 ? '#73d13d' : 'rgba(255,255,255,0.4)';
                return `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32" width="${iconSize}" height="${iconSize}">
                    <rect x="8" y="4" width="16" height="24" rx="3" fill="none" stroke="rgba(255,255,255,0.5)" stroke-width="2"/>
                    <path d="M18 8 L13 16 L16 16 L14 24 L19 15 L16 15 L18 8 Z" fill="${color}"/>
                    ${percent > 0 ? `<rect x="10" y="${yPos}" width="12" height="${fillHeight}" rx="2" fill="#73d13d" opacity="0.9"/>` : ''}
                </svg>`;
            },
            // Autopilot/steering wheel icon (blue when active)
            autopilot: (active) => `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" width="${iconSize}" height="${iconSize}">
                    <circle cx="32" cy="32" r="26" fill="none" stroke="${active ? '#1890ff' : 'rgba(255,255,255,0.6)'}" stroke-width="4"/>
                    <circle cx="32" cy="32" r="8" fill="${active ? '#1890ff' : 'rgba(255,255,255,0.6)'}"/>
                    <rect x="6" y="29" width="17" height="6" rx="2" fill="${active ? '#1890ff' : 'rgba(255,255,255,0.6)'}"/>
                    <rect x="41" y="29" width="17" height="6" rx="2" fill="${active ? '#1890ff' : 'rgba(255,255,255,0.6)'}"/>
                    <rect x="29" y="41" width="6" height="17" rx="2" fill="${active ? '#1890ff' : 'rgba(255,255,255,0.6)'}"/>
                </svg>`
        };

        // Pre-generate common icon states
        this.metadataIcons = {
            blinkerLeftActive: await this.createSvgIcon(svgDefs.blinkerLeft(true), iconSize),
            blinkerLeftInactive: await this.createSvgIcon(svgDefs.blinkerLeft(false), iconSize),
            blinkerRightActive: await this.createSvgIcon(svgDefs.blinkerRight(true), iconSize),
            blinkerRightInactive: await this.createSvgIcon(svgDefs.blinkerRight(false), iconSize),
            brakeActive: await this.createSvgIcon(svgDefs.brake(true), iconSize),
            brakeInactive: await this.createSvgIcon(svgDefs.brake(false), iconSize),
            autopilotActive: await this.createSvgIcon(svgDefs.autopilot(true), iconSize),
            autopilotInactive: await this.createSvgIcon(svgDefs.autopilot(false), iconSize),
            // Generate accelerator icons for 0%, 25%, 50%, 75%, 100%
            accel0: await this.createSvgIcon(svgDefs.accelerator(0), iconSize),
            accel25: await this.createSvgIcon(svgDefs.accelerator(25), iconSize),
            accel50: await this.createSvgIcon(svgDefs.accelerator(50), iconSize),
            accel75: await this.createSvgIcon(svgDefs.accelerator(75), iconSize),
            accel100: await this.createSvgIcon(svgDefs.accelerator(100), iconSize),
            iconSize
        };

        this.iconsLoaded = true;
        return this.metadataIcons;
    }

    /**
     * Get accelerator icon based on percentage
     */
    getAcceleratorIcon(percent) {
        if (!this.metadataIcons) return null;
        if (percent <= 0) return this.metadataIcons.accel0;
        if (percent <= 25) return this.metadataIcons.accel25;
        if (percent <= 50) return this.metadataIcons.accel50;
        if (percent <= 75) return this.metadataIcons.accel75;
        return this.metadataIcons.accel100;
    }

    formatBytes(bytes) {
        if (typeof bytes !== 'number') return 'n/a';
        const MB = 1024 * 1024;
        if (bytes < MB) return `${bytes.toFixed(0)} B`;
        return `${(bytes / MB).toFixed(2)} MB`;
    }

    logMemory(label, extra = {}) {
        try {
            const mem = performance?.memory;
            const payload = {
                ...extra,
            };
            if (mem) {
                payload.usedJSHeapSize = this.formatBytes(mem.usedJSHeapSize);
                payload.totalJSHeapSize = this.formatBytes(mem.totalJSHeapSize);
                payload.jsHeapSizeLimit = this.formatBytes(mem.jsHeapSizeLimit);
            }
            console.log(`[Mem][Grid] ${label}`, payload);
        } catch (err) {
            console.warn('logMemory failed', err);
        }
    }
    
    // Clean up resources to prevent memory leaks
    cleanup() {
        console.log('[VideoClipProcessor] Cleaning up resources...');

        
        // Clear canvas
        if (this.ctx && this.canvas) {
            this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        }
        
        // Reset canvas size to minimal to free GPU memory
        if (this.canvas) {
            this.canvas.width = 1;
            this.canvas.height = 1;
            this.canvas = null;
        }
        this.ctx = null;
        
        // Clear media recorder
        if (this.mediaRecorder) {
            if (this.mediaRecorder.state !== 'inactive') {
                try {
                    this.mediaRecorder.stop();
                } catch (e) {
                    // Ignore errors when stopping
                }
            }
            this.mediaRecorder = null;
        }
        
        this.recordingStartTime = null;
        
        console.log('[VideoClipProcessor] Cleanup completed');
    }


    // IndexedDB cache for FFmpeg WASM files
    static FFMPEG_CACHE_DB = 'FFmpegWASMCache';
    static FFMPEG_CACHE_STORE = 'files';
    static FFMPEG_CACHE_VERSION = '0.12.6'; // Update when upgrading FFmpeg version
    
    async openCacheDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(VideoClipProcessor.FFMPEG_CACHE_DB, 1);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(VideoClipProcessor.FFMPEG_CACHE_STORE)) {
                    db.createObjectStore(VideoClipProcessor.FFMPEG_CACHE_STORE, { keyPath: 'url' });
                }
            };
        });
    }
    
    async getCachedFile(db, url) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([VideoClipProcessor.FFMPEG_CACHE_STORE], 'readonly');
            const store = transaction.objectStore(VideoClipProcessor.FFMPEG_CACHE_STORE);
            const request = store.get(url);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);
        });
    }
    
    async setCachedFile(db, url, data, mimeType) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([VideoClipProcessor.FFMPEG_CACHE_STORE], 'readwrite');
            const store = transaction.objectStore(VideoClipProcessor.FFMPEG_CACHE_STORE);
            const request = store.put({ 
                url, 
                data, 
                mimeType, 
                version: VideoClipProcessor.FFMPEG_CACHE_VERSION,
                timestamp: Date.now() 
            });
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve();
        });
    }
    
    async toBlobURLWithCache(url, mimeType, progressCallback) {
        try {
            const db = await this.openCacheDB();
            const cached = await this.getCachedFile(db, url);
            
            // Check if cached and version matches
            if (cached && cached.version === VideoClipProcessor.FFMPEG_CACHE_VERSION && cached.data) {
                console.log(`[FFmpeg] Loading from cache: ${url.split('/').pop()}`);
                const blob = new Blob([cached.data], { type: mimeType });
                db.close();
                return URL.createObjectURL(blob);
            }
            
            // Download and cache
            console.log(`[FFmpeg] Downloading: ${url.split('/').pop()}`);
            const response = await fetch(url);
            if (!response.ok) {
                throw new Error(`Failed to fetch ${url}: ${response.status}`);
            }
            const arrayBuffer = await response.arrayBuffer();
            const data = new Uint8Array(arrayBuffer);
            
            // Save to cache
            try {
                await this.setCachedFile(db, url, data, mimeType);
                console.log(`[FFmpeg] Cached: ${url.split('/').pop()}`);
            } catch (cacheError) {
                console.warn('[FFmpeg] Failed to cache file:', cacheError);
            }
            
            db.close();
            return URL.createObjectURL(new Blob([arrayBuffer], { type: mimeType }));
        } catch (error) {
            // Fallback to direct download without caching
            console.warn('[FFmpeg] Cache failed, downloading directly:', error);
            const response = await fetch(url);
            const blob = await response.blob();
            return URL.createObjectURL(new Blob([await blob.arrayBuffer()], { type: mimeType }));
        }
    }

    async loadFFmpeg(progressCallback) {
        if (this.ffmpeg && this.ffmpegLoaded) return this.ffmpeg;
        
        // Dynamically load FFmpeg WASM library if not already loaded
        let FFmpegLib = window.FFmpegWASM || window.FFmpeg;
        
        if (!FFmpegLib) {
            progressCallback?.('ËºâÂÖ• FFmpeg Á®ãÂºèÂ∫´...');
            console.log('[FFmpeg] Dynamically loading FFmpeg WASM library...');
            
            try {
                // Try ESM import first - much better for cross-origin and avoids UMD chunk issues
                // Use version 0.12.6 to match core
                const module = await import('https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.6/+esm');
                FFmpegLib = module;
                console.log('[FFmpeg] FFmpeg library loaded via ESM');
            } catch (esmError) {
                console.warn('[FFmpeg] ESM import failed, falling back to UMD script tag:', esmError);
                // Fallback to the UMD script tag if ESM fails
                await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    // Use 0.12.6 for better compatibility with core 0.12.6
                    script.src = 'https://cdn.jsdelivr.net/npm/@ffmpeg/ffmpeg@0.12.6/dist/umd/ffmpeg.min.js';
                    script.onload = resolve;
                    script.onerror = () => reject(new Error('Failed to load FFmpeg library via script tag'));
                    document.head.appendChild(script);
                });
                FFmpegLib = window.FFmpegWASM || window.FFmpeg;
            }

            if (!FFmpegLib) {
                throw new Error('FFmpeg WASM library failed to initialize');
            }
        }

        const { FFmpeg } = FFmpegLib;
        
        if (!this.ffmpeg) {
            this.ffmpeg = new FFmpeg();
            
            this.ffmpeg.on('log', ({ message }) => {
                console.log('[FFmpeg]', message);
            });
            
            // Use arrow function to capture 'this' and access current progress callback
            this.ffmpeg.on('progress', ({ progress, time }) => {
                 // progress is 0-1
                 if (this.ffmpegProgressCallback) {
                     this.ffmpegProgressCallback(`ÁºñÁ†Å‰∏≠... ${(progress * 100).toFixed(0)}%`);
                 }
            });
        }

        // Check if multi-threading is supported (requires COOP/COEP headers)
        const supportsMultiThread = typeof SharedArrayBuffer !== 'undefined';
        const useMultiThread = supportsMultiThread; // Re-enabled with scale optimization
        
        if (useMultiThread) {
            progressCallback?.('ËºâÂÖ• FFmpeg Â§öÂü∑Ë°åÁ∑íÊ†∏ÂøÉÊ®°ÁµÑ...');
            console.log('[FFmpeg] Loading FFmpeg WASM core (multi-threaded)...');
        } else {
            progressCallback?.('ËºâÂÖ• FFmpeg Ê†∏ÂøÉÊ®°ÁµÑ...');
            console.log('[FFmpeg] Loading FFmpeg WASM core (single-threaded)...');
        }
        
        const startTime = performance.now();
        
        // Load from CDN for web version
        // Use unpkg CDN for ffmpeg core files
        // Must use toBlobURL to convert remote scripts to Blob URLs to bypass CORS Worker restrictions
        const baseURL = 'https://unpkg.com/@ffmpeg/core@0.12.6/dist/umd';
        const baseURLMT = 'https://unpkg.com/@ffmpeg/core-mt@0.12.6/dist/umd';
        
        try {
            if (useMultiThread) {
                // Multi-threaded version - faster but requires COOP/COEP headers
                progressCallback?.('ËºâÂÖ• FFmpeg Ê†∏ÂøÉÊ™îÊ°à (‰ΩøÁî®Êú¨Ê©üÂø´Âèñ)...');
                const [coreURL, wasmURL, workerURL] = await Promise.all([
                    this.toBlobURLWithCache(`${baseURLMT}/ffmpeg-core.js`, 'text/javascript', progressCallback),
                    this.toBlobURLWithCache(`${baseURLMT}/ffmpeg-core.wasm`, 'application/wasm', progressCallback),
                    this.toBlobURLWithCache(`${baseURLMT}/ffmpeg-core.worker.js`, 'text/javascript', progressCallback),
                ]);
                progressCallback?.('ÂàùÂßãÂåñ FFmpeg...');
                await this.ffmpeg.load({ coreURL, wasmURL, workerURL });
                this.ffmpegMultiThread = true;
            } else {
                // Single-threaded version - more stable
                progressCallback?.('ËºâÂÖ• FFmpeg Ê†∏ÂøÉÊ™îÊ°à (‰ΩøÁî®Êú¨Ê©üÂø´Âèñ)...');
                const [coreURL, wasmURL] = await Promise.all([
                    this.toBlobURLWithCache(`${baseURL}/ffmpeg-core.js`, 'text/javascript', progressCallback),
                    this.toBlobURLWithCache(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm', progressCallback),
                ]);
                progressCallback?.('ÂàùÂßãÂåñ FFmpeg...');
                await this.ffmpeg.load({ coreURL, wasmURL });
                this.ffmpegMultiThread = false;
            }
        } catch (mtError) {
            // If multi-thread fails, fallback to single-thread
            if (useMultiThread) {
                console.warn('[FFmpeg] Multi-thread load failed, falling back to single-thread:', mtError);
                progressCallback?.('Â§öÂü∑Ë°åÁ∑íËºâÂÖ•Â§±ÊïóÔºå‰ΩøÁî®ÂñÆÂü∑Ë°åÁ∑íÊ®°Âºè...');
                const [coreURL, wasmURL] = await Promise.all([
                    this.toBlobURLWithCache(`${baseURL}/ffmpeg-core.js`, 'text/javascript', progressCallback),
                    this.toBlobURLWithCache(`${baseURL}/ffmpeg-core.wasm`, 'application/wasm', progressCallback),
                ]);
                await this.ffmpeg.load({ coreURL, wasmURL });
                this.ffmpegMultiThread = false;
            } else {
                throw mtError;
            }
        }
        
        this.ffmpegLoaded = true;
        const loadTime = ((performance.now() - startTime) / 1000).toFixed(1);
        console.log(`[FFmpeg] FFmpeg WASM loaded successfully in ${loadTime}s (multi-thread: ${this.ffmpegMultiThread})`);
        return this.ffmpeg;
    }
    
    // Fix WebM metadata using FFmpeg WASM (for streamed files)
    async fixWebmWithFFmpeg(fileHandle, progressCallback) {
        try {
            progressCallback?.(this.currentLanguage === 'zh-TW' ? 'ËºâÂÖ• FFmpeg ‰øÆÂæ©Ê®°ÁµÑ...' : 'Loading FFmpeg repair module...');
            const ffmpeg = await this.loadFFmpeg(progressCallback);
            
            // Read the file content
            progressCallback?.(this.currentLanguage === 'zh-TW' ? 'ËÆÄÂèñÂΩ±ÁâáÊ™îÊ°à...' : 'Reading video file...');
            const file = await fileHandle.getFile();
            const inputData = new Uint8Array(await file.arrayBuffer());
            
            // Write to FFmpeg virtual filesystem
            await ffmpeg.writeFile('input.webm', inputData);
            
            // Run FFmpeg to remux (copy streams, fix metadata)
            progressCallback?.(this.currentLanguage === 'zh-TW' ? '‰øÆÂæ©ÂΩ±Áâá‰∏≠ÁπºË≥áÊñô...' : 'Repairing video metadata...');
            await ffmpeg.exec([
                '-i', 'input.webm',
                '-c', 'copy',
                '-y',
                'output.webm'
            ]);
            
            // Read the fixed file
            const outputData = await ffmpeg.readFile('output.webm');
            
            // Clean up FFmpeg virtual filesystem
            try {
                await ffmpeg.deleteFile('input.webm');
                await ffmpeg.deleteFile('output.webm');
            } catch (e) {
                console.warn('[FFmpeg] Cleanup warning:', e);
            }
            
            // Write back to the original file
            progressCallback?.(this.currentLanguage === 'zh-TW' ? 'ÂÑ≤Â≠ò‰øÆÂæ©ÂæåÁöÑÂΩ±Áâá...' : 'Saving repaired video...');
            const writable = await fileHandle.createWritable();
            await writable.write(outputData);
            await writable.close();
            
            console.log('[FFmpeg] WebM metadata fixed successfully');
            return true;
        } catch (error) {
            console.error('[FFmpeg] Failed to fix WebM metadata:', error);
            return false;
        }
    }
    
    // Helper function to fetch file as Uint8Array (replaces @ffmpeg/util fetchFile)
    async fetchFileAsUint8Array(file) {
        if (file instanceof File) {
            return new Uint8Array(await file.arrayBuffer());
        } else if (file instanceof Blob) {
            return new Uint8Array(await file.arrayBuffer());
        } else if (typeof file === 'string') {
            // URL or path
            const response = await fetch(file);
            return new Uint8Array(await response.arrayBuffer());
        } else if (file instanceof Uint8Array) {
            return file;
        }
        throw new Error('Unsupported file type');
    }

    async processWithFFmpegWasm(clipSegments, cameras, startTime, endTime, addTimestamp, mergeGrid, eventStartTime, progressCallback, fileHandle = null, addLogo = false, addAudio = false) {
        // Set the progress callback for FFmpeg events
        this.ffmpegProgressCallback = progressCallback;
        
        const ffmpeg = await this.loadFFmpeg(progressCallback);
        
        // Track all temporary files to ensure cleanup
        const allCreatedFiles = [];
        
        // Prepare writable stream if available
        let writable = null;
        if (fileHandle) {
             try {
                 writable = await fileHandle.createWritable();
             } catch(e) {
                 console.warn("Create writable stream failed, fallback to memory mode", e);
             }
        }
        
        try {
            // Sort cameras for grid layout consistency
            let sortedCameras = cameras;
            if (mergeGrid) {
                 const order = ['front', 'back', 'left', 'right', 'left_pillar', 'right_pillar'];
                 sortedCameras = cameras.sort((a, b) => {
                     const idxA = order.indexOf(a);
                     const idxB = order.indexOf(b);
                     return (idxA === -1 ? 99 : idxA) - (idxB === -1 ? 99 : idxB);
                 });
            }

            // Load Font if needed (once) ‚Äî use bundled DejaVu Sans Bold
            let fontFile = null;
            if (addTimestamp) {
                progressCallback?.('ËºâÂÖ•Â≠óÈ´î...');
                try {
                     let fontData;
                     if (window.__TAURI__) {
                         const resDir = await window.__TAURI__.path.resourceDir();
                         const fSep = resDir.includes('\\') ? '\\' : '/';
                         fontData = await window.__TAURI__.fs.readFile(`${resDir}assets${fSep}fonts${fSep}dejavu-sans-bold.ttf`);
                     } else {
                         fontData = await this.fetchFileAsUint8Array('https://pub-007d01a7483d4a778c32807e257fedc8.r2.dev/fonts/dejavu-sans-bold.ttf');
                     }
                     await ffmpeg.writeFile('font.ttf', fontData);
                     fontFile = 'font.ttf';
                     allCreatedFiles.push('font.ttf');
                } catch (e) {
                     console.warn('Font load failed, timestamp disabled', e);
                     addTimestamp = false;
                }
            }

            // Load Logo if needed (once)
            let logoFile = null;
            if (addLogo) {
                progressCallback?.('ËºâÂÖ• Logo...');
                try {
                    let logoData;
                    if (window.__TAURI__) {
                        const resourceDir = await window.__TAURI__.path.resourceDir();
                        const sep = resourceDir.includes('\\') ? '\\' : '/';
                        logoData = await window.__TAURI__.fs.readFile(`${resourceDir}imgs${sep}TeslaCAM_256.png`);
                    } else {
                        logoData = await this.fetchFileAsUint8Array('imgs/TeslaCAM_256.png');
                    }
                    await ffmpeg.writeFile('logo.png', logoData);
                    logoFile = 'logo.png';
                    allCreatedFiles.push('logo.png');
                } catch (e) {
                    console.warn('Logo load failed, logo disabled', e);
                    addLogo = false;
                }
            }

            // Load background audio if needed (once)
            let bgmFile = null;
            if (addAudio) {
                progressCallback?.('ËºâÂÖ•ËÉåÊôØÈü≥Ê®Ç...');
                try {
                    const audioFiles = [
                        'M_Fischer.mp3', 'Take_Me_Down_To_The_Fashion_Show.mp3', 'Dopamina.mp3',
                        'Do_The_Bop.mp3', 'La_Fiesta_Y_La_Cruda.mp3', 'Los_Cabos.mp3',
                        'Chicago.mp3', 'Sugar_High.mp3', 'The_Monuments_and_Tunnels_in_Goa_and_Hampi.mp3'
                    ];
                    const selectedAudio = audioFiles[Math.floor(Math.random() * audioFiles.length)];
                    let audioData;
                    if (window.__TAURI__) {
                        const resourceDir = await window.__TAURI__.path.resourceDir();
                        const sep = resourceDir.includes('\\') ? '\\' : '/';
                        audioData = await window.__TAURI__.fs.readFile(`${resourceDir}audios${sep}${selectedAudio}`);
                    } else {
                        audioData = await this.fetchFileAsUint8Array(`https://audio.tinyomnibus.me/chronodrive/${selectedAudio}`);
                    }
                    await ffmpeg.writeFile('bgm.mp3', audioData);
                    bgmFile = 'bgm.mp3';
                    allCreatedFiles.push('bgm.mp3');
                } catch (e) {
                    console.warn('BGM load failed, audio disabled', e);
                    addAudio = false;
                }
            }

            // Process each segment sequentially to save memory
            // Use TS (MPEG-TS) for intermediate segments as it's streamable
            const tsBlobs = [];
            
            for (let i = 0; i < clipSegments.length; i++) {
                const seg = clipSegments[i];
                const segmentFiles = []; // Files for this segment only
                
                progressCallback?.(`ËôïÁêÜÁâáÊÆµ ${i + 1}/${clipSegments.length}...`);
                
                const cameraInputs = {};
                
                // 1. Write input files for this segment
                for (const cam of sortedCameras) {
                    const file = seg.segment.files[cam];
                    if (!file) continue;
                    
                    const filename = `s${i}_${cam}.mp4`;
                    let data;
                    if (file.path && window.__TAURI__) {
                         data = await window.__TAURI__.fs.readFile(file.path);
                    } else {
                         data = await this.fetchFileAsUint8Array(file);
                    }
                    
                    await ffmpeg.writeFile(filename, data);
                    segmentFiles.push(filename);
                    if (!cameraInputs[cam]) cameraInputs[cam] = [];
                    cameraInputs[cam].push(filename);
                    
                    // Allow GC
                    data = null;
                }
                
                // 2. Build filter graph for this segment
                let filterComplex = '';
                let inputIdx = 0;
                const cameraStreamNames = [];
                
                // Calculate timestamp for this segment
                let segmentTimestampStr = '';
                if (addTimestamp) {
                    // Base timestamp from file or fallback
                    const firstCam = sortedCameras[0];
                    const firstFile = seg.segment.files[firstCam];
                    const fileName = firstFile?.name || (firstFile?.path ? firstFile.path.split(/[/\\]/).pop() : null);
                    const fullTimestampMatch = fileName?.match(/(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})/);
                    
                    let segBaseTime;
                    if (fullTimestampMatch) {
                        segBaseTime = this.parseTimestamp(fullTimestampMatch[1]);
                    } else {
                        segBaseTime = this.parseTimestamp(seg.timestamp);
                    }
                    
                    // Add clipStart offset
                    const currentSegTime = new Date(segBaseTime.getTime() + seg.clipStart * 1000);
                    
                    segmentTimestampStr = currentSegTime.toLocaleString('zh-CN', {
                        year: 'numeric', month: '2-digit', day: '2-digit',
                        hour: '2-digit', minute: '2-digit', second: '2-digit',
                        hour12: false
                    }).replace(/\//g, '-');
                }

                // Build inputs and filters
                for (const cam of sortedCameras) {
                    if (!cameraInputs[cam]) continue;
                    
                    // Since we process one segment, there is only one file per camera here
                    const inputFile = cameraInputs[cam][0];
                    const inputStream = `[${inputIdx}:v]`;
                    inputIdx++;
                    
                    const trimmedStream = `[v_${cam}_trimmed]`;
                    // Use segment-specific clip duration
                    const duration = seg.clipEnd - seg.clipStart;
                    
                    filterComplex += `${inputStream}trim=start=${seg.clipStart}:duration=${duration},setpts=PTS-STARTPTS${trimmedStream};`;
                    cameraStreamNames.push({ name: trimmedStream, cam });
                }
                
                let finalStream = '';
                
                if (mergeGrid && cameraStreamNames.length > 1) {
                    // Grid logic with 6px gap
                    const gap = 6;
                    const scaledStreams = [];
                    const count = cameraStreamNames.length;
                    // Calculate cell size based on grid layout
                    const cols = count <= 4 ? 2 : 3;
                    const cellW = count <= 4 ? Math.floor((1920 - gap) / 2) : Math.floor((2880 - 2 * gap) / 3);
                    const cellH = Math.floor((1080 - gap) / 2);
                    for (const {name, cam} of cameraStreamNames) {
                        const scaledName = `[v_${cam}_scaled]`;
                        filterComplex += `${name}scale=${cellW}:${cellH}${scaledName};`;
                        scaledStreams.push(scaledName);
                    }

                    let stackLayout = '';
                    let xstackCount = count;
                    if (count === 4) stackLayout = `0_0|w0+${gap}_0|0_h0+${gap}|w0+${gap}_h0+${gap}`;
                    else if (count === 2) stackLayout = `0_0|w0+${gap}_0`;
                    else if (count === 3) {
                        // Generate "No Signal" blue placeholder as the 4th cell
                        const segDuration = seg.clipEnd - seg.clipStart;
                        filterComplex += `color=c=0x3B6EA5:s=${cellW}x${cellH}:d=${segDuration},format=yuv420p,drawtext=text='No Signal':fontcolor=white:fontsize=36:x=(w-tw)/2:y=(h-th)/2[v_nosig];`;
                        scaledStreams.push('[v_nosig]');
                        stackLayout = `0_0|w0+${gap}_0|0_h0+${gap}|w0+${gap}_h0+${gap}`;
                        xstackCount = 4;
                    }
                    else if (count === 6) stackLayout = `0_0|w0+${gap}_0|w0+w1+${gap*2}_0|0_h0+${gap}|w0+${gap}_h0+${gap}|w0+w1+${gap*2}_h0+${gap}`;
                    else stackLayout = '0_0';

                    finalStream = `[v_grid]`;
                    filterComplex += `${scaledStreams.join('')}xstack=inputs=${xstackCount}:layout=${stackLayout}:fill=black${finalStream};`;
                } else {
                    finalStream = cameraStreamNames[0].name;
                }
                
                // Add timestamp
                if (addTimestamp && fontFile) {
                    const stampedStream = `[v_final]`;
                    const escapedTimestamp = segmentTimestampStr.replace(/:/g, '\\:');
                    const drawText = `drawtext=fontfile=${fontFile}:text='${escapedTimestamp}':x=20:y=h-th-20:fontsize=42:fontcolor=white:borderw=3:bordercolor=black@0.8`;

                    filterComplex += `${finalStream}${drawText}${stampedStream}`;
                    finalStream = stampedStream;
                }

                // Add logo overlay
                let logoInputIdx = -1;
                if (addLogo && logoFile) {
                    // Logo input index = number of camera inputs
                    logoInputIdx = inputIdx; // inputIdx tracks the next available index
                    const logoStream = `[v_logo]`;
                    filterComplex += (filterComplex.endsWith(';') ? '' : ';') + `[${logoInputIdx}:v]format=rgba,colorchannelmixer=aa=0.85[logo_alpha];${finalStream}[logo_alpha]overlay=x=W-w-16:y=16[logo_v]`;
                    finalStream = `[logo_v]`;
                }

                if (filterComplex.endsWith(';')) filterComplex = filterComplex.slice(0, -1);

                const args = [];
                // Add inputs
                for (const cam of sortedCameras) {
                    if (cameraInputs[cam]) args.push('-i', cameraInputs[cam][0]);
                }
                // Add logo input
                if (addLogo && logoFile && logoInputIdx >= 0) {
                    args.push('-i', logoFile);
                }
                // Add background audio input
                if (addAudio && bgmFile) {
                    args.push('-i', bgmFile);
                }

                args.push('-filter_complex', filterComplex);
                args.push('-map', finalStream);
                // Audio mapping
                if (addAudio && bgmFile) {
                    const bgmIdx = inputIdx + (addLogo && logoFile ? 1 : 0);
                    args.push('-map', `${bgmIdx}:a`);
                    args.push('-c:a', 'aac', '-shortest');
                }

                // Encoding settings
                // Use MPEG-TS for intermediate segments
                args.push('-c:v', 'libx264', '-preset', 'ultrafast');
                // Cap bitrate to control file size and memory usage (4Mbps is sufficient for dashboard)
                args.push('-b:v', '4000k', '-maxrate', '4000k', '-bufsize', '8000k');
                args.push('-crf', '28'); // Slightly better quality than 32, but bitrate cap will control size
                args.push('-g', '48', '-bf', '0', '-pix_fmt', 'yuv420p');
                args.push('-f', 'mpegts'); // Output as TS
                
                const tempOutName = `temp_out_${i}.ts`;
                args.push(tempOutName);
                
                console.log(`[FFmpeg] Processing segment ${i}`, args.join(' '));
                await ffmpeg.exec(args);
                
                // Read temp file to JS memory
                const segData = await ffmpeg.readFile(tempOutName);
                
                if (writable) {
                     // Streaming write to disk directly
                     progressCallback?.(`ÂØ´ÂÖ•Á£ÅÁ¢ü (ÊÆµ ${i + 1})...`);
                     await writable.write(segData);
                } else {
                     // Convert to Blob immediately
                     const segBlob = new Blob([segData.buffer], { type: 'video/mp2t' });
                     tsBlobs.push(segBlob);
                }
                
                // Clean up WASM memory
                await ffmpeg.deleteFile(tempOutName);
                
                // CLEANUP INPUTS IMMEDIATELY
                for (const f of segmentFiles) {
                    await ffmpeg.deleteFile(f);
                }
                
                // Explicitly nullify
                data = null; 
            }
            
            if (writable) {
                 await writable.close();
                 this.ffmpegProgressCallback = null;
                 // Return empty blob to satisfy signature, but with saved: true
                 return new Blob([], { type: 'video/mp2t' });
            }
            
            // 3. Concat all segments (Memory Mode Fallback)
            progressCallback?.('ÂêàÂπ∂ÁâáÊÆµ...');
            
            try {
                const allTsBlob = new Blob(tsBlobs, { type: 'video/mp2t' });
                
                // Only try to remux if small enough
                const MAX_SAFE_SIZE = 500 * 1024 * 1024; // Lower limit to 500MB
                if (allTsBlob.size > MAX_SAFE_SIZE) {
                    console.warn('[FFmpeg] Total size too large, returning TS file');
                    return allTsBlob;
                }

                const allTsBuffer = await allTsBlob.arrayBuffer();
                const allTsUint8 = new Uint8Array(allTsBuffer);
                
                await ffmpeg.writeFile('all.ts', allTsUint8);
                allCreatedFiles.push('all.ts');
                
                progressCallback?.('Â∞ÅË£Ö MP4...');
                const args = [
                    '-i', 'all.ts',
                    '-c', 'copy',
                    '-movflags', '+faststart',
                    'output.mp4'
                ];
                
                await ffmpeg.exec(args);
                const finalOutputData = await ffmpeg.readFile('output.mp4');
                allCreatedFiles.push('output.mp4');
                
                const blob = new Blob([finalOutputData.buffer], { type: 'video/mp4' });
                
                // Final cleanup
                for (const f of allCreatedFiles) {
                    try { await ffmpeg.deleteFile(f); } catch {}
                }
                
                this.ffmpegProgressCallback = null;
                return blob;
                
            } catch (remuxError) {
                console.warn('[FFmpeg] MP4 Remux failed, falling back to TS:', remuxError);
                const finalBlob = new Blob(tsBlobs, { type: 'video/mp2t' });
                for (const f of allCreatedFiles) {
                    try { await ffmpeg.deleteFile(f); } catch {}
                }
                this.ffmpegProgressCallback = null;
                return finalBlob; 
            }

        } catch (e) {
            console.error('FFmpeg WASM Error:', e);
            if (writable) {
                 try { await writable.close(); } catch {}
            }
            this.ffmpegProgressCallback = null;
            // Attempt cleanup
            for (const f of allCreatedFiles) {
                try { await ffmpeg.deleteFile(f); } catch {}
            }
            throw new Error('ÁÄèË¶ΩÂô®ÂåØÂá∫Â§±Êïó: ' + e.message + "\\nÂª∫ËÆÆ‰ΩøÁî® Chrome ÊµèËßàÂô®ÊàñÂ∞ùËØïÊú¨Âú∞Â∫îÁî®Ê®°Âºè„ÄÇ");
        }
    }

    initCanvas(width, height) {
        if (!this.canvas) {
            this.canvas = document.createElement('canvas');
            this.ctx = this.canvas.getContext('2d');
        }
        this.canvas.width = width;
        this.canvas.height = height;
    }
    
    async checkFFmpeg() {
        const tauri = window.__TAURI__;
        if (!tauri || !tauri.shell) {
            console.warn('[FFmpeg] Tauri shell not available');
            return false;
        }
        try {
            console.log('[FFmpeg] Checking bundled FFmpeg availability...');
            // Try bundled FFmpeg first (sidecar)
            try {
                const sidecarCommand = tauri.shell.Command.sidecar('binaries/ffmpeg', ['-version']);
                const sidecarOutput = await sidecarCommand.execute();
                if (sidecarOutput.code === 0) {
                    console.log('[FFmpeg] Bundled FFmpeg available');
                    this.ffmpegCommand = 'sidecar';
                    return true;
                }
            } catch (e) {
                console.log('[FFmpeg] Bundled FFmpeg not available, trying system FFmpeg...');
            }
            
            // Fallback to system FFmpeg
            const command = tauri.shell.Command.create('ffmpeg', ['-version']);
            const output = await command.execute();
            console.log('[FFmpeg] System FFmpeg check result:', output);
            if (output.code === 0) {
                this.ffmpegCommand = 'system';
                return true;
            }
            return false;
        } catch (e) {
            console.warn('[FFmpeg] Check failed:', e);
            return false;
        }
    }
    
    createFFmpegCommand(args) {
        const tauri = window.__TAURI__;
        if (this.ffmpegCommand === 'sidecar') {
            return tauri.shell.Command.sidecar('binaries/ffmpeg', args);
        }
        return tauri.shell.Command.create('ffmpeg', args);
    }

    /**
     * Execute FFmpeg command with real-time progress updates
     */
    async executeFFmpegWithProgress(args, totalDuration, progressCallback, progressPrefix) {
        if (!progressPrefix) {
            progressPrefix = this.currentLanguage === 'zh-TW' ? 'Á∑®Á¢º‰∏≠...' : 'Encoding...';
        }
        const tauri = window.__TAURI__;
        const command = this.createFFmpegCommand(args);
        
        return new Promise((resolve, reject) => {
            let stderr = '';
            let resolved = false;
            let lastProgressTime = Date.now();
            let progressCheckInterval = null;
            let childProcess = null;
            
            const cleanup = () => {
                if (progressCheckInterval) {
                    clearInterval(progressCheckInterval);
                    progressCheckInterval = null;
                }
            };
            
            const onFinished = data => {
                if (resolved) return;
                resolved = true;
                cleanup();
                
                console.log('[FFmpeg] Process finished/terminated:', data);
                const code = typeof data === 'number' ? data : (data && typeof data.code === 'number' ? data.code : 0);
                
                if (code === 0) {
                    resolve({ code: 0, stderr });
                } else {
                    const lastError = stderr.split('\n').filter(l => l.includes('Error') || l.includes('error')).pop() || 'Êú™Áü•ÈåØË™§';
                    reject(new Error(`FFmpeg ÈåØË™§ (code ${code}): ${lastError}`));
                }
            };

            command.on('close', onFinished);
            command.on('terminated', onFinished);
            
            command.on('error', error => {
                if (resolved) return;
                resolved = true;
                cleanup();
                console.error('[FFmpeg] Process error:', error);
                reject(error);
            });
            
            command.on('stdout', line => {
                // Consume stdout to prevent buffer fill
                lastProgressTime = Date.now();
                if (line && line.includes('progress=end')) {
                    console.log('[FFmpeg] Progress end detected in stdout');
                }
            });
            
            command.on('stderr', line => {
                // line is usually a string in Tauri v2 shell plugin
                stderr += line + '\n';
                lastProgressTime = Date.now();
                
                // Detailed logging for debugging
                if (line.includes('Error') || line.includes('error')) {
                    console.error('[FFmpeg stderr]', line);
                }
                
                // Keep stderr buffer manageable
                if (stderr.length > 20000) {
                    stderr = stderr.substring(stderr.length - 10000);
                }
                
                // Parse FFmpeg progress: time=00:00:05.12 or time=00:00:05.123
                const timeMatch = line.match(/time=(\d{2}):(\d{2}):(\d{2})\.(\d+)/);
                if (timeMatch && totalDuration > 0) {
                    const hours = parseInt(timeMatch[1], 10);
                    const minutes = parseInt(timeMatch[2], 10);
                    const seconds = parseInt(timeMatch[3], 10);
                    const msStr = timeMatch[4];
                    // Handle different millisecond lengths (.1, .12, .123)
                    const ms = parseFloat("0." + msStr);
                    const currentTime = hours * 3600 + minutes * 60 + seconds + ms;
                    
                    const progress = Math.min(99, Math.round((currentTime / totalDuration) * 100));
                    progressCallback?.(`${progressPrefix} ${progress}%`);
                    
                    // Check if we've reached near the end
                    if (currentTime >= totalDuration - 0.5) {
                        console.log('[FFmpeg] Reached end of expected duration, waiting for process to finish...');
                    }
                }
            });
            
            console.log('[FFmpeg] Spawning process with args:', args.slice(0, 10).join(' '), '...');
            command.spawn().then(child => {
                childProcess = child;
                this.ffmpegChild = child;
                console.log('[FFmpeg] Process spawned successfully, PID:', child.pid);
                
                // Set up a watchdog to detect if FFmpeg has stalled
                // Check every 30 seconds if we've received any output
                progressCheckInterval = setInterval(() => {
                    const timeSinceLastProgress = Date.now() - lastProgressTime;
                    console.log(`[FFmpeg Watchdog] Time since last output: ${Math.round(timeSinceLastProgress / 1000)}s`);
                    
                    // If no output for 2 minutes, something is wrong
                    if (timeSinceLastProgress > 120000 && !resolved) {
                        console.warn('[FFmpeg Watchdog] No output for 2 minutes, process may be stuck');
                        console.warn('[FFmpeg Watchdog] Last stderr:', stderr.slice(-500));
                    }
                }, 30000);
            }).catch(err => {
                cleanup();
                console.error('[FFmpeg] Failed to spawn process:', err);
                reject(err);
            });
        });
    }

    async processWithFFmpeg(clipSegments, camera, progressCallback) {
        const tauri = window.__TAURI__;
        const fs = tauri.fs;
        const shell = tauri.shell;
        
        // Use the directory of the first file for output, temp dir for intermediate files
        const firstFile = clipSegments[0].segment.files[camera];
        if (!firstFile || !firstFile.path) throw new Error('File path not found');
        
        // Get directory path (handle both forward and back slashes)
        const pathSeparator = firstFile.path.includes('\\') ? '\\' : '/';
        const lastSepIdx = firstFile.path.lastIndexOf(pathSeparator);
        const outputDir = lastSepIdx !== -1 ? firstFile.path.substring(0, lastSepIdx) : '.';
        
        // Use system temp directory for intermediate files
        let workDir = await getTempDir();
        const workSeparator = workDir.includes('\\') ? '\\' : '/';
        
        const timestamp = new Date().getTime();
        const listFilename = `ffmpeg_list_${camera}_${timestamp}.txt`;
        const outputFilename = `export_${camera}_${timestamp}.mp4`;
        
        const listPath = `${workDir}${workSeparator}${listFilename}`;
        const outputPath = `${outputDir}${pathSeparator}${outputFilename}`;
        
        // Generate list content
        let listContent = '';
        for (const seg of clipSegments) {
            const file = seg.segment.files[camera];
            if (!file || !file.path) continue;
            
            // For ffmpeg concat, paths should be escaped
            // FFmpeg concat demuxer needs forward slashes even on Windows
            const safePath = file.path.replace(/\\/g, '/').replace(/'/g, "'\\''");
            listContent += `file '${safePath}'\n`;
            listContent += `inpoint ${seg.clipStart}\n`;
            listContent += `outpoint ${seg.clipEnd}\n`;
        }
        
        try {
            // Write list file
            await fs.writeTextFile(listPath, listContent);
            
            // ffmpeg args
            const args = [
                '-f', 'concat',
                '-safe', '0',
                '-i', listPath,
                '-c', 'copy',
                '-y',
                outputPath
            ];
            
            console.log('Running ffmpeg:', args);
            progressCallback?.(this.currentLanguage === 'zh-TW' ? `FFmpeg Ê•µÈÄüÂåØÂá∫‰∏≠...` : `FFmpeg Fast Exporting...`);
            
            const totalDuration = clipSegments.reduce((sum, seg) => {
                const dur = (seg.clipEnd || 60) - (seg.clipStart || 0);
                return sum + (dur > 0 ? dur : 0);
            }, 0);
            const output = await this.executeFFmpegWithProgress(args, totalDuration, progressCallback, this.currentLanguage === 'zh-TW' ? 'Ê•µÈÄüÂåØÂá∫...' : 'Fast Exporting...');
            
            // Read result
            const binary = await fs.readFile(outputPath);
            const blob = new Blob([binary], { type: 'video/mp4' });
            
            // Cleanup
            await fs.remove(listPath);
            await fs.remove(outputPath);
            
            return blob;
            
        } catch (e) {
            // Cleanup on error
            try { await fs.remove(listPath); } catch(_) {}
            try { await fs.remove(outputPath); } catch(_) {}
            throw e;
        }
    }




    async processClip(segments, cameras, startTime, endTime, addTimestamp, addMetadata, mergeGrid, eventStartTime, progressCallback, useLocalFFmpeg = false, language = 'zh-TW', fileHandle = null, metadataManager = null, addLogo = false, addAudio = false, colorAdjust = {}) {
        try {
            // Reset cancellation state
            this.isCancelled = false;
            // Store language for use in processing methods
            this.currentLanguage = language;
            this.metadataManager = metadataManager;
            // Calculate which segments are needed
            const clipSegments = this.getSegmentsForTimeRange(segments, startTime, endTime);
            
            if (clipSegments.length === 0) {
                throw new Error('Êú™ÊâæÂà∞ÊúâÊïàÁöÑÂΩ±ÁâáÁâáÊÆµ');
            }

            // 1. Use local FFmpeg if requested (Tauri desktop only)
            if (useLocalFFmpeg && window.__TAURI__) {
                const hasFFmpeg = await this.checkFFmpeg();
                if (!hasFFmpeg) {
                    throw new Error('Êú™ÂÅµÊ∏¨Âà∞ FFmpegÔºåË´ãÂÖàÂÆâË£ù FFmpeg ‰∏¶Á¢∫‰øùÂÖ∂Âú®Á≥ªÁµ± PATH ‰∏≠');
                }
                
                console.log('[VideoClipProcessor] Using local FFmpeg for export');
                
                if (mergeGrid && cameras.length > 1) {
                    // FFmpeg grid merge with optional timestamp and metadata
                    progressCallback?.(this.currentLanguage === 'zh-TW' ? 'FFmpeg ÂêàÊàêÂõõÂÆÆÊ†ºÂΩ±Áâá...' : 'FFmpeg Merging Grid Video...');
                    const result = await this.processWithFFmpegGrid(clipSegments, cameras, addTimestamp, addMetadata, eventStartTime, progressCallback, addLogo, addAudio, colorAdjust);
                    return [result];
                } else {
                    // FFmpeg single camera export
                    const results = [];
                    for (const camera of cameras) {
                        if (this.isCancelled) throw new Error(this.currentLanguage === 'zh-TW' ? 'ÂåØÂá∫Â∑≤ÂèñÊ∂à' : 'Export Cancelled');
                        progressCallback?.(this.currentLanguage === 'zh-TW' ? `FFmpeg Ê•µÈÄüÂåØÂá∫ ${camera}...` : `FFmpeg Fast Exporting ${camera}...`);
                        const result = await this.processWithFFmpegFull(clipSegments, camera, addTimestamp, addMetadata, eventStartTime, progressCallback, addLogo, addAudio, colorAdjust);
                        results.push(result);
                    }
                    return results;
                }
            }

            // 2. Fallback: Try native FFmpeg for fast copy (no timestamp, no grid, no metadata, no logo, no audio) - Tauri only
            const hasFFmpeg = await this.checkFFmpeg();
            const _hasColor = (colorAdjust.saturation ?? 100) !== 100 || (colorAdjust.contrast ?? 100) !== 100 || (colorAdjust.brightness ?? 100) !== 100;
            if (hasFFmpeg && !addTimestamp && !addMetadata && !mergeGrid && !addLogo && !addAudio && !_hasColor) {
                 const results = [];
                 for (const camera of cameras) {
                     progressCallback?.(`Ê•µÈÄüÂåØÂá∫ ${camera}...`);
                     const blob = await this.processWithFFmpeg(clipSegments, camera, progressCallback);
                     results.push({ camera, blob });
                 }
                 return results;
            }
            
            // 3. Web FFmpeg (WASM) for Grid or Timestamp in Browser
            // If we have fileHandle (streaming mode), force use Web FFmpeg logic even if cameras.length=1
            // But currently processWithFFmpegWasm is only called if we implement it here.
            // Wait, previous logic called createGridVideoFromSegments or processVideoWithTimestamp (Canvas).
            // We want to replace Canvas with FFmpegWASM for better quality if possible, OR just optimize processWithFFmpegWasm
            
            // Previously, there was NO call to processWithFFmpegWasm in processClip in the provided snippet!
            // Wait, let's check the original code again.
            // Ah, the original code used Canvas (createGridVideoFromSegments / processVideoWithTimestamp).
            // But I modified processWithFFmpegWasm earlier. Where is it called?
            // It seems processWithFFmpegWasm was added but maybe not hooked up in processClip in the original code, 
            // OR I missed where it was called.
            
            // Let's hook it up. If fileHandle is provided, OR if we want to use WASM instead of Canvas.
            // Using WASM is generally better quality than Canvas recording but slower.
            // If the user is on Web, we prefer WASM for Grid/Timestamp to avoid re-encoding loss of Canvas recording (which is real-time-ish).
            
            // However, to be safe and stick to the "fix memory" goal:
            // If fileHandle is present, we MUST use processWithFFmpegWasm because Canvas recording doesn't support stream writing easily (MediaRecorder returns chunks, we could write chunks...).
            // Actually MediaRecorder chunks CAN be written to fileHandle!
            // But processWithFFmpegWasm was the one I optimized.
            
            // Let's use processWithFFmpegWasm if fileHandle is present OR if we want higher quality.
            // For now, let's only enable it if fileHandle is present to test the fix.
            
            if (fileHandle) {
                 progressCallback?.('Ê≠£Âú®‰ΩøÁî®ÊµÅÂºèÂåØÂá∫Ê®°Âºè (Canvas)...');

                 // Â¶ÇÊûúÊòØÂêàÂπ∂ÂõõÂÆÆÊ†º
                 if (mergeGrid && cameras.length > 1) {
                     const result = await this.createGridVideoFromSegments(
                        clipSegments,
                        cameras,
                        startTime,
                        endTime,
                        addTimestamp,
                        addMetadata,
                        eventStartTime,
                        progressCallback,
                        fileHandle,
                        addLogo,
                        addAudio,
                        colorAdjust
                    );
                    const blob = result.saved ? result.blob : result;
                    const saved = !!result.saved;
                    return [{ camera: 'grid', blob: blob, saved: saved }];
                 } else {
                     const results = [];
                     for (const camera of cameras) {
                         const result = await this.processVideoWithTimestamp(
                            clipSegments,
                            camera,
                            startTime,
                            endTime,
                            addTimestamp,
                            addMetadata,
                            eventStartTime,
                            progressCallback,
                            fileHandle,
                            addLogo,
                            addAudio,
                            colorAdjust
                        );
                        const blob = result.saved ? result.blob : result;
                        const saved = !!result.saved;
                        results.push({ camera, blob: blob, saved: saved });
                     }
                     return results;
                 }
            }

            // 3. If merging as grid, process all cameras together (Canvas method)
            if (mergeGrid && cameras.length > 1) {
                progressCallback?.('ÂêàÊàêÂõõÂÆÆÊ†ºÂΩ±Áâá...');
                const gridBlob = await this.createGridVideoFromSegments(
                    clipSegments,
                    cameras,
                    startTime,
                    endTime,
                    addTimestamp,
                    addMetadata,
                    eventStartTime,
                    progressCallback,
                    null,
                    addLogo,
                    addAudio,
                    colorAdjust
                );
                return [{ camera: 'grid', blob: gridBlob }];
            }

            // 5. Otherwise, process each camera individually (Canvas method - fallback)
            const results = [];

            for (const camera of cameras) {
                progressCallback?.(`ËôïÁêÜ ${camera} ÊîùÂΩ±Ê©ü...`);

                const videoBlob = await this.processVideoWithTimestamp(
                    clipSegments,
                    camera,
                    startTime,
                    endTime,
                    addTimestamp,
                    addMetadata,
                    eventStartTime,
                    progressCallback,
                    null,
                    addLogo,
                    addAudio,
                    colorAdjust
                );

                results.push({ camera, blob: videoBlob });
            }

            return results;
            
        } catch (error) {
            console.error('Video processing error:', error);
            throw error;
        } finally {
            // Clean up canvas and media recorder resources
            this.cleanup();
        }
    }
    
    // FFmpeg full export with optional timestamp and metadata (single camera)
    async processWithFFmpegFull(clipSegments, camera, addTimestamp, addMetadata, eventStartTime, progressCallback, addLogo = false, addAudio = false, colorAdjust = {}) {
        const tauri = window.__TAURI__;
        const fs = tauri.fs;
        const shell = tauri.shell;
        
        const firstFile = clipSegments[0].segment.files[camera];
        if (!firstFile || !firstFile.path) throw new Error(`${camera} ÊîùÂΩ±Ê©üÊ™îÊ°àË∑ØÂæëÊú™ÊâæÂà∞`);
        
        const pathSeparator = firstFile.path.includes('\\') ? '\\' : '/';
        const lastSepIdx = firstFile.path.lastIndexOf(pathSeparator);
        const outputDir = lastSepIdx !== -1 ? firstFile.path.substring(0, lastSepIdx) : '.';
        
        // Use system temp directory for intermediate files
        let workDir = await getTempDir();
        const workSeparator = workDir.includes('\\') ? '\\' : '/';
        
        const timestamp = new Date().getTime();
        const listFilename = `ffmpeg_list_${camera}_${timestamp}.txt`;
        const outputFilename = `TeslaCam_${camera}_${timestamp}.mp4`;
        
        const listPath = `${workDir}${workSeparator}${listFilename}`;
        const outputPath = `${outputDir}${pathSeparator}${outputFilename}`;
        
        // Track temp files for cleanup
        const tempFiles = [listPath];
        
        // Generate concat list
        let listContent = '';
        for (const seg of clipSegments) {
            const file = seg.segment.files[camera];
            if (!file || !file.path) continue;
            const safePath = file.path.replace(/\\/g, '/').replace(/'/g, "'\\''");
            listContent += `file '${safePath}'\n`;
            listContent += `inpoint ${seg.clipStart}\n`;
            listContent += `outpoint ${seg.clipEnd}\n`;
        }
        
        try {
            await fs.writeTextFile(listPath, listContent);
            
            // Calculate total duration early for trim filters
            const totalDuration = clipSegments.reduce((sum, seg) => {
                const dur = (seg.clipEnd || 60) - (seg.clipStart || 0);
                return sum + (dur > 0 ? dur : 0);
            }, 0);
            
            // Generate PNG overlay for metadata if enabled
            let allMetadata = null;
            let overlayInfo = null;
            
            if (addMetadata && this.metadataManager) {
                progressCallback?.(`ËºâÂÖ• ${camera} ‰∏≠ÁπºË≥áÊñô...`);
                allMetadata = await this.loadMetadataForSegments(clipSegments, camera, progressCallback);
                
                if (allMetadata && allMetadata.length > 0) {
                    // Tesla cameras are typically 1280x960
                    const videoWidth = 1280;
                    const videoHeight = 960;
                    
                    progressCallback?.(`ÁîüÊàê‰∏≠ÁπºË≥áÊñôË¶ÜËìãÂ±§...`);
                    try {
                        overlayInfo = await metadataOverlayGenerator.generateOverlayPngs(
                            allMetadata,
                            clipSegments,
                            workDir,
                            videoWidth,
                            videoHeight,
                            progressCallback,
                            this.currentLanguage
                        );
                        if (overlayInfo) {
                            tempFiles.push(overlayInfo.pngDir);
                            console.log('[FFmpeg] PNG overlays generated:', overlayInfo.pngDir);
                        }
                    } catch (pngError) {
                        console.error('[FFmpeg] PNG overlay generation failed:', pngError);
                        overlayInfo = null;
                    }
                }
            }
            
            // Build filter chain
            let filterComplex = '';
            let inputArgs = ['-fflags', '+genpts', '-f', 'concat', '-safe', '0', '-i', listPath];
            let nextInputIdx = 1; // input 0 is the concat video

            console.log(`[FFmpeg] Exporting ${camera}, calculated duration: ${totalDuration}s`);

            let currentLabel = '[0:v]';
            
            // Normalize video stream if we are re-encoding (timestamp, metadata, or logo enabled)
            // This is CRITICAL to fix duration shortening issues caused by PTS gaps in concat demuxer
            const _fSat = colorAdjust.saturation ?? 100;
            const _fCon = colorAdjust.contrast ?? 100;
            const _fBri = colorAdjust.brightness ?? 100;
            const hasColorAdjust = _fSat !== 100 || _fCon !== 100 || _fBri !== 100;
            if (addTimestamp || addMetadata || addLogo || hasColorAdjust) {
                // Use fps filter to fill gaps, setpts to ensure continuous timeline from 0
                // and trim to force the expected duration.
                const eqPart = hasColorAdjust
                    ? `,eq=saturation=${(_fSat / 100).toFixed(2)}:contrast=${(_fCon / 100).toFixed(2)}:brightness=${((_fBri - 100) / 100).toFixed(2)}`
                    : '';
                filterComplex = `${currentLabel}fps=fps=30,setpts=PTS-STARTPTS,trim=duration=${totalDuration}${eqPart}[v_sync]`;
                currentLabel = '[v_sync]';
            }

            // Add timestamp filter if enabled
            if (addTimestamp) {
                const firstFileRef = clipSegments[0].segment.files[camera];
                const fileName = firstFileRef.name || firstFileRef.path.split(/[/\\]/).pop();
                const fullTimestampMatch = fileName.match(/(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})/);
                
                let firstSegTime;
                if (fullTimestampMatch) {
                    firstSegTime = this.parseTimestamp(fullTimestampMatch[1]);
                } else {
                    firstSegTime = this.parseTimestamp(clipSegments[0].timestamp);
                }
                
                const clipStartTimeObj = new Date(firstSegTime.getTime() + clipSegments[0].clipStart * 1000);
                const startEpoch = Math.floor(clipStartTimeObj.getTime() / 1000);
                
                // Use bundled DejaVu font
                const resourceDir = await tauri.path.resourceDir();
                const fontSep = resourceDir.includes('\\') ? '\\' : '/';
                const fontPath = `${resourceDir}assets${fontSep}fonts${fontSep}dejavu-sans-bold.ttf`.replace(/\\/g, '/').replace(/'/g, "'\\''");
                const fontOption = `fontfile='${fontPath}':`;

                // White text with black border (no background box), larger font
                const drawtext = `drawtext=${fontOption}text='%{pts\\:localtime\\:${startEpoch}}':x=20:y=h-th-20:fontsize=32:fontcolor=white:borderw=3:bordercolor=black@0.8`;
                filterComplex += (filterComplex ? ';' : '') + `${currentLabel}${drawtext}[ts]`;
                currentLabel = '[ts]';
            }

            // Add PNG overlay filters for metadata
            if (addMetadata && overlayInfo && overlayInfo.pngPaths && overlayInfo.pngPaths.size > 0) {
                const overlayResult = await metadataOverlayGenerator.generateOverlayFilter(
                    allMetadata,
                    clipSegments,
                    overlayInfo.pngPaths,
                    workDir,
                    1 // Video is input 0
                );
                
                if (overlayResult.concatFile) {
                    // Add background and concat stream to inputs
                    const bgPath = overlayInfo.pngPaths.get('__background__');
                    // Use -loop 1 for background image
                    inputArgs.push('-loop', '1', '-i', bgPath);
                    const bgIdx = nextInputIdx++;

                    inputArgs.push('-f', 'concat', '-safe', '0', '-i', overlayResult.concatFile);
                    const metaIdx = nextInputIdx++;

                    tempFiles.push(overlayResult.concatFile);

                    // Overlay background then metadata stream
                    const xExpr = '(W-w)/2';
                    const yExpr = '(H*0.97-h/2)';

                    // Background and metadata streams also need synchronization
                    const bgTrim = `[${bgIdx}:v]trim=duration=${totalDuration},setpts=PTS-STARTPTS[bg_trimmed]`;
                    const metaSync = `[${metaIdx}:v]setpts=PTS-STARTPTS[meta_sync]`;

                    // Apply overlays using synchronized streams
                    const ovPart = `${bgTrim};${metaSync};${currentLabel}[bg_trimmed]overlay=x=${xExpr}:y=${yExpr}:eof_action=pass[bg_v];[bg_v][meta_sync]overlay=x=${xExpr}:y=${yExpr}:eof_action=pass[ov]`;

                    filterComplex += (filterComplex ? ';' : '') + ovPart;
                    currentLabel = '[ov]';
                }
            }

            // Add Logo watermark overlay
            if (addLogo) {
                const tauri = window.__TAURI__;
                try {
                    const resourceDir = await tauri.path.resourceDir();
                    const sep = resourceDir.includes('\\') ? '\\' : '/';
                    const logoPath = `${resourceDir}imgs${sep}TeslaCAM_256.png`;
                    inputArgs.push('-i', logoPath);
                    const logoIdx = nextInputIdx++;
                    const logoPart = `[${logoIdx}:v]format=rgba,colorchannelmixer=aa=0.85[logo_alpha];${currentLabel}[logo_alpha]overlay=x=W-w-16:y=16:eof_action=pass[logo_out]`;
                    filterComplex += (filterComplex ? ';' : '') + logoPart;
                    currentLabel = '[logo_out]';
                } catch (logoErr) {
                    console.warn('[FFmpeg] Logo overlay failed:', logoErr);
                }
            }

            // Add background audio input
            let audioInputIdx = -1;
            if (addAudio) {
                try {
                    const audioFiles = [
                        'M_Fischer.mp3', 'Take_Me_Down_To_The_Fashion_Show.mp3', 'Dopamina.mp3',
                        'Do_The_Bop.mp3', 'La_Fiesta_Y_La_Cruda.mp3', 'Los_Cabos.mp3',
                        'Chicago.mp3', 'Sugar_High.mp3', 'The_Monuments_and_Tunnels_in_Goa_and_Hampi.mp3'
                    ];
                    const selectedAudio = audioFiles[Math.floor(Math.random() * audioFiles.length)];
                    const resourceDir = await tauri.path.resourceDir();
                    const sep = resourceDir.includes('\\') ? '\\' : '/';
                    const audioPath = `${resourceDir}audios${sep}${selectedAudio}`;
                    inputArgs.push('-i', audioPath);
                    audioInputIdx = nextInputIdx++;
                    console.log(`[FFmpeg] Background audio: ${selectedAudio} (input ${audioInputIdx})`);
                } catch (audioErr) {
                    console.warn('[FFmpeg] Background audio failed:', audioErr);
                    audioInputIdx = -1;
                }
            }

            let args;
            if (filterComplex) {
                // With filters: need re-encode
                // Use filter_complex_script to avoid command line length limits on Windows
                const filterScriptPath = `${workDir}${pathSeparator}ffmpeg_filter_${timestamp}.txt`;
                console.log('[FFmpeg] Filter complex content:', filterComplex);
                console.log('[FFmpeg] Current label for -map:', currentLabel);
                await fs.writeTextFile(filterScriptPath, filterComplex);
                tempFiles.push(filterScriptPath);

                args = [
                    ...inputArgs,
                    '-filter_complex_script', filterScriptPath,
                    '-map', currentLabel,
                    ...(audioInputIdx >= 0 ? ['-map', `${audioInputIdx}:a`] : ['-map', '0:a?']),
                    '-c:v', 'libx264',
                    '-preset', 'fast',
                    '-crf', '23',
                    '-c:a', 'aac',
                    ...(audioInputIdx >= 0 ? ['-shortest'] : []),
                    '-t', String(Math.ceil(totalDuration + 0.5)),
                    '-y',
                    outputPath
                ];
            } else {
                // Without filters: fast copy
                args = [
                    '-f', 'concat',
                    '-safe', '0',
                    '-i', listPath,
                    '-c', 'copy',
                    '-y',
                    outputPath
                ];
            }
            
            console.log('[FFmpeg] Running:', args.join(' '));
            progressCallback?.(this.currentLanguage === 'zh-TW' ? `FFmpeg ËôïÁêÜ ${camera}...` : `FFmpeg Processing ${camera}...`);
            
            // totalDuration already calculated at line 4166
            const output = await this.executeFFmpegWithProgress(args, totalDuration, progressCallback, this.currentLanguage === 'zh-TW' ? `ËôïÁêÜ ${camera}...` : `Processing ${camera}...`);
            progressCallback?.(this.currentLanguage === 'zh-TW' ? `ËôïÁêÜ ${camera}: 100%` : `Processing ${camera}: 100%`);
            
            console.log('[FFmpeg] Finished processing camera:', camera);
            
            if (output.code !== 0) {
                throw new Error(`FFmpeg ÈåØË™§ (code ${output.code}): ${output.stderr || output.stdout || 'Êú™Áü•ÈåØË™§'}`);
            }
            
            // Cleanup temp files
            for (const f of tempFiles) {
                try { 
                    // Check if it's a directory (PNG overlay dir)
                    if (f.includes('overlay_pngs_')) {
                        await this.removeDirectory(f, fs);
                    } else {
                        await fs.remove(f); 
                    }
                } catch(_) {}
            }
            
            return { camera, path: outputPath, isFile: true };
            
        } catch (e) {
            // Cleanup on error
            for (const f of tempFiles) {
                try { 
                    if (f.includes('overlay_pngs_')) {
                        await this.removeDirectory(f, fs);
                    } else {
                        await fs.remove(f); 
                    }
                } catch(_) {}
            }
            try { await fs.remove(outputPath); } catch(_) {}
            throw e;
        }
    }
    
    // Helper to remove directory recursively
    async removeDirectory(dirPath, fs) {
        try {
            const entries = await fs.readDir(dirPath);
            for (const entry of entries) {
                const entryPath = entry.path || `${dirPath}/${entry.name}`;
                if (entry.children !== undefined) {
                    await this.removeDirectory(entryPath, fs);
                } else {
                    await fs.remove(entryPath);
                }
            }
            await fs.remove(dirPath);
        } catch (e) {
            console.warn('[FFmpeg] Failed to remove directory:', dirPath, e);
        }
    }
    
    // FFmpeg grid merge export with optional timestamp and metadata
    async processWithFFmpegGrid(clipSegments, cameras, addTimestamp, addMetadata, eventStartTime, progressCallback, addLogo = false, addAudio = false, colorAdjust = {}) {
        const tauri = window.__TAURI__;
        const fs = tauri.fs;
        const shell = tauri.shell;

        // Sort cameras for 6-grid layout
        let sortedCameras = [...cameras];
        if (cameras.length > 4) {
            const sortOrder = ['left_pillar', 'front', 'right_pillar', 'left', 'back', 'right'];
            sortedCameras.sort((a, b) => {
                const idxA = sortOrder.indexOf(a);
                const idxB = sortOrder.indexOf(b);
                return (idxA === -1 ? 99 : idxA) - (idxB === -1 ? 99 : idxB);
            });
        } else {
             // Standard layout for <= 4 cameras
             const sortOrder = ['front', 'back', 'left', 'right', 'left_pillar', 'right_pillar'];
             sortedCameras.sort((a, b) => {
                const idxA = sortOrder.indexOf(a);
                const idxB = sortOrder.indexOf(b);
                return (idxA === -1 ? 99 : idxA) - (idxB === -1 ? 99 : idxB);
            });
        }
        
        // Filter out cameras that have no files in the selected range to prevent FFmpeg hangs
        const activeCameras = sortedCameras.filter(cam => 
            clipSegments.some(seg => seg.segment.files[cam] && seg.segment.files[cam].path)
        );
        
        if (activeCameras.length === 0) throw new Error('Ê≤íÊúâÂèØÂåØÂá∫ÁöÑÂΩ±Áâá‰∏≤ÊµÅ');
        
        const firstFile = clipSegments.find(seg => seg.segment.files[activeCameras[0]] && seg.segment.files[activeCameras[0]].path)?.segment.files[activeCameras[0]];
        if (!firstFile) throw new Error('Ê™îÊ°àË∑ØÂæëÊú™ÊâæÂà∞');
        
        const pathSeparator = firstFile.path.includes('\\') ? '\\' : '/';
        const lastSepIdx = firstFile.path.lastIndexOf(pathSeparator);
        const outputDir = lastSepIdx !== -1 ? firstFile.path.substring(0, lastSepIdx) : '.';
        
        // Use system temp directory for intermediate files
        let workDir = await getTempDir();
        const workSeparator = workDir.includes('\\') ? '\\' : '/';
        
        const timestamp = new Date().getTime();
        const outputFilename = `TeslaCam_grid_${timestamp}.mp4`;
        const outputPath = `${outputDir}${pathSeparator}${outputFilename}`;
        
        // Create temp concat files for each camera
        const tempFiles = [];
        const inputArgs = [];
        
        try {
            // Build concat files for each camera and track which ones have content
            const validCameras = [];
            for (const camera of activeCameras) {
                const listFilename = `ffmpeg_list_${camera}_${timestamp}.txt`;
                const listPath = `${workDir}${workSeparator}${listFilename}`;
                tempFiles.push(listPath);
                
                let listContent = '';
                for (const seg of clipSegments) {
                    const file = seg.segment.files[camera];
                    if (!file || !file.path) continue;
                    const safePath = file.path.replace(/\\/g, '/').replace(/'/g, "'\\''");
                    listContent += `file '${safePath}'\n`;
                    listContent += `inpoint ${seg.clipStart}\n`;
                    listContent += `outpoint ${seg.clipEnd}\n`;
                }
                
                // Only add cameras that have actual video files
                if (listContent.trim()) {
                    await fs.writeTextFile(listPath, listContent);
                    inputArgs.push('-f', 'concat', '-safe', '0', '-i', listPath);
                    validCameras.push(camera);
                } else {
                    console.warn(`[FFmpeg Grid] Camera ${camera} has no files in selected range, skipping`);
                }
            }
            
            // Update activeCameras to only include cameras with valid files
            if (validCameras.length === 0) {
                throw new Error('Ê≤íÊúâÂèØÂåØÂá∫ÁöÑÂΩ±ÁâáÊ™îÊ°à');
            }
            if (validCameras.length !== activeCameras.length) {
                console.log(`[FFmpeg Grid] Reduced cameras from ${activeCameras.length} to ${validCameras.length}`);
            }
            // Replace activeCameras with validCameras for the rest of processing
            const originalActiveCameras = activeCameras;
            activeCameras.length = 0;
            activeCameras.push(...validCameras);
            
            // Generate ASS subtitle for metadata if enabled
            let allMetadata = null;
            let overlayInfo = null;
            
            // Calculate grid dimensions
            const count = activeCameras.length;
            let gridWidth, gridHeight;
            if (count <= 2) {
                gridWidth = 1920;
                gridHeight = 540;
            } else if (count <= 4) {
                gridWidth = 1920;
                gridHeight = 1080;
            } else {
                gridWidth = 2880;
                gridHeight = 1080;
            }
            
            if (addMetadata && this.metadataManager) {
                progressCallback?.('ËºâÂÖ•‰∏≠ÁπºË≥áÊñô...');
                // Use first camera for metadata (front camera preferred)
                const metadataCamera = activeCameras.includes('front') ? 'front' : activeCameras[0];
                allMetadata = await this.loadMetadataForSegments(clipSegments, metadataCamera, progressCallback);
                
                if (allMetadata && allMetadata.length > 0) {
                    progressCallback?.(this.currentLanguage === 'zh-TW' ? `ÁîüÊàê‰∏≠ÁπºË≥áÊñôË¶ÜËìãÂ±§...` : `Generating metadata overlays...`);
                    try {
                        overlayInfo = await metadataOverlayGenerator.generateOverlayPngs(
                            allMetadata,
                            clipSegments,
                            workDir,
                            gridWidth,
                            gridHeight,
                            progressCallback,
                            this.currentLanguage
                        );
                        if (overlayInfo) {
                            tempFiles.push(overlayInfo.pngDir);
                            console.log('[FFmpeg Grid] PNG overlays generated:', overlayInfo.pngDir);
                        }
                    } catch (pngError) {
                        console.error('[FFmpeg Grid] PNG overlay generation failed:', pngError);
                        overlayInfo = null;
                    }
                }
            }
            
            // Calculate total duration EARLY - needed for trim filter to prevent FFmpeg hanging
            const totalDuration = clipSegments.reduce((sum, seg) => {
                const dur = (seg.clipEnd || 60) - (seg.clipStart || 0);
                return sum + (dur > 0 ? dur : 0);
            }, 0);
            
            console.log('[FFmpeg Grid] Total duration calculated:', totalDuration, 'seconds');
            
            // Build filter for grid layout
            let filterComplex = '';
            
            // Camera names for localization
            const lang = this.currentLanguage || 'zh-TW';
            const cameraNames = {
                front: { en: 'Front', zh: 'ÂâçËßÜ' },
                left_pillar: { en: 'Left Pillar', zh: 'Â∑¶Êü±' },
                right_pillar: { en: 'Right Pillar', zh: 'Âè≥Êü±' },
                back: { en: 'Back', zh: 'ÂêéËßÜ' },
                left: { en: 'Left', zh: 'Â∑¶‰æß' },
                right: { en: 'Right', zh: 'Âè≥‰æß' }
            };

            // Gap between grid cells (pixels)
            const gap = 6;

            // Resolve bundled font path once for all labels
            const gridResourceDir = await tauri.path.resourceDir();
            const gridFontSep = gridResourceDir.includes('\\') ? '\\' : '/';
            const gridFontPath = `${gridResourceDir}assets${gridFontSep}fonts${gridFontSep}dejavu-sans-bold.ttf`.replace(/\\/g, '/').replace(/'/g, "'\\''");
            const gridFontOption = `fontfile='${gridFontPath}':`;

            // Scale each input and add label, with padding for grid gap
            for (let i = 0; i < count; i++) {
                const camName = activeCameras[i];
                const labelText = cameraNames[camName]?.[lang] || camName.toUpperCase();

                const drawLabel = `drawtext=${gridFontOption}text='${labelText}':x=10:y=10:fontsize=18:fontcolor=white:box=1:boxcolor=black@0.5`;
                // Scale to slightly smaller size, then pad with black for gap effect
                // Each cell gets gap/2 padding on right and bottom; after stacking, adjacent cells share gap
                const cellW = count <= 4 ? 960 - gap / 2 : 960 - gap / 2;
                const cellH = 540 - gap / 2;
                const padW = count <= 4 ? 960 : 960;
                const padH = 540;
                const _cSat = colorAdjust.saturation ?? 100;
                const _cCon = colorAdjust.contrast ?? 100;
                const _cBri = colorAdjust.brightness ?? 100;
                const eqFilter = (_cSat !== 100 || _cCon !== 100 || _cBri !== 100)
                    ? `,eq=saturation=${(_cSat / 100).toFixed(2)}:contrast=${(_cCon / 100).toFixed(2)}:brightness=${((_cBri - 100) / 100).toFixed(2)}`
                    : '';
                filterComplex += `[${i}:v]trim=duration=${totalDuration},setpts=PTS-STARTPTS,scale=${cellW}:${cellH},setsar=1,fps=24,format=yuva420p${eqFilter},${drawLabel},pad=${padW}:${padH}:0:0:black@0[v${i}];`;
            }

            // Stack layout - no shortest=1 needed since trim filter ensures equal duration
            // After stacking, crop to remove excess padding on outer edges
            let stackFilter = '';
            if (count === 1) {
                stackFilter = `[v0]null[grid]`;
            } else if (count === 2) {
                stackFilter = `[v0][v1]hstack=inputs=2,crop=${gridWidth}:${gridHeight}:0:0[grid]`;
            } else if (count === 3) {
                // Generate a "No Signal" blue placeholder as the 4th cell
                const noSigW = 960 - gap / 2;
                const noSigH = 540 - gap / 2;
                const noSigPadW = 960;
                const noSigPadH = 540;
                const noSigLabel = `drawtext=${gridFontOption}text='No Signal':fontcolor=white:fontsize=36:x=(w-tw)/2:y=(h-th)/2`;
                filterComplex += `color=c=0x3B6EA5:s=${noSigW}x${noSigH}:d=${totalDuration},fps=24,format=yuva420p,${noSigLabel},pad=${noSigPadW}:${noSigPadH}:0:0:black@0[v_nosig];`;
                stackFilter = `[v0][v1]hstack=inputs=2[top];[v2][v_nosig]hstack=inputs=2[bottom];[top][bottom]vstack=inputs=2,crop=${gridWidth}:${gridHeight}:0:0[grid]`;
            } else if (count === 4) {
                stackFilter = `[v0][v1]hstack=inputs=2[top];[v2][v3]hstack=inputs=2[bottom];[top][bottom]vstack=inputs=2,crop=${gridWidth}:${gridHeight}:0:0[grid]`;
            } else if (count >= 5) {
                // 3x2 grid
                stackFilter = `[v0][v1][v2]hstack=inputs=3[top];`;
                if (count === 5) {
                    stackFilter += `[v3][v4]hstack=inputs=2,pad=2880:540:480:0[bottom];[top][bottom]vstack=inputs=2,crop=${gridWidth}:${gridHeight}:0:0[grid]`;
                } else {
                    stackFilter += `[v3][v4][v5]hstack=inputs=3[bottom];[top][bottom]vstack=inputs=2,crop=${gridWidth}:${gridHeight}:0:0[grid]`;
                }
            } else {
                stackFilter = `[v0]null[grid]`;
            }
            
            filterComplex += stackFilter;

            // Overlay grid (with transparent gaps) on background image
            const bgSep = gridResourceDir.includes('\\') ? '\\' : '/';
            const bgImgPath = `${gridResourceDir}imgs${bgSep}space-bg.jpg`.replace(/\\/g, '/');
            inputArgs.push('-loop', '1', '-i', bgImgPath);
            const bgInputIdx = inputArgs.filter(a => a === '-i').length - 1;
            filterComplex += `;[${bgInputIdx}:v]scale=${gridWidth}:${gridHeight},setsar=1,trim=duration=${totalDuration},fps=24,format=yuv420p[bg];[bg][grid]overlay=0:0:format=auto,format=yuv420p[grid_bg]`;

            // Track current output label
            let currentOutput = 'grid_bg';
            
            // Add timestamp if needed
            if (addTimestamp) {
                // Extract full timestamp (with seconds) from filename
                const firstFileRef = clipSegments.find(seg => seg.segment.files[activeCameras[0]])?.segment.files[activeCameras[0]];
                const fileName = firstFileRef.name || firstFileRef.path.split(/[/\\]/).pop();
                const fullTimestampMatch = fileName.match(/(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})/);
                
                let firstSegTime;
                if (fullTimestampMatch) {
                    firstSegTime = this.parseTimestamp(fullTimestampMatch[1]);
                } else {
                    firstSegTime = this.parseTimestamp(clipSegments[0].timestamp);
                }
                
                const clipStartTimeObj = new Date(firstSegTime.getTime() + clipSegments[0].clipStart * 1000);
                const startEpoch = Math.floor(clipStartTimeObj.getTime() / 1000);
                
                // Use bundled DejaVu font
                const resourceDir2 = await tauri.path.resourceDir();
                const fontSep2 = resourceDir2.includes('\\') ? '\\' : '/';
                const fontPath2 = `${resourceDir2}assets${fontSep2}fonts${fontSep2}dejavu-sans-bold.ttf`.replace(/\\/g, '/').replace(/'/g, "'\\''");
                const fontOption = `fontfile='${fontPath2}':`;

                const drawtext = `drawtext=${fontOption}text='%{pts\\:localtime\\:${startEpoch}}':x=20:y=h-th-20:fontsize=32:fontcolor=white:borderw=3:bordercolor=black@0.8`;
                filterComplex += (filterComplex ? ';' : '') + `[${currentOutput}]${drawtext}[ts]`;
                currentOutput = 'ts';
            }
            
            // Track next input index (cameras are 0..N-1)
            let nextGridInputIdx = activeCameras.length;

            // Add PNG overlay filters for metadata
            if (overlayInfo && overlayInfo.pngPaths && overlayInfo.pngPaths.size > 0) {
                const overlayResult = await metadataOverlayGenerator.generateOverlayFilter(
                    allMetadata,
                    clipSegments,
                    overlayInfo.pngPaths,
                    workDir,
                    activeCameras.length // Multiple video inputs
                );

                if (overlayResult.concatFile) {
                    // Add background and concat stream to inputs
                    const bgPath = overlayInfo.pngPaths.get('__background__');
                    // Use -loop 1 for background image
                    inputArgs.push('-loop', '1', '-i', bgPath);
                    const bgIdx = nextGridInputIdx++;

                    inputArgs.push('-f', 'concat', '-safe', '0', '-i', overlayResult.concatFile);
                    const metaIdx = nextGridInputIdx++;

                    tempFiles.push(overlayResult.concatFile);

                    // Scale down metadata overlay for grid view to match single camera proportions
                    const referenceWidth = 2896;
                    const scaleFactor = 1920 / referenceWidth;
                    const scaledBgWidth = Math.round(480 * scaleFactor);
                    const scaledBgHeight = Math.round(65 * scaleFactor);

                    // Overlay background then metadata stream with scaling
                    const xExpr = '(W-w)/2';
                    const yExpr = '(H*0.97-h/2)';
                    const currentLabelStr = `[${currentOutput}]`;

                    // Ensure all streams start at PTS 0 and are synchronized
                    const videoStream = `${currentLabelStr}setpts=PTS-STARTPTS[v_sync]`;
                    const bgScale = `[${bgIdx}:v]trim=duration=${totalDuration},setpts=PTS-STARTPTS,scale=${scaledBgWidth}:${scaledBgHeight}[bg_scaled]`;
                    const metaScale = `[${metaIdx}:v]setpts=PTS-STARTPTS,scale=${scaledBgWidth}:${scaledBgHeight}[meta_scaled]`;

                    const ovPart = `${videoStream};${bgScale};${metaScale};[v_sync][bg_scaled]overlay=x=${xExpr}:y=${yExpr}:eof_action=pass[bg_v];[bg_v][meta_scaled]overlay=x=${xExpr}:y=${yExpr}:eof_action=pass[ov]`;

                    filterComplex += (filterComplex ? ';' : '') + ovPart;
                    currentOutput = 'ov';
                }
            }

            // Add Logo watermark overlay
            if (addLogo) {
                try {
                    const resourceDir = await tauri.path.resourceDir();
                    const sep = resourceDir.includes('\\') ? '\\' : '/';
                    const logoPath = `${resourceDir}imgs${sep}TeslaCAM_256.png`;
                    inputArgs.push('-i', logoPath);
                    const logoIdx = nextGridInputIdx++;
                    const logoPart = `[${logoIdx}:v]format=rgba,colorchannelmixer=aa=0.85[logo_alpha];[${currentOutput}][logo_alpha]overlay=x=W-w-16:y=16:eof_action=pass[logo_out]`;
                    filterComplex += (filterComplex ? ';' : '') + logoPart;
                    currentOutput = 'logo_out';
                } catch (logoErr) {
                    console.warn('[FFmpeg Grid] Logo overlay failed:', logoErr);
                }
            }

            // Add background audio input
            let gridAudioInputIdx = -1;
            if (addAudio) {
                try {
                    const audioFiles = [
                        'M_Fischer.mp3', 'Take_Me_Down_To_The_Fashion_Show.mp3', 'Dopamina.mp3',
                        'Do_The_Bop.mp3', 'La_Fiesta_Y_La_Cruda.mp3', 'Los_Cabos.mp3',
                        'Chicago.mp3', 'Sugar_High.mp3', 'The_Monuments_and_Tunnels_in_Goa_and_Hampi.mp3'
                    ];
                    const selectedAudio = audioFiles[Math.floor(Math.random() * audioFiles.length)];
                    const resourceDir = await tauri.path.resourceDir();
                    const sep = resourceDir.includes('\\') ? '\\' : '/';
                    const audioPath = `${resourceDir}audios${sep}${selectedAudio}`;
                    inputArgs.push('-i', audioPath);
                    gridAudioInputIdx = nextGridInputIdx++;
                    console.log(`[FFmpeg Grid] Background audio: ${selectedAudio} (input ${gridAudioInputIdx})`);
                } catch (audioErr) {
                    console.warn('[FFmpeg Grid] Background audio failed:', audioErr);
                    gridAudioInputIdx = -1;
                }
            }

            const finalOutput = `[${currentOutput}]`;

            // Use filter_complex_script to avoid command line length limits on Windows
            const filterScriptPath = `${workDir}${pathSeparator}ffmpeg_filter_grid_${timestamp}.txt`;
            await fs.writeTextFile(filterScriptPath, filterComplex);
            tempFiles.push(filterScriptPath);

            const args = [
                ...inputArgs,
                '-filter_complex_script', filterScriptPath,
                '-map', finalOutput,
                ...(gridAudioInputIdx >= 0 ? ['-map', `${gridAudioInputIdx}:a`] : ['-map', '0:a?']),
                '-c:v', 'libx264',
                '-preset', 'veryfast',
                '-crf', '23',
                '-c:a', 'aac',
                ...(gridAudioInputIdx >= 0 ? ['-shortest'] : []),
                '-r', '24',
                '-t', String(Math.ceil(totalDuration + 1)),
                '-y',
                outputPath
            ];
            
            console.log('[FFmpeg Grid] Filter script content (first 500):', filterComplex.substring(0, 500));
            console.log('[FFmpeg Grid] Filter script content (last 500):', filterComplex.substring(filterComplex.length - 500));
            console.log('[FFmpeg Grid] Running with', activeCameras.length, 'cameras, duration:', totalDuration);
            console.log('[FFmpeg Grid] Args:', args.join(' '));
            progressCallback?.(this.currentLanguage === 'zh-TW' ? 'FFmpeg ÂêàÊàêÂõõÂÆÆÊ†º...' : 'FFmpeg Merging Grid...');
            
            const output = await this.executeFFmpegWithProgress(args, totalDuration, progressCallback, this.currentLanguage === 'zh-TW' ? 'ÂêàÊàêÂõõÂÆÆÊ†º...' : 'Merging Grid...');
            progressCallback?.(this.currentLanguage === 'zh-TW' ? 'ÂêàÊàêÂõõÂÆÆÊ†º: 100%' : 'Merging Grid: 100%');
            
            console.log('[FFmpeg Grid] Finished processing grid');
            
            if (output.code !== 0) {
                throw new Error(`FFmpeg ÈåØË™§ (code ${output.code}): ${output.stderr || output.stdout || 'Êú™Áü•ÈåØË™§'}`);
            }
            
            // Cleanup temp files
            for (const f of tempFiles) {
                try { 
                    if (f.includes('overlay_pngs_')) {
                        await this.removeDirectory(f, fs);
                    } else {
                        await fs.remove(f); 
                    }
                } catch(_) {}
            }
            
            return { camera: 'grid', path: outputPath, isFile: true };
            
        } catch (e) {
            for (const f of tempFiles) {
                try { 
                    if (f.includes('overlay_pngs_')) {
                        await this.removeDirectory(f, fs);
                    } else {
                        await fs.remove(f); 
                    }
                } catch(_) {}
            }
            try { await fs.remove(outputPath); } catch(_) {}
            throw e;
        }
    }
    
    getSegmentsForTimeRange(allSegments, startTime, endTime) {
        const result = [];
        let accumulatedTime = 0;
        
        for (let i = 0; i < allSegments.length; i++) {
            const segment = allSegments[i];
            const segmentDuration = segment.duration || 60; // Default 60s
            const segmentStart = accumulatedTime;
            const segmentEnd = accumulatedTime + segmentDuration;
            
            // Check if this segment overlaps with our clip range
            if (segmentEnd > startTime && segmentStart < endTime) {
                const clipStart = Math.max(0, startTime - segmentStart);
                const clipEnd = Math.min(segmentDuration, endTime - segmentStart);
                
                result.push({
                    segment,
                    segmentIndex: i,
                    clipStart,
                    clipEnd,
                    clipDuration: clipEnd - clipStart,
                    timestamp: segment.timestamp,
                    absoluteStart: segmentStart
                });
            }
            
            accumulatedTime += segmentDuration;
            
            if (accumulatedTime >= endTime) break;
        }
        
        return result;
    }
    
    async processVideoWithTimestamp(clipSegments, camera, totalStartTime, totalEndTime, addTimestamp, addMetadata, eventStartTime, progressCallback, fileHandle = null, addLogo = false, addAudio = false, colorAdjust = {}) {
        if (clipSegments.length === 0) {
            throw new Error('Ê≤íÊúâÂèØÁî®ÁöÑÂΩ±ÁâáÁâáÊÆµ');
        }
        
        progressCallback?.(this.currentLanguage === 'zh-TW' ? `ËôïÁêÜ ${camera} ÊîùÂΩ±Ê©ü (${clipSegments.length} ÂÄãÁâáÊÆµ)...` : `Processing ${camera} camera (${clipSegments.length} segments)...`);
        
        // Load metadata for all segments if addMetadata is enabled
        let allMetadata = [];
        if (addMetadata && this.metadataManager) {
            progressCallback?.(this.currentLanguage === 'zh-TW' ? 'ËºâÂÖ•Ë°åËªäÊï∏Êìö...' : 'Loading driving data...');
            allMetadata = await this.loadMetadataForSegments(clipSegments, camera, progressCallback);
            // Load SVG icons for metadata overlay
            await this.loadMetadataIcons();
        }
        
        // Check if we're in Tauri environment
        const isTauri = !!window.__TAURI__;
        
        // First pass: get video dimensions from first segment (load and release immediately)
        let canvasWidth = 0;
        let canvasHeight = 0;
        const firstVideoFile = clipSegments[0].segment.files[camera];
        if (firstVideoFile) {
            const tempVideo = document.createElement('video');
            tempVideo.muted = true;
            tempVideo.crossOrigin = 'anonymous';
            tempVideo.src = getFileUrl(firstVideoFile);
            await new Promise((resolve, reject) => {
                tempVideo.onloadedmetadata = resolve;
                tempVideo.onerror = reject;
            });
            canvasWidth = tempVideo.videoWidth;
            canvasHeight = tempVideo.videoHeight;
            // Release immediately
            URL.revokeObjectURL(tempVideo.src);
            tempVideo.src = '';
            tempVideo.load();
        }
        
        // Initialize canvas
        this.initCanvas(canvasWidth, canvasHeight);

        // Load custom font for timestamp
        if (addTimestamp) {
            await this.loadTimestampFont();
        }

        // Load logo image if needed
        let logoImg = null;
        if (addLogo) {
            progressCallback?.(this.currentLanguage === 'zh-TW' ? 'ËºâÂÖ• Logo...' : 'Loading logo...');
            logoImg = await this.loadLogoImage();
        }

        // Load background image
        const bgImg = await this.loadExportBgImage();

        // Load background audio if needed
        let bgAudio = null;
        if (addAudio) {
            progressCallback?.(this.currentLanguage === 'zh-TW' ? 'ËºâÂÖ•ËÉåÊôØÈü≥Ê®Ç...' : 'Loading background audio...');
            bgAudio = await this.loadBackgroundAudio();
        }

        // Calculate total duration
        const FPS = 30;
        let totalDuration = 0;
        for (const clipSegment of clipSegments) {
            totalDuration += clipSegment.clipDuration;
        }
        const totalFrames = Math.ceil(totalDuration * FPS);

        // Setup MediaRecorder with fixed framerate
        // If background audio is enabled, mix audio into the canvas stream
        const canvasStream = this.canvas.captureStream(FPS);
        let stream = canvasStream;
        if (bgAudio) {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioCtx.createMediaElementSource(bgAudio);
                const dest = audioCtx.createMediaStreamDestination();
                source.connect(dest);
                // Do NOT connect to destination ‚Äî avoid playback during export
                // Combine canvas video track + audio track
                const combinedStream = new MediaStream([
                    ...canvasStream.getVideoTracks(),
                    ...dest.stream.getAudioTracks()
                ]);
                stream = combinedStream;
                bgAudio.loop = true;
                bgAudio.volume = 0.5;
                bgAudio.play().catch(() => {});
                this._bgAudioCleanup = () => {
                    bgAudio.pause();
                    bgAudio.currentTime = 0;
                    source.disconnect();
                    audioCtx.close().catch(() => {});
                };
            } catch (audioErr) {
                console.warn('[Canvas] Audio mixing failed:', audioErr);
                stream = canvasStream;
            }
        }

        // Try VP9 first, fallback to VP8 if not supported
        let mimeType = 'video/webm;codecs=vp9';
        if (!MediaRecorder.isTypeSupported(mimeType)) {
            mimeType = 'video/webm;codecs=vp8';
        }
        
        this.mediaRecorder = new MediaRecorder(stream, {
            mimeType,
            videoBitsPerSecond: 3000000 // Reduced to 3 Mbps for lower memory footprint
        });
        
        // Use streaming approach - write chunks to array and periodically clear
        const chunks = [];
        let totalChunkSize = 0;
        let writable = null;
        
        // Write queue system to avoid Promise chain memory leaks
        const writeQueue = [];
        let writeQueueSize = 0;
        let isWriting = false;
        
        const processWriteQueue = async () => {
            if (isWriting) return;
            isWriting = true;
            
            while (writeQueue.length > 0) {
                const blob = writeQueue.shift();
                if (!blob) {
                    continue;
                }
                writeQueueSize -= blob.size || 0;
                try {
                    await writable.write(blob);
                } catch (err) {
                    console.error('Write error:', err);
                }
            }
            
            isWriting = false;
        };
        
        if (fileHandle) {
             try {
                 writable = await fileHandle.createWritable();
             } catch(e) {
                 console.warn("Writable creation failed", e);
             }
        }
        
        this.mediaRecorder.ondataavailable = (e) => {
            const size = e?.data ? e.data.size : 0;
            if (size > 0) {
                if (writable) {
                    writeQueue.push(e.data);
                    writeQueueSize += size;
                    if (writeQueueSize > 50 * 1024 * 1024) {
                        this.logMemory('writeQueue > 50MB', {
                            writeQueueSize: this.formatBytes(writeQueueSize),
                            totalChunkSize: this.formatBytes(totalChunkSize),
                            chunksBuffered: chunks.length,
                        });
                    }
                    processWriteQueue();
                } else {
                    chunks.push(e.data);
                }
                totalChunkSize += size;
            }
        };

        
        const recordingComplete = new Promise((resolve) => {
            this.mediaRecorder.onstop = async () => {
                console.log('MediaRecorder stopped, chunks count:', chunks.length, 'total size:', totalChunkSize);
                if (writable) {
                     await writable.close();
                     // Return result indicating saved
                     resolve({ saved: true, blob: new Blob([], { type: 'video/webm' }) });
                } else {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    console.log('Created blob, size:', blob.size);
                    // Clear chunks array to free memory
                    chunks.length = 0;
                    resolve(blob);
                }
            };
        });
        
        // Start recording - smaller timeslice helps reduce internal buffering
        this.mediaRecorder.start(250);
        const recordingStartTime = performance.now();
        
        // Process segments one at a time (streaming approach to reduce memory)
        let processedFrames = 0;
        const hasVideoFrameCallback = 'requestVideoFrameCallback' in HTMLVideoElement.prototype;
        const _tsSat = colorAdjust.saturation ?? 100;
        const _tsCon = colorAdjust.contrast ?? 100;
        const _tsBri = colorAdjust.brightness ?? 100;
        const _tsColorFilter = `saturate(${_tsSat}%) contrast(${_tsCon}%) brightness(${_tsBri}%)`;
        
        for (let i = 0; i < clipSegments.length; i++) {
            const clipSegment = clipSegments[i];
            const videoFile = clipSegment.segment.files[camera];
            
            if (!videoFile) {
                throw new Error(`${camera} ÊîùÂΩ±Ê©üÂú®ÁâáÊÆµ ${i + 1} ‰∏≠Ê≤íÊúâÂèØÁî®ÁöÑÂΩ±ÁâáÊ™îÊ°à`);
            }
            
            progressCallback?.(`ËºâÂÖ•ÁâáÊÆµ ${i + 1}/${clipSegments.length}...`);
            
            // Load video for this segment only
            const video = document.createElement('video');
            video.muted = true;
            video.crossOrigin = 'anonymous';
            
            // In Tauri, we need to read the file as blob to avoid CORS issues with canvas
            if (isTauri && videoFile.path) {
                try {
                    const fs = window.__TAURI__.fs;
                    const fileData = await fs.readFile(videoFile.path);
                    const blob = new Blob([fileData], { type: 'video/mp4' });
                    video.src = URL.createObjectURL(blob);
                } catch (e) {
                    console.error('Failed to read file via Tauri fs:', e);
                    video.src = getFileUrl(videoFile);
                }
            } else {
                video.src = getFileUrl(videoFile);
            }
            
            await new Promise((resolve, reject) => {
                video.onloadedmetadata = resolve;
                video.onerror = reject;
            });
            
            // Calculate timestamp for this segment - extract full timestamp from filename
            const fileName = videoFile?.name || (videoFile?.path ? videoFile.path.split(/[/\\]/).pop() : null);
            const fullTimestampMatch = fileName?.match(/(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})/);
            
            let segmentTime;
            if (fullTimestampMatch) {
                segmentTime = this.parseTimestamp(fullTimestampMatch[1]);
            } else {
                segmentTime = this.parseTimestamp(clipSegment.timestamp);
            }
            
            const segmentEndTime = clipSegment.clipEnd;
            
            // Adjust clipStart if it exceeds video duration
            const actualClipStart = Math.min(clipSegment.clipStart, video.duration);
            // Adjust clipEnd based on actual video duration
            const actualEndTime = Math.min(segmentEndTime, video.duration);
            
            // Calculate timestamp based on actual clip start
            const segmentStartTimestamp = new Date(segmentTime.getTime() + actualClipStart * 1000);
            
            // Skip this segment if clipStart is already past video duration
            if (actualClipStart >= video.duration) {
                console.warn(`Segment ${i + 1}: clipStart (${clipSegment.clipStart}) exceeds video duration (${video.duration}), skipping`);
                // Release video resources
                URL.revokeObjectURL(video.src);
                video.src = '';
                video.load();
                continue;
            }
            
            console.log(`Processing single camera segment ${i + 1}/${clipSegments.length}:`, {
                clipStart: clipSegment.clipStart,
                actualClipStart,
                clipEnd: clipSegment.clipEnd,
                segmentEndTime,
                actualEndTime,
                videoDuration: video.duration,
                actualDuration: actualEndTime - actualClipStart
            });
            
            // Seek to clip start position
            video.currentTime = actualClipStart;
            await new Promise((resolve) => {
                video.onseeked = resolve;
            });
            
            if (hasVideoFrameCallback) {
                // Use requestVideoFrameCallback for precise frame capture
                await new Promise((resolve) => {
                    let lastFrameTime = -1;
                    let resolved = false;
                    
                    const captureFrame = (now, metadata) => {
                        if (resolved) return;
                        
                        if (video.currentTime >= actualEndTime + 0.05 || video.ended) {
                            resolved = true;
                            video.pause();
                            resolve();
                            return;
                        }
                        
                        if (metadata.mediaTime !== lastFrameTime) {
                            lastFrameTime = metadata.mediaTime;

                            if (bgImg) {
                                this.ctx.drawImage(bgImg, 0, 0, this.canvas.width, this.canvas.height);
                            }
                            this.ctx.filter = _tsColorFilter;
                            this.ctx.drawImage(video, 0, 0, this.canvas.width, this.canvas.height);
                            this.ctx.filter = 'none';

                            if (addTimestamp) {
                                const currentTime = new Date(segmentStartTimestamp.getTime() + (video.currentTime - actualClipStart) * 1000);
                                const timeString = currentTime.toLocaleString('zh-CN', {
                                    year: 'numeric',
                                    month: '2-digit',
                                    day: '2-digit',
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    second: '2-digit',
                                    hour12: false
                                }).replace(/\//g, '-');
                                
                                this.drawTimestamp(timeString);
                            }
                            
                            // Draw metadata overlay if enabled
                            if (addMetadata && allMetadata.length > 0) {
                                const metadataData = this.getMetadataAtTime(allMetadata, i, video.currentTime);
                                this.drawMetadata(metadataData, this.currentLanguage);
                            }

                            // Draw logo watermark if enabled
                            if (logoImg) {
                                this.drawLogo(logoImg);
                            }

                            processedFrames++;

                            if (processedFrames % 30 === 0) {
                                const progress = Math.min(100, Math.round((processedFrames / totalFrames) * 100));
                                progressCallback?.(`ËôïÁêÜ ${camera}: ${progress}%`);
                            }
                        }
                        
                        if (!resolved) {
                            video.requestVideoFrameCallback(captureFrame);
                        }
                    };
                    
                    video.onended = () => {
                        if (!resolved) {
                            resolved = true;
                            video.pause();
                            resolve();
                        }
                    };
                    
                    video.requestVideoFrameCallback(captureFrame);
                    video.play();
                });
            } else {
                // Fallback: play and sample at FPS (avoid per-frame seeking which can explode memory)
                const frameInterval = 1000 / FPS;
                
                await new Promise((resolve) => {
                    let resolved = false;
                    
                    const stop = () => {
                        if (resolved) return;
                        resolved = true;
                        video.pause();
                        resolve();
                    };
                    
                    const tick = () => {
                        if (resolved) return;
                        
                        const t = video.currentTime;
                        if (t >= actualEndTime - 0.02 || video.ended) {
                            stop();
                            return;
                        }
                        
                        if (bgImg) {
                            this.ctx.drawImage(bgImg, 0, 0, this.canvas.width, this.canvas.height);
                        }
                        this.ctx.filter = _tsColorFilter;
                        this.ctx.drawImage(video, 0, 0, this.canvas.width, this.canvas.height);
                        this.ctx.filter = 'none';

                        if (addTimestamp) {
                            const currentTime = new Date(segmentStartTimestamp.getTime() + (t - actualClipStart) * 1000);
                            const timeString = currentTime.toLocaleString('zh-CN', {
                                year: 'numeric',
                                month: '2-digit',
                                day: '2-digit',
                                hour: '2-digit',
                                minute: '2-digit',
                                second: '2-digit',
                                hour12: false
                            }).replace(/\//g, '-');
                            
                            this.drawTimestamp(timeString);
                        }
                        
                        // Draw metadata overlay if enabled
                        if (addMetadata && allMetadata.length > 0) {
                            const metadataData = this.getMetadataAtTime(allMetadata, i, t);
                            this.drawMetadata(metadataData, this.currentLanguage);
                        }

                        // Draw logo watermark if enabled
                        if (logoImg) {
                            this.drawLogo(logoImg);
                        }

                        processedFrames++;

                        if (processedFrames % 30 === 0) {
                            const progress = Math.min(100, Math.round((processedFrames / totalFrames) * 100));
                            progressCallback?.(`ËôïÁêÜ ${camera}: ${progress}%`);
                        }
                        
                        setTimeout(tick, frameInterval);
                    };
                    
                    video.play().then(() => tick()).catch(() => tick());
                });
            }
            
            // Release video resources immediately after processing this segment
            video.pause();
            URL.revokeObjectURL(video.src);
            video.src = '';
            video.load();
            
            // Allow GC
            if (i % 5 === 0) {
                 await new Promise(r => setTimeout(r, 100));
            }

            console.log(`Segment ${i + 1} completed, memory released`);
            this.logMemory(`segment done ${i + 1}/${clipSegments.length}`, {
                writeQueueSize: this.formatBytes(writeQueueSize),
                totalChunkSize: this.formatBytes(totalChunkSize),
                chunksBuffered: chunks.length,
                writeQueueItems: writeQueue.length,
            });
        }

        
        // Ensure all writes are finished before stopping
        if (writable) {
            while (isWriting || writeQueue.length > 0) {
                await new Promise(r => setTimeout(r, 100));
            }
        }
        
        // Stop recording
        await new Promise(resolve => setTimeout(resolve, 500));
        this.mediaRecorder.stop();
        
        const result = await recordingComplete;
        
        const calculatedDuration = (processedFrames / FPS) * 1000;
        const recordingEndTime = performance.now();
        const realTimeDuration = recordingEndTime - recordingStartTime;
        console.log(`[Single Video Export] Recording completed. Expected: ${totalDuration * 1000}ms, Calculated: ${calculatedDuration}ms, RealTime: ${realTimeDuration}ms, Frames: ${processedFrames}`);
        
        // Clean up canvas, stream, and audio
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
        }
        if (this._bgAudioCleanup) {
            this._bgAudioCleanup();
            this._bgAudioCleanup = null;
        }

        if (result.saved) {
            // For streamed files, try to use FFmpeg to fix metadata
            // If FFmpeg fails, the video is still playable (just without accurate duration)
            if (fileHandle) {
                try {
                    const fixed = await this.fixWebmWithFFmpeg(fileHandle, progressCallback);
                    if (!fixed) {
                        console.warn('[Grid Video Export] FFmpeg metadata fix failed, video may have inaccurate duration');
                        progressCallback?.('ÂΩ±ÁâáÂ∑≤ÂÑ≤Â≠òÔºà‰∏≠ÁπºË≥áÊñô‰øÆÂæ©Ë∑≥ÈÅéÔºâ');
                    }
                } catch (e) {
                    console.warn('[Grid Video Export] FFmpeg metadata fix error:', e);
                    progressCallback?.('ÂΩ±ÁâáÂ∑≤ÂÑ≤Â≠òÔºà‰∏≠ÁπºË≥áÊñô‰øÆÂæ©Ë∑≥ÈÅéÔºâ');
                }
            }
            return result;
        }

        progressCallback?.('‰øÆÂæ©ÂΩ±Áâá‰∏≠ÁπºË≥áÊñô...');
        const fixedBlob = await webmDurationFixer.fixDuration(result, calculatedDuration);
        
        return fixedBlob;
    }
    
    async createGridVideoFromSegments(clipSegments, cameras, totalStartTime, totalEndTime, addTimestamp, addMetadata, eventStartTime, progressCallback, fileHandle = null, addLogo = false, addAudio = false, colorAdjust = {}) {
        progressCallback?.(this.currentLanguage === 'zh-TW' ? `Ê∫ñÂÇôÂõõÂÆÆÊ†ºÂΩ±Áâá (${clipSegments.length} ÂÄãÁâáÊÆµ)...` : `Preparing grid video (${clipSegments.length} segments)...`);
        
        // Load metadata for all segments if addMetadata is enabled
        let allMetadata = [];
        if (addMetadata && this.metadataManager) {
            progressCallback?.(this.currentLanguage === 'zh-TW' ? 'ËºâÂÖ•Ë°åËªäÊï∏Êìö...' : 'Loading driving data...');
            // Use front camera for metadata (it's the same for all cameras)
            allMetadata = await this.loadMetadataForSegments(clipSegments, cameras[0], progressCallback);
            // Load SVG icons for metadata overlay
            await this.loadMetadataIcons();
        }
        
        // Check if we're in Tauri environment
        const isTauri = !!window.__TAURI__;
        
        // First pass: get video dimensions from first segment (load and release immediately)
        let canvasWidth = 0;
        let canvasHeight = 0;
        const firstVideoFile = clipSegments[0].segment.files[cameras[0]];
        if (firstVideoFile) {
            const tempVideo = document.createElement('video');
            tempVideo.muted = true;
            tempVideo.crossOrigin = 'anonymous';
            tempVideo.src = getFileUrl(firstVideoFile);
            await new Promise((resolve, reject) => {
                tempVideo.onloadedmetadata = resolve;
                tempVideo.onerror = reject;
            });
            canvasWidth = tempVideo.videoWidth;
            canvasHeight = tempVideo.videoHeight;
            URL.revokeObjectURL(tempVideo.src);
            tempVideo.src = '';
            tempVideo.load();
        }
        
        const videoCount = cameras.length;
        
        // Calculate grid layout and sort order
        let gridCols, gridRows;
        let sortOrder;

        if (videoCount > 4) {
            gridCols = 3; 
            gridRows = 2;
            sortOrder = ['left_pillar', 'front', 'right_pillar', 'left', 'back', 'right'];
        } else {
            sortOrder = ['front', 'back', 'left', 'right', 'left_pillar', 'right_pillar'];
            if (videoCount === 1) {
                gridCols = 1; gridRows = 1;
            } else if (videoCount === 2) {
                gridCols = 2; gridRows = 1;
            } else {
                gridCols = 2; gridRows = 2;
            }
        }

        const sortedCameras = cameras.sort((a, b) => {
            const idxA = sortOrder.indexOf(a);
            const idxB = sortOrder.indexOf(b);
            return (idxA === -1 ? 99 : idxA) - (idxB === -1 ? 99 : idxB);
        });

        // Target output resolution: 1920x1080 (scales each cell to fit)
        const targetWidth = 1920;
        const targetHeight = 1080;
        const gap = 6; // gap between grid cells
        const cellWidth = Math.floor((targetWidth - (gridCols - 1) * gap) / gridCols);
        const cellHeight = Math.floor((targetHeight - (gridRows - 1) * gap) / gridRows);
        const gridCanvasWidth = targetWidth;
        const gridCanvasHeight = targetHeight;

        // Initialize canvas
        this.initCanvas(gridCanvasWidth, gridCanvasHeight);

        // Load custom font for timestamp
        if (addTimestamp) {
            await this.loadTimestampFont();
        }

        // Load logo image if needed
        let logoImg = null;
        if (addLogo) {
            progressCallback?.(this.currentLanguage === 'zh-TW' ? 'ËºâÂÖ• Logo...' : 'Loading logo...');
            logoImg = await this.loadLogoImage();
        }

        // Load background image for grid canvas
        const bgImg = await this.loadExportBgImage();

        // Load background audio if needed
        let bgAudio = null;
        if (addAudio) {
            progressCallback?.(this.currentLanguage === 'zh-TW' ? 'ËºâÂÖ•ËÉåÊôØÈü≥Ê®Ç...' : 'Loading background audio...');
            bgAudio = await this.loadBackgroundAudio();
        }

        // Calculate total duration
        const FPS = 30;
        let totalDuration = 0;
        for (const clipSegment of clipSegments) {
            totalDuration += clipSegment.clipDuration;
        }
        const totalFrames = Math.ceil(totalDuration * FPS);

        // Setup MediaRecorder - mix in audio if needed
        const canvasStream = this.canvas.captureStream(FPS);
        let stream = canvasStream;
        if (bgAudio) {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioCtx.createMediaElementSource(bgAudio);
                const dest = audioCtx.createMediaStreamDestination();
                source.connect(dest);
                // Do NOT connect to destination ‚Äî avoid playback during export
                stream = new MediaStream([
                    ...canvasStream.getVideoTracks(),
                    ...dest.stream.getAudioTracks()
                ]);
                bgAudio.loop = true;
                bgAudio.volume = 0.5;
                bgAudio.play().catch(() => {});
                this._bgAudioCleanup = () => {
                    bgAudio.pause();
                    bgAudio.currentTime = 0;
                    source.disconnect();
                    audioCtx.close().catch(() => {});
                };
            } catch (audioErr) {
                console.warn('[Canvas Grid] Audio mixing failed:', audioErr);
                stream = canvasStream;
            }
        }
        
        // Dynamic bitrate based on grid cell count
        // Optimize bitrate to reduce memory usage: ~2.5Mbps per camera is sufficient
        const gridCellCount = gridCols * gridRows;
        const videoBitsPerSecond = Math.min(2500000 * gridCellCount, 15000000);
        
        let mimeType = 'video/webm;codecs=vp9';
        if (!MediaRecorder.isTypeSupported(mimeType)) {
            mimeType = 'video/webm;codecs=vp8';
        }
        
        console.log(`Grid export: ${gridCols}x${gridRows}, ${gridCanvasWidth}x${gridCanvasHeight}, ${videoBitsPerSecond / 1000000} Mbps, codec: ${mimeType}, total frames: ${totalFrames}`);
        this.logMemory('grid init', {
            gridSize: `${gridCols}x${gridRows}`,
            canvasSize: `${gridCanvasWidth}x${gridCanvasHeight}`,
            bitrateMbps: (videoBitsPerSecond / 1000000).toFixed(2),
        });
        
        this.mediaRecorder = new MediaRecorder(stream, {
            mimeType,
            videoBitsPerSecond
        });

        
        const chunks = [];
        let totalChunkSize = 0;
        let writable = null;
        
        // Write queue system to avoid Promise chain memory leaks
        const writeQueue = [];
        let writeQueueSize = 0;
        let isWriting = false;
        
        const processWriteQueue = async () => {
            if (isWriting) return;
            isWriting = true;
            
            while (writeQueue.length > 0) {
                const blob = writeQueue.shift();
                if (!blob) {
                    continue;
                }
                writeQueueSize -= blob.size || 0;
                try {
                    await writable.write(blob);
                } catch (err) {
                    console.error('Write error:', err);
                }
            }
            
            isWriting = false;
        };


        if (fileHandle) {
             try {
                 writable = await fileHandle.createWritable();
             } catch(e) {
                 console.warn("Writable creation failed", e);
             }
        }
        
        this.mediaRecorder.ondataavailable = (e) => {
            const size = e?.data ? e.data.size : 0;
            if (size > 0) {
                if (writable) {
                    writeQueue.push(e.data);
                    writeQueueSize += size;
                    if (writeQueueSize > 50 * 1024 * 1024) {
                        this.logMemory('writeQueue > 50MB', {
                            writeQueueSize: this.formatBytes(writeQueueSize),
                            totalChunkSize: this.formatBytes(totalChunkSize),
                            chunksBuffered: chunks.length,
                        });
                    }
                    processWriteQueue();
                } else {
                    chunks.push(e.data);
                }
                totalChunkSize += size;
            }
        };

        
        const recordingComplete = new Promise((resolve) => {
            this.mediaRecorder.onstop = async () => {
                console.log('MediaRecorder stopped, chunks count:', chunks.length, 'total size:', totalChunkSize);
                if (writable) {
                     await writable.close();
                     resolve({ saved: true, blob: new Blob([], { type: 'video/webm' }) });
                } else {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    console.log('Created blob, size:', blob.size);
                    chunks.length = 0;
                    resolve(blob);
                }
            };
        });
        
        // Start recording - smaller timeslice helps reduce internal buffering
        this.mediaRecorder.start(250);
        const recordingStartTime = performance.now();
        
        // Position mapping for grid
        const cameraPositions = {};
        sortedCameras.forEach((cam, index) => {
            cameraPositions[cam] = {
                x: index % gridCols,
                y: Math.floor(index / gridCols)
            };
        });
        
        // Process segments one at a time (streaming approach)
        let processedFrames = 0;
        const hasVideoFrameCallback = 'requestVideoFrameCallback' in HTMLVideoElement.prototype;
        
        for (let i = 0; i < clipSegments.length; i++) {
            const clipSegment = clipSegments[i];
            
            progressCallback?.(`ËºâÂÖ•ÁâáÊÆµ ${i + 1}/${clipSegments.length}...`);
            
            // Load videos for this segment only
            const videos = {};
            for (const camera of cameras) {
                const videoFile = clipSegment.segment.files[camera];
                if (!videoFile) continue;
                
                const video = document.createElement('video');
                video.muted = true;
                video.crossOrigin = 'anonymous';
                
                if (isTauri && videoFile.path) {
                    try {
                        const fs = window.__TAURI__.fs;
                        const fileData = await fs.readFile(videoFile.path);
                        const blob = new Blob([fileData], { type: 'video/mp4' });
                        video.src = URL.createObjectURL(blob);
                    } catch (e) {
                        console.error('Failed to read file via Tauri fs:', e);
                        video.src = getFileUrl(videoFile);
                    }
                } else {
                    video.src = getFileUrl(videoFile);
                }
                
                await new Promise((resolve, reject) => {
                    video.onloadedmetadata = resolve;
                    video.onerror = reject;
                });
                
                videos[camera] = video;
            }
            
            if (Object.keys(videos).length === 0) {
                throw new Error(`ÁâáÊÆµ ${i + 1} Ê≤íÊúâÂèØÁî®ÁöÑÂΩ±ÁâáÊ™îÊ°à`);
            }

            const videoCountLoaded = Object.keys(videos).length;
            this.logMemory(`segment start ${i + 1}/${clipSegments.length}`, {
                videoCountLoaded,
                writeQueueSize: this.formatBytes(writeQueueSize),
                totalChunkSize: this.formatBytes(totalChunkSize),
                chunksBuffered: chunks.length,
                writeQueueItems: writeQueue.length,
            });
            
            // Calculate timestamp for this segment
            const firstCam = sortedCameras[0];

            const videoFile = clipSegment.segment.files[firstCam];
            const fileName = videoFile?.name || (videoFile?.path ? videoFile.path.split(/[/\\]/).pop() : null);
            const fullTimestampMatch = fileName?.match(/(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})/);
            
            let segmentTime;
            if (fullTimestampMatch) {
                segmentTime = this.parseTimestamp(fullTimestampMatch[1]);
            } else {
                segmentTime = this.parseTimestamp(clipSegment.timestamp);
            }
            
            const segmentEndTime = clipSegment.clipEnd;
            
            const videoEntries = Object.entries(videos);
            const firstVideo = videoEntries[0][1];
            
            // Adjust clipStart if it exceeds video duration
            const actualClipStart = Math.min(clipSegment.clipStart, firstVideo.duration);
            // Adjust clipEnd based on actual video duration
            const actualEndTime = Math.min(segmentEndTime, firstVideo.duration);
            
            // Calculate timestamp based on actual clip start
            const segmentStartTimestamp = new Date(segmentTime.getTime() + actualClipStart * 1000);
            
            // Skip this segment if clipStart is already past video duration
            if (actualClipStart >= firstVideo.duration) {
                console.warn(`Grid segment ${i + 1}: clipStart (${clipSegment.clipStart}) exceeds video duration (${firstVideo.duration}), skipping`);
                // Release video resources
                for (const video of Object.values(videos)) {
                    URL.revokeObjectURL(video.src);
                    video.src = '';
                    video.load();
                }
                continue;
            }
            
            console.log(`Processing segment ${i + 1}/${clipSegments.length}:`, {
                clipStart: clipSegment.clipStart,
                actualClipStart,
                clipEnd: clipSegment.clipEnd,
                clipDuration: clipSegment.clipDuration,
                segmentEndTime,
                actualEndTime,
                videoDuration: firstVideo.duration,
                actualDuration: actualEndTime - actualClipStart
            });
            
            // Seek all videos to clip start position with timeout
            const seekWithTimeout = (video, targetTime, timeout = 5000) => {
                return new Promise((resolve) => {
                    // If already at target position (within tolerance), resolve immediately
                    if (Math.abs(video.currentTime - targetTime) < 0.1) {
                        video.playbackRate = 1.0;
                        resolve();
                        return;
                    }
                    
                    const timeoutId = setTimeout(() => {
                        console.warn(`[Grid] Seek timeout for video, forcing continue`);
                        video.onseeked = null;
                        resolve();
                    }, timeout);
                    
                    video.onseeked = () => {
                        clearTimeout(timeoutId);
                        video.onseeked = null;
                        resolve();
                    };
                    
                    video.playbackRate = 1.0;
                    video.currentTime = targetTime;
                });
            };
            
            await Promise.all(Object.values(videos).map(video => 
                seekWithTimeout(video, actualClipStart)
            ));
            
            const segmentDuration = actualEndTime - actualClipStart;
            const segmentFrameCount = Math.ceil(segmentDuration * FPS);
            console.log(`Segment ${i + 1}: clipStart=${clipSegment.clipStart}, actualEndTime=${actualEndTime}, segmentDuration=${segmentDuration}s, expectedFrames=${segmentFrameCount}`);
            
        const _colorSat = colorAdjust.saturation ?? 100;
        const _colorCon = colorAdjust.contrast ?? 100;
        const _colorBri = colorAdjust.brightness ?? 100;
        const _colorFilter = `saturate(${_colorSat}%) contrast(${_colorCon}%) brightness(${_colorBri}%)`;

        const renderFrame = (videoTime) => {
            // Draw background
            if (bgImg) {
                this.ctx.drawImage(bgImg, 0, 0, gridCanvasWidth, gridCanvasHeight);
            } else {
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(0, 0, gridCanvasWidth, gridCanvasHeight);
            }
            
            // 2x2 ÁâπÊÆäÈÄªËæëÔºöÁ≠âÊØîÁº©Â∞è„ÄÅ‰∏çË£ÅÂâ™ÔºõÂêå‰∏ÄË°åÁöÑ‰∏§Âº†ÂõæÊ∞¥Âπ≥ÊãºÊàê‰∏ÄÁªÑÔºåÊï¥ÁªÑÂ±Ö‰∏≠Ôºå‰øùËØÅÂ∑¶Âè≥Ë¥¥ÂêàÊó†Â§ñÈÉ®Á©∫Èöô
            const is2x2 = gridCols === 2 && gridRows === 2;

            if (is2x2) {
                // Build layout items for all 4 grid positions (video + "No Signal" placeholders)
                const occupiedPositions = new Set();
                for (const [camera] of videoEntries) {
                    const pos = cameraPositions[camera];
                    if (pos) occupiedPositions.add(`${pos.x},${pos.y}`);
                }

                const layout = videoEntries.map(([camera, video]) => {
                    const pos = cameraPositions[camera] || { x: 0, y: 0 };
                    const x = pos.x * (cellWidth + gap);
                    const y = pos.y * (cellHeight + gap);
                    const srcW = video.videoWidth || cellWidth;
                    const srcH = video.videoHeight || cellHeight;
                    const scale = Math.min(cellWidth / srcW, cellHeight / srcH); // contain: ‰∏çË£ÅÂâ™
                    const drawW = Math.ceil(srcW * scale);
                    const drawH = Math.ceil(srcH * scale);
                    return { camera, video, x, y, row: pos.y, drawW, drawH, isNoSignal: false };
                });

                // Add "No Signal" virtual items for empty grid cells
                // Use the same drawW/drawH as actual video cells so the grid stays even
                const refItem = layout[0];
                const noSigW = refItem ? refItem.drawW : cellWidth;
                const noSigH = refItem ? refItem.drawH : cellHeight;
                for (let gy = 0; gy < 2; gy++) {
                    for (let gx = 0; gx < 2; gx++) {
                        if (!occupiedPositions.has(`${gx},${gy}`)) {
                            layout.push({
                                camera: null, video: null,
                                x: gx * (cellWidth + gap),
                                y: gy * (cellHeight + gap),
                                row: gy,
                                drawW: noSigW, drawH: noSigH,
                                isNoSignal: true
                            });
                        }
                    }
                }

                // ÊåâË°åÂ§ÑÁêÜÔºåÊØèË°å‰∏§Âº†ÔºöÊÄªÂÆΩÂ∫¶ <= 1920ÔºåÊï¥Ë°åÂ±Ö‰∏≠ÔºõÂ∑¶Âè≥Á¥ßË¥¥
                const rows = new Map();
                for (const item of layout) {
                    if (!rows.has(item.row)) rows.set(item.row, []);
                    rows.get(item.row).push(item);
                }

                for (const [, items] of rows) {
                    items.sort((a, b) => a.x - b.x); // Â∑¶Âè≥È°∫Â∫è
                    const totalW = items.reduce((sum, it) => sum + it.drawW, 0) + (items.length - 1) * gap;
                    const startX = Math.floor((gridCanvasWidth - totalW) / 2);
                    let cursorX = startX;
                    for (let idx = 0; idx < items.length; idx++) {
                        const item = items[idx];
                        if (idx > 0) cursorX += gap;
                        const offsetX = cursorX;
                        const offsetY = item.y + Math.floor((cellHeight - item.drawH) / 2);

                        if (item.isNoSignal) {
                            // Draw "No Signal" blue placeholder
                            this.ctx.fillStyle = '#3B6EA5';
                            this.ctx.fillRect(offsetX, offsetY, item.drawW, item.drawH);
                            this.ctx.fillStyle = '#ffffff';
                            this.ctx.font = 'bold 36px "Noto Sans SC", Arial';
                            const noSignalText = 'No Signal';
                            const tw = this.ctx.measureText(noSignalText).width;
                            this.ctx.fillText(noSignalText, offsetX + Math.floor((item.drawW - tw) / 2), offsetY + Math.floor(item.drawH / 2) + 12);
                        } else {
                            this.ctx.filter = _colorFilter;
                            this.ctx.drawImage(item.video, offsetX, offsetY, item.drawW, item.drawH);
                            this.ctx.filter = 'none';
                        }
                        cursorX += item.drawW;

                        if (!item.isNoSignal) {
                        // Draw camera label (auto width) ‚Äî position relative to video, not cell
                        const labelX = offsetX + 4;
                        const labelY = offsetY + 4;
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                        this.ctx.font = 'bold 12px "Noto Sans SC", Arial';
                        const lang = this.currentLanguage || 'zh-TW';
                        const cameraNames = {
                            front: { en: 'Front', zh: 'ÂâçËßÜ' },
                            left_pillar: { en: 'Left Pillar', zh: 'Â∑¶Êü±' },
                            right_pillar: { en: 'Right Pillar', zh: 'Âè≥Êü±' },
                            back: { en: 'Back', zh: 'ÂêéËßÜ' },
                            left: { en: 'Left', zh: 'Â∑¶‰æß' },
                            right: { en: 'Right', zh: 'Âè≥‰æß' }
                        };
                        const labelText = cameraNames[item.camera]?.[lang] || item.camera.toUpperCase();
                        const textW = this.ctx.measureText(labelText).width;
                        const padX = 6;
                        const padY = 4;
                        const boxW = Math.ceil(textW + padX * 2);
                        const boxH = 20 + padY * 0; // 20 È´òÂ∫¶Â§ü 12px Â≠ó‰Ωì
                        this.ctx.fillRect(labelX, labelY, boxW, boxH);
                        this.ctx.fillStyle = '#fff';
                        this.ctx.fillText(labelText, labelX + padX, labelY + 14);
                        }

                    }
                }
            } else {

            // Draw each camera view (contain: keep aspect, center inside cell)
            for (const [camera, video] of videoEntries) {
                const pos = cameraPositions[camera] || { x: 0, y: 0 };
                const x = pos.x * (cellWidth + gap);
                const y = pos.y * (cellHeight + gap);

                const srcW = video.videoWidth || cellWidth;
                const srcH = video.videoHeight || cellHeight;
                const scale = Math.min(cellWidth / srcW, cellHeight / srcH); // contain: ‰∏çË£ÅÂâ™
                const drawW = Math.ceil(srcW * scale);
                const drawH = Math.ceil(srcH * scale);

                const offsetX = x + Math.floor((cellWidth - drawW) / 2);
                const offsetY = y + Math.floor((cellHeight - drawH) / 2);

                this.ctx.filter = _colorFilter;
                this.ctx.drawImage(video, offsetX, offsetY, drawW, drawH);
                this.ctx.filter = 'none';


                // Draw camera label (auto width) ‚Äî position relative to video, not cell
                const labelX = offsetX + 4;
                const labelY = offsetY + 4;
                this.ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                this.ctx.font = 'bold 12px "Noto Sans SC", Arial';
                
                const lang = this.currentLanguage || 'zh-TW';
                const cameraNames = {
                    front: { en: 'Front', zh: 'ÂâçËßÜ' },
                    left_pillar: { en: 'Left Pillar', zh: 'Â∑¶Êü±' },
                    right_pillar: { en: 'Right Pillar', zh: 'Âè≥Êü±' },
                    back: { en: 'Back', zh: 'ÂêéËßÜ' },
                    left: { en: 'Left', zh: 'Â∑¶‰æß' },
                    right: { en: 'Right', zh: 'Âè≥‰æß' }
                };
                const labelText = cameraNames[camera]?.[lang] || camera.toUpperCase();
                const textW = this.ctx.measureText(labelText).width;
                const padX = 6;
                const padY = 4;
                const boxW = Math.ceil(textW + padX * 2);
                const boxH = 20 + padY * 0;
                this.ctx.fillRect(labelX, labelY, boxW, boxH);
                this.ctx.fillStyle = '#fff';
                this.ctx.fillText(labelText, labelX + padX, labelY + 14);




            }
            }



            
            // Draw timestamp if needed
            if (addTimestamp) {
                const currentTime = new Date(segmentStartTimestamp.getTime() + (videoTime - actualClipStart) * 1000);
                const timeString = currentTime.toLocaleString('zh-CN', {
                    year: 'numeric',
                    month: '2-digit',
                    day: '2-digit',
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit',
                    hour12: false
                }).replace(/\//g, '-');
                
                // Use shared drawTimestamp for consistent style
                this.drawTimestamp(timeString);

            }
            
            // Draw metadata overlay if enabled (at bottom center of grid)
            if (addMetadata && allMetadata.length > 0) {
                const metadataData = this.getMetadataAtTime(allMetadata, i, videoTime);
                this.drawMetadata(metadataData, this.currentLanguage);
            }

            // Draw logo watermark if enabled
            if (logoImg) {
                this.drawLogo(logoImg);
            }

        };


            
            if (hasVideoFrameCallback) {
                await new Promise((resolve) => {
                    let resolved = false;
                    const masterVideo = firstVideo;
                    let lastFrameTime = Date.now();
                    let stuckCheckInterval = null;
                    
                    const stopAll = () => {
                        if (resolved) return;
                        resolved = true;
                        if (stuckCheckInterval) clearInterval(stuckCheckInterval);
                        for (const video of Object.values(videos)) {
                            video.pause();
                        }
                        resolve();
                    };
                    
                    // Check if video is stuck (no frame for 10 seconds)
                    stuckCheckInterval = setInterval(() => {
                        if (resolved) {
                            clearInterval(stuckCheckInterval);
                            return;
                        }
                        if (Date.now() - lastFrameTime > 10000) {
                            console.warn(`[Grid] Video playback stuck, forcing continue. currentTime=${masterVideo.currentTime}, targetEnd=${actualEndTime}`);
                            stopAll();
                        }
                    }, 2000);
                    
                    const onFrame = () => {
                        if (resolved) return;
                        lastFrameTime = Date.now();
                        
                        const t = masterVideo.currentTime;
                        if (t >= actualEndTime - 0.02 || masterVideo.ended) {
                            stopAll();
                            return;
                        }
                        
                        // Light sync: if other cameras drift too much, correct occasionally
                        // Skip videos that have ended or if target time exceeds their duration
                        for (const video of Object.values(videos)) {
                            if (video === masterVideo) continue;
                            if (video.ended || t >= video.duration) continue; // Skip ended videos
                            if (Math.abs(video.currentTime - t) > 0.15) {
                                video.currentTime = Math.min(t, video.duration - 0.1);
                            }
                        }
                        
                        renderFrame(t);
                        processedFrames++;
                        
                        if (processedFrames % 30 === 0) {
                            const progress = Math.min(100, Math.round((processedFrames / totalFrames) * 100));
                            progressCallback?.(`ËôïÁêÜÂõõÂÆÆÊ†º: ${progress}%`);
                        }
                        
                        masterVideo.requestVideoFrameCallback(onFrame);
                    };
                    
                    Promise.all(Object.values(videos).map(v => v.play().catch((e) => {
                        console.warn('[Grid] Video play failed:', e);
                        return null;
                    })))
                        .then(() => {
                            if (!resolved) {
                                masterVideo.requestVideoFrameCallback(onFrame);
                            }
                        })
                        .catch((e) => {
                            console.error('[Grid] Failed to start video playback:', e);
                            stopAll();
                        });
                });
            } else {
                // Fallback: play and sample at FPS without per-frame seeking
                await new Promise((resolve) => {
                    let resolved = false;
                    const masterVideo = firstVideo;
                    const frameInterval = 1000 / FPS;
                    let lastTickTime = Date.now();
                    let stuckCheckInterval = null;
                    
                    const stopAll = () => {
                        if (resolved) return;
                        resolved = true;
                        if (stuckCheckInterval) clearInterval(stuckCheckInterval);
                        for (const video of Object.values(videos)) {
                            video.pause();
                        }
                        resolve();
                    };
                    
                    // Check if video is stuck (no tick for 10 seconds)
                    stuckCheckInterval = setInterval(() => {
                        if (resolved) {
                            clearInterval(stuckCheckInterval);
                            return;
                        }
                        if (Date.now() - lastTickTime > 10000) {
                            console.warn(`[Grid] Video playback stuck (fallback mode), forcing continue`);
                            stopAll();
                        }
                    }, 2000);
                    
                    const tick = () => {
                        if (resolved) return;
                        lastTickTime = Date.now();
                        const t = masterVideo.currentTime;
                        if (t >= actualEndTime - 0.02 || masterVideo.ended) {
                            stopAll();
                            return;
                        }
                        renderFrame(t);
                        processedFrames++;
                        
                        if (processedFrames % 30 === 0) {
                            const progress = Math.min(100, Math.round((processedFrames / totalFrames) * 100));
                            progressCallback?.(`ËôïÁêÜÂõõÂÆÆÊ†º: ${progress}%`);
                        }
                        setTimeout(tick, frameInterval);
                    };
                    
                    Promise.all(Object.values(videos).map(v => v.play().catch((e) => {
                        console.warn('[Grid] Video play failed (fallback):', e);
                        return null;
                    })))
                        .then(() => {
                            if (!resolved) {
                                tick();
                            }
                        })
                        .catch((e) => {
                            console.error('[Grid] Failed to start video playback (fallback):', e);
                            stopAll();
                        });
                });
            }
            
            // Release video resources immediately after processing this segment
            for (const key of Object.keys(videos)) {
                const video = videos[key];
                video.pause();
                URL.revokeObjectURL(video.src);
                video.src = '';
                video.load(); // Detach source
                videos[key] = null;
            }
            
            // Explicitly force garbage collection pause if processing many segments
            if (i % 5 === 0) {
                 await new Promise(r => setTimeout(r, 100));
            }
            
            console.log(`Segment ${i + 1} completed, memory released`);
            this.logMemory(`segment done ${i + 1}/${clipSegments.length}`, {
                writeQueueSize: this.formatBytes(writeQueueSize),
                totalChunkSize: this.formatBytes(totalChunkSize),
                chunksBuffered: chunks.length,
                writeQueueItems: writeQueue.length,
            });
        }

        
        // Ensure all writes are finished before stopping
        if (writable) {
            // Wait for queue to drain
            while (isWriting || writeQueue.length > 0) {
                await new Promise(r => setTimeout(r, 100));
            }
            this.logMemory('write queue drained', {
                writeQueueSize: this.formatBytes(writeQueueSize),
                totalChunkSize: this.formatBytes(totalChunkSize),
                chunksBuffered: chunks.length,
                writeQueueItems: writeQueue.length,
            });
        }


        // Stop recording
        await new Promise(resolve => setTimeout(resolve, 500));
        this.mediaRecorder.stop();
        
        const result = await recordingComplete;
        
        const calculatedDuration = (processedFrames / FPS) * 1000;
        const recordingEndTime = performance.now();
        const realTimeDuration = recordingEndTime - recordingStartTime;
        console.log(`[Grid Video Export] Recording completed. Expected: ${totalDuration * 1000}ms, Calculated: ${calculatedDuration}ms, RealTime: ${realTimeDuration}ms, Frames: ${processedFrames}`);
        this.logMemory('recording stopped', {
            writeQueueSize: this.formatBytes(writeQueueSize),
            totalChunkSize: this.formatBytes(totalChunkSize),
            chunksBuffered: chunks.length,
            writeQueueItems: writeQueue.length,
        });
        
        // Clean up canvas, stream, and audio
        if (stream) {
            stream.getTracks().forEach(track => track.stop());
        }
        if (this._bgAudioCleanup) {
            this._bgAudioCleanup();
            this._bgAudioCleanup = null;
        }

        if (result.saved) {
            // For streamed files, try to use FFmpeg to fix metadata
            // If FFmpeg fails, the video is still playable (just without accurate duration)
            if (fileHandle) {
                try {
                    const fixed = await this.fixWebmWithFFmpeg(fileHandle, progressCallback);
                    if (!fixed) {
                        console.warn('[Grid Video Export] FFmpeg metadata fix failed, video may have inaccurate duration');
                        progressCallback?.('ÂΩ±ÁâáÂ∑≤ÂÑ≤Â≠òÔºà‰∏≠ÁπºË≥áÊñô‰øÆÂæ©Ë∑≥ÈÅéÔºâ');
                    }
                } catch (e) {
                    console.warn('[Grid Video Export] FFmpeg metadata fix error:', e);
                    progressCallback?.('ÂΩ±ÁâáÂ∑≤ÂÑ≤Â≠òÔºà‰∏≠ÁπºË≥áÊñô‰øÆÂæ©Ë∑≥ÈÅéÔºâ');
                }
            }
            return result;
        }

        progressCallback?.('‰øÆÂæ©ÂΩ±Áâá‰∏≠ÁπºË≥áÊñô...');
        const fixedBlob = await webmDurationFixer.fixDuration(result, calculatedDuration);
        
        return fixedBlob;
    }
    
    // Load custom font for timestamp
    async loadTimestampFont() {
        if (this._timestampFontLoaded) return;
        try {
            const fontPath = window.__TAURI__
                ? await (async () => {
                    const dir = await window.__TAURI__.path.resourceDir();
                    const sep = dir.includes('\\') ? '\\' : '/';
                    return getFileUrl({ path: `${dir}assets${sep}fonts${sep}dejavu-sans-bold.ttf` });
                })()
                : 'https://pub-007d01a7483d4a778c32807e257fedc8.r2.dev/fonts/dejavu-sans-bold.ttf';
            const font = new FontFace('DejaVu Sans Bold', `url(${fontPath})`);
            await font.load();
            document.fonts.add(font);
            this._timestampFontLoaded = true;
        } catch (e) {
            console.warn('[Canvas] Custom font load failed, using fallback:', e);
        }
    }

    drawTimestamp(timeString) {
        // Dynamic scaling ‚Äî base size targets 1280px single camera
        const referenceWidth = 1280;
        const scale = this.canvas.width / referenceWidth;

        const fontSize = Math.round(26 * scale);
        const margin = 20 * scale;

        const fontFamily = this._timestampFontLoaded ? '"DejaVu Sans Bold"' : 'bold Arial';
        this.ctx.font = `bold ${fontSize}px ${fontFamily}, Arial`;
        const x = margin;
        const y = this.canvas.height - margin;

        // White text with dark stroke (no background box)
        this.ctx.textBaseline = 'bottom';
        this.ctx.textAlign = 'left';
        this.ctx.lineWidth = Math.max(3, Math.round(2.5 * scale));
        this.ctx.strokeStyle = 'rgba(0, 0, 0, 0.8)';
        this.ctx.strokeText(timeString, x, y);
        this.ctx.fillStyle = '#fff';
        this.ctx.fillText(timeString, x, y);
    }

    // Load logo image for Canvas overlay
    async loadLogoImage() {
        if (this._logoImage) return this._logoImage;
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                this._logoImage = img;
                resolve(img);
            };
            img.onerror = (e) => {
                console.warn('[Canvas] Logo load failed:', e);
                resolve(null);
            };
            // In Tauri, use convertFileSrc; in browser, use relative path
            if (window.__TAURI__) {
                const tauri = window.__TAURI__;
                tauri.path.resourceDir().then(dir => {
                    const sep = dir.includes('\\') ? '\\' : '/';
                    const path = `${dir}imgs${sep}TeslaCAM_256.png`;
                    img.src = getFileUrl({ path });
                }).catch(() => {
                    img.src = 'imgs/TeslaCAM_256.png';
                });
            } else {
                img.src = 'imgs/TeslaCAM_256.png';
            }
        });
    }

    async loadExportBgImage() {
        if (this._exportBgImage) return this._exportBgImage;
        return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
                this._exportBgImage = img;
                resolve(img);
            };
            img.onerror = () => resolve(null);
            if (window.__TAURI__) {
                const tauri = window.__TAURI__;
                tauri.path.resourceDir().then(dir => {
                    const sep = dir.includes('\\') ? '\\' : '/';
                    img.src = getFileUrl({ path: `${dir}imgs${sep}space-bg.jpg` });
                }).catch(() => {
                    img.src = 'imgs/space-bg.jpg';
                });
            } else {
                img.src = 'imgs/space-bg.jpg';
            }
        });
    }

    // Draw logo watermark on canvas (top-right, 85% opacity)
    drawLogo(logoImg) {
        if (!logoImg) return;
        const margin = 16;
        // Scale logo relative to canvas width (~13% of canvas width)
        const targetW = Math.round(this.canvas.width * 0.13);
        const scale = targetW / logoImg.naturalWidth;
        const targetH = Math.round(logoImg.naturalHeight * scale);
        const x = this.canvas.width - targetW - margin;
        const y = margin;
        this.ctx.globalAlpha = 0.85;
        this.ctx.drawImage(logoImg, x, y, targetW, targetH);
        this.ctx.globalAlpha = 1.0;
    }

    // Load a random background audio file as HTMLAudioElement
    async loadBackgroundAudio() {
        const audioFiles = [
            'M_Fischer.mp3', 'Take_Me_Down_To_The_Fashion_Show.mp3', 'Dopamina.mp3',
            'Do_The_Bop.mp3', 'La_Fiesta_Y_La_Cruda.mp3', 'Los_Cabos.mp3',
            'Chicago.mp3', 'Sugar_High.mp3', 'The_Monuments_and_Tunnels_in_Goa_and_Hampi.mp3'
        ];
        const selected = audioFiles[Math.floor(Math.random() * audioFiles.length)];
        return new Promise((resolve) => {
            const audio = new Audio();
            audio.crossOrigin = 'anonymous';
            audio.oncanplaythrough = () => resolve(audio);
            audio.onerror = (e) => {
                console.warn('[Canvas] Audio load failed:', e);
                resolve(null);
            };
            if (window.__TAURI__) {
                window.__TAURI__.path.resourceDir().then(dir => {
                    const sep = dir.includes('\\') ? '\\' : '/';
                    audio.src = getFileUrl({ path: `${dir}audios${sep}${selected}` });
                }).catch(() => {
                    audio.src = `https://audio.tinyomnibus.me/chronodrive/${selected}`;
                });
            } else {
                audio.src = `https://audio.tinyomnibus.me/chronodrive/${selected}`;
            }
        });
    }

    // Load metadata for all segments
    async loadMetadataForSegments(clipSegments, camera, progressCallback = null) {
        const allMetadata = [];
        
        for (let i = 0; i < clipSegments.length; i++) {
            if (this.isCancelled) throw new Error('ÂåØÂá∫Â∑≤ÂèñÊ∂à');
            if (progressCallback) {
                progressCallback(`ËÆÄÂèñÂΩ±ÁâáË≥áÊñô ${i + 1}/${clipSegments.length}...`);
            }
            const clipSegment = clipSegments[i];
            const videoFile = clipSegment.segment.files[camera];
            
            if (!videoFile) continue;
            
            try {
                let buffer;
                if (videoFile instanceof File) {
                    buffer = await videoFile.arrayBuffer();
                } else if (videoFile.path && window.__TAURI__) {
                    const fs = window.__TAURI__.fs;
                    const data = await fs.readFile(videoFile.path);
                    buffer = data.buffer;
                } else if (videoFile.path || videoFile.name) {
                    const response = await fetch(getFileUrl(videoFile));
                    buffer = await response.arrayBuffer();
                } else {
                    continue;
                }
                
                const parser = new DashcamMP4(buffer);
                const rawMetadata = parser.parseMetadata();
                
                if (this.metadataManager && this.metadataManager.SeiMetadata) {
                    const segmentMetadata = rawMetadata.map(item => {
                        try {
                            const decoded = this.metadataManager.SeiMetadata.decode(item.data);
                            return {
                                time: item.time,
                                segmentIndex: i,
                                data: this.metadataManager.SeiMetadata.toObject(decoded, { enums: String, longs: String })
                            };
                        } catch (e) {
                            return null;
                        }
                    }).filter(Boolean);
                    
                    allMetadata.push({
                        segmentIndex: i,
                        clipStart: clipSegment.clipStart,
                        clipEnd: clipSegment.clipEnd,
                        metadata: segmentMetadata
                    });
                }
            } catch (e) {
                console.warn(`[Metadata] Failed to load metadata for segment ${i}:`, e);
            }
        }
        
        return allMetadata;
    }
    
    // Get metadata for a specific time within a segment
    getMetadataAtTime(allMetadata, segmentIndex, currentTime) {
        const segmentData = allMetadata.find(m => m.segmentIndex === segmentIndex);
        if (!segmentData || !segmentData.metadata || segmentData.metadata.length === 0) {
            return null;
        }
        
        // Find the metadata item closest to current time
        let bestMatch = segmentData.metadata[0];
        for (const item of segmentData.metadata) {
            if (item.time <= currentTime) {
                bestMatch = item;
            } else {
                break;
            }
        }
        
        return bestMatch?.data || null;
    }
    
    // Draw metadata overlay at bottom center with SVG icons
    /**
     * Draw metadata overlay on canvas
     */
    drawMetadata(metadataData, lang = 'zh-TW') {
        if (!metadataData) return;

        const d = metadataData;

        // Dynamic scaling ‚Äî base size targets 1280px single camera
        const referenceWidth = 1280;
        const scale = this.canvas.width / referenceWidth;

        const barWidth = 420 * scale;
        const barHeight = 56 * scale;
        const iconSize = 26 * scale;
        const borderRadius = 14 * scale;
        const fontSize = 20 * scale;
        
        // Position: Bottom center
        const x = (this.canvas.width - barWidth) / 2;
        const y = this.canvas.height - barHeight - (20 * scale);
        
        // Draw background bar (Glassmorphism effect)
        this.ctx.save();
        const gradient = this.ctx.createLinearGradient(x, y, x, y + barHeight);
        gradient.addColorStop(0, 'rgba(20, 20, 20, 0.3)');
        gradient.addColorStop(1, 'rgba(5, 5, 5, 0.35)');
        this.ctx.fillStyle = gradient;
        
        this.ctx.beginPath();
        if (this.ctx.roundRect) {
            this.ctx.roundRect(x, y, barWidth, barHeight, borderRadius);
        } else {
            const r = borderRadius;
            this.ctx.moveTo(x + r, y);
            this.ctx.lineTo(x + barWidth - r, y);
            this.ctx.quadraticCurveTo(x + barWidth, y, x + barWidth, y + r);
            this.ctx.lineTo(x + barWidth, y + barHeight - r);
            this.ctx.quadraticCurveTo(x + barWidth, y + barHeight, x + barWidth - r, y + barHeight);
            this.ctx.lineTo(x + r, y + barHeight);
            this.ctx.quadraticCurveTo(x, y + barHeight, x, y + barHeight - r);
            this.ctx.lineTo(x, y + r);
            this.ctx.quadraticCurveTo(x, y, x + r, y);
        }
        this.ctx.fill();
        this.ctx.restore();
        
        const yCenter = y + barHeight / 2;
        
        // Speed
        const speedKmh = Math.round((d.vehicleSpeedMps || 0) * 3.6);
        const speedDisplay = speedKmh >= 150 ? '150+' : `${speedKmh}`;
        const speedText = `${speedDisplay} km/h`;
        
        // Gear
        const gearMap = {
            'GEAR_PARK': 'P',
            'GEAR_DRIVE': 'D',
            'GEAR_REVERSE': 'R',
            'GEAR_NEUTRAL': 'N'
        };
        const gear = gearMap[d.gearState] || '--';
        const gearText = `[${gear}]`;
        
        // Steering bucket
        const steeringAngle = Math.round(d.steeringWheelAngle || 0);
        const steeringBucket = Math.round(steeringAngle / 10) * 10;
        const autopilotState = d.autopilotState || 'NONE';
        
        // Accelerator bucket
        const accelPercent = Math.round(d.acceleratorPedalPosition || 0);
        const accelBucket = Math.floor(accelPercent / 10) * 10;
        
        // Draw items (Using SCALED COORDINATES)
        this.ctx.save();
        this.ctx.font = `bold ${fontSize}px "Noto Sans SC", Arial, sans-serif`;
        this.ctx.textBaseline = 'middle';
        
        // Speed (Scaled at 125)
        this.ctx.fillStyle = '#ffffff';
        this.ctx.textAlign = 'right';
        this.ctx.fillText(speedText, x + 125 * scale, yCenter);
        
        // Gear (Scaled at 145)
        this.ctx.textAlign = 'left';
        let gearColor = '#ffffff';
        if (gear === 'D') gearColor = '#52c41a';
        else if (gear === 'R') gearColor = '#ff4d4f';
        this.ctx.fillStyle = gearColor;
        this.ctx.fillText(gearText, x + 145 * scale, yCenter);
        
        // Blinkers
        this.drawLeftArrow(this.ctx, x + 200 * scale, yCenter, iconSize, d.blinkerOnLeft);
        this.drawRightArrow(this.ctx, x + 240 * scale, yCenter, iconSize, d.blinkerOnRight);
        
        // Brake (Fixed at 290)
        this.drawBrakeIcon(this.ctx, x + 290 * scale, yCenter, iconSize, d.brakeApplied);
        
        // Accel (Fixed at 340, no percentage text, only icon)
        this.drawAcceleratorIcon(this.ctx, x + 340 * scale, yCenter, iconSize, accelBucket);
        
        // Steering Wheel (Fixed at 390)
        this.drawSteeringWheelIcon(this.ctx, x + 390 * scale, yCenter, iconSize, steeringBucket, autopilotState);
        
        this.ctx.restore();
    }

    // Helper: draw left arrow
    drawLeftArrow(ctx, x, y, size, active) {
        const color = active ? '#52c41a' : 'rgba(255,255,255,0.2)';
        ctx.save();
        if (active) {
            ctx.shadowBlur = 6;
            ctx.shadowColor = 'rgba(82, 196, 26, 0.4)';
        }
        ctx.fillStyle = color;
        ctx.beginPath();
        const halfSize = size / 2;
        ctx.moveTo(x + size * 0.9, y - halfSize * 0.4);
        ctx.lineTo(x + halfSize * 1.1, y - halfSize * 0.4);
        ctx.lineTo(x + halfSize * 1.1, y - halfSize * 0.8);
        ctx.lineTo(x + size * 0.1, y);
        ctx.lineTo(x + halfSize * 1.1, y + halfSize * 0.8);
        ctx.lineTo(x + halfSize * 1.1, y + halfSize * 0.4);
        ctx.lineTo(x + size * 0.9, y + halfSize * 0.4);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    // Helper: draw right arrow
    drawRightArrow(ctx, x, y, size, active) {
        const color = active ? '#52c41a' : 'rgba(255,255,255,0.2)';
        ctx.save();
        if (active) {
            ctx.shadowBlur = 6;
            ctx.shadowColor = 'rgba(82, 196, 26, 0.4)';
        }
        ctx.fillStyle = color;
        ctx.beginPath();
        const halfSize = size / 2;
        ctx.moveTo(x + size * 0.1, y - halfSize * 0.4);
        ctx.lineTo(x + halfSize * 0.9, y - halfSize * 0.4);
        ctx.lineTo(x + halfSize * 0.9, y - halfSize * 0.8);
        ctx.lineTo(x + size * 0.9, y);
        ctx.lineTo(x + halfSize * 0.9, y + halfSize * 0.8);
        ctx.lineTo(x + halfSize * 0.9, y + halfSize * 0.4);
        ctx.lineTo(x + size * 0.1, y + halfSize * 0.4);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    // Helper: draw brake icon (brake pedal shape from SVG)
    drawBrakeIcon(ctx, x, y, size, active) {
        const color = active ? '#ff4d4f' : 'rgba(255,255,255,0.4)';
        ctx.save();
        
        try {
            if (active) {
                ctx.shadowBlur = 6;
                ctx.shadowColor = 'rgba(255, 77, 79, 0.5)';
            }
            ctx.fillStyle = color;
            
            // ÁªòÂà∂ÂõæÊ†áÔºåÂ±Ö‰∏≠ÂØπÈΩê - ‰ΩøÁî®ËæÉÂ§ßÂ∞∫ÂØ∏
            const iconSize = size * 1.5;
            const iconX = x + (size - iconSize) / 2;
            const iconY = y - iconSize / 2;
            
            // SVG viewBoxÊòØ0 0 1024 1024ÔºåË∑ØÂæÑÂÆûÈôÖËåÉÂõ¥Á∫¶ x:140-880, y:162-861
            const svgSize = 1024;
            const pathWidth = 880 - 140;
            const pathHeight = 861 - 162;
            const pathCenterX = 140 + pathWidth / 2;
            const pathCenterY = 162 + pathHeight / 2;
            
            const scale = iconSize / svgSize;
            
            // Â∞ÜË∑ØÂæÑ‰∏≠ÂøÉÁßªÂà∞ÂõæÊ†á‰∏≠ÂøÉ
            ctx.translate(iconX + iconSize / 2, iconY + iconSize / 2);
            ctx.scale(scale, scale);
            ctx.translate(-pathCenterX, -pathCenterY);
            
            const path = new Path2D('M821.394 861.482H200.242c-23.709 0-44.013-20.191-45.124-44.975 0 0-30.555-129.896-30.044-166.228 0.325-23.102 15.23-164.3 15.23-164.3 2.449-27.739 18.019-48.258 42.686-48.258h646.233c24.667 0 44.357 21.769 43.759 48.258l14.579 163.622-22.043 166.906c-0.56 24.784-20.414 44.975-44.124 44.975z m24.716-358.364l0.292-10.498c0.23-8.275-6.452-15.059-14.85-15.059H186.497c-8.397 0-14.828 6.784-14.291 15.059l0.681 10.498c0.534 8.232 7.802 14.954 16.153 14.954h641.472c8.35 0 15.37-6.722 15.598-14.954z m8.739 81.304l0.296-10.264c0.233-8.091-6.628-14.724-15.248-14.724H177.735c-8.62 0-15.226 6.633-14.681 14.724l0.691 10.264c0.542 8.049 7.999 14.622 16.571 14.622H838.84c8.574 0 15.777-6.572 16.009-14.622z m6.172 79.506l0.298-10.038c0.235-7.912-6.747-14.399-15.516-14.399H172.234c-8.769 0-15.494 6.487-14.945 14.399l0.695 10.038c0.545 7.872 8.126 14.3 16.847 14.3h669.91c8.721 0 16.047-6.428 16.28-14.3z m-14.901 77.765l0.282-9.819c0.222-7.74-6.466-14.085-14.863-14.085H186.526c-8.397 0-14.841 6.345-14.322 14.085l0.659 9.819c0.517 7.701 7.772 13.989 16.123 13.989h641.548c8.351 0 15.365-6.288 15.586-13.989z m-8.749 76.081l0.267-9.608c0.21-7.573-6.189-13.781-14.222-13.781H206.385c-8.033 0-14.202 6.208-13.711 13.781l0.623 9.608c0.489 7.535 7.425 13.688 15.415 13.688h613.751c7.99 0.001 14.698-6.152 14.908-13.688z m1.869-378.856l36.038-94.167 21.623-119.775H785.183L752.749 356.56l-118.926 82.358H839.24z');
            ctx.fill(path);
        } catch (err) {
            console.error('[drawBrakeIcon Web] Error:', err);
        }
        
        ctx.restore();
    }

    // Helper: draw accelerator icon
    drawAcceleratorIcon(ctx, x, y, size, percent) {
        const active = percent > 0;
        const rectWidth = size * 0.6;
        const rectHeight = size * 0.9;
        const rectX = x + (size - rectWidth) / 2;
        const rectY = y - rectHeight / 2;
        const cornerRadius = 3;
        
        ctx.save();
        ctx.strokeStyle = active ? '#52c41a' : 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        this.drawRoundedRect(ctx, rectX, rectY, rectWidth, rectHeight, cornerRadius);
        ctx.stroke();
        
        if (active) {
            const fillHeight = (percent / 100) * (rectHeight - 4);
            const fillY = rectY + rectHeight - 2 - fillHeight;
            ctx.fillStyle = '#52c41a';
            this.drawRoundedRect(ctx, rectX + 2, fillY, rectWidth - 4, fillHeight, 1);
            ctx.fill();
        }
        ctx.restore();
    }

    // Helper: draw steering wheel icon
    drawSteeringWheelIcon(ctx, x, y, size, angle, autopilotState) {
        let color = 'rgba(255,255,255,0.9)';
        let shadowColor = 'transparent';
        if (autopilotState === 'SELF_DRIVING') {
            color = '#52c41a';
            shadowColor = 'rgba(82, 196, 26, 0.5)';
        } else if (autopilotState === 'AUTOSTEER' || autopilotState === 'TACC') {
            color = '#1890ff';
            shadowColor = 'rgba(24, 144, 255, 0.5)';
        }
        
        ctx.save();
        if (shadowColor !== 'transparent') {
            ctx.shadowBlur = 6;
            ctx.shadowColor = shadowColor;
        }
        
        const cx = x + size / 2;
        const cy = y;
        ctx.translate(cx, cy);
        ctx.rotate((angle * Math.PI) / 180);
        
        const scale = size / 64;
        const r = 28 * scale;
        const hubR = 9 * scale;
        const strokeWidth = 5 * scale;
        const spokeHeight = 8 * scale;
        const spokeWidth = 19 * scale;
        const spokeRx = 2 * scale;
        
        ctx.strokeStyle = color;
        ctx.lineWidth = strokeWidth;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(0, 0, hubR, 0, Math.PI * 2);
        ctx.fill();
        
        // Left spoke
        this.drawRoundedRect(ctx, -r - strokeWidth / 2, -spokeHeight / 2, spokeWidth, spokeHeight, spokeRx);
        ctx.fill();
        // Right spoke
        this.drawRoundedRect(ctx, r - spokeWidth + strokeWidth / 2, -spokeHeight / 2, spokeWidth, spokeHeight, spokeRx);
        ctx.fill();
        // Bottom spoke
        this.drawRoundedRect(ctx, -spokeHeight / 2, hubR, spokeHeight, spokeWidth, spokeRx);
        ctx.fill();
        
        ctx.restore();
    }

    // Helper: draw rounded rectangle
    drawRoundedRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        if (ctx.roundRect) {
            ctx.roundRect(x, y, width, height, radius);
        } else {
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
        }
    }

    parseTimestamp(timestamp) {
        // Handles "2024-01-01_12-00-00" format
        const [datePart, timePart] = timestamp.split('_');
        return new Date(`${datePart}T${timePart.replace(/-/g, ':')}`);
    }
}

class TeslaCamViewer {
    constructor() {
        this.isTauri = !!window.__TAURI__;
        this.allFiles = [];
        this.eventGroups = [];
        this.currentEvent = null;
        this.currentLanguage = 'zh-TW';
        this.currentMapCoordinates = null;
        this.flatpickrInstance = null;
        this.videoClipProcessor = new VideoClipProcessor();
        this.metadataManager = new MetadataManager(this);
        this.dom = {
            folderInput: document.getElementById('folderInput'),
            fileInputIOS: document.getElementById('fileInputIOS'),
            selectFolderBtn: document.getElementById('selectFolderBtn'),
            dateFilter: document.getElementById('dateFilter'),
            clearDateBtn: document.getElementById('clearDateBtn'),
            eventFilter: document.getElementById('eventFilter'),
            sidebar: document.querySelector('.sidebar'),
            toggleSidebarBtn: document.getElementById('toggleSidebarBtn'),
            openSidebarBtn: document.getElementById('openSidebarBtn'),
            playerArea: document.getElementById('playerArea'),
            overlay: document.getElementById('overlay'),
            themeToggleBtn: document.getElementById('themeToggleBtn'),
            langToggleBtn: document.getElementById('langToggleBtn'),
            mapModal: document.getElementById('mapModal'),
            mapModalTitle: document.getElementById('mapModalTitle'),
            gaodeMapBtn: document.getElementById('gaodeMapBtn'),
            googleMapBtn: document.getElementById('googleMapBtn'),
            closeModalBtn: document.getElementById('closeModalBtn'),
            revealFileBtn: document.getElementById('revealFileBtn'),
            downloadFileBtn: document.getElementById('downloadFileBtn'),
            exportMetadataBtn: document.getElementById('exportMetadataBtn'),
            metadataSwitchBtn: document.getElementById('metaSwitchBtn'),
            headerLocationDisplay: document.getElementById('headerLocationDisplay'),
            headerMenuBtn: document.getElementById('headerMenuBtn'),
            headerRight: document.getElementById('headerRight'),
            headerActionsGroup: document.getElementById('headerActionsGroup'),
            headerCenterInfo: document.getElementById('headerCenterInfo') || document.querySelector('.header-center-info'),
            mainHeader: document.querySelector('.main-header'),
            // Clip modal elements
            clipModal: document.getElementById('clipModal'),
            clipModalTitle: document.getElementById('clipModalTitle'),
            clipInfo: document.getElementById('clipInfo'),
            clipOptions: document.getElementById('clipOptions'),
            clipDuration: document.getElementById('clipDuration'),
            clipStartTime: document.getElementById('clipStartTime'),
            clipEndTime: document.getElementById('clipEndTime'),
            exportFront: document.getElementById('exportFront'),
            exportBack: document.getElementById('exportBack'),
            exportLeft: document.getElementById('exportLeft'),
            exportRight: document.getElementById('exportRight'),
            exportLeftPillar: document.getElementById('exportLeftPillar'),
            exportRightPillar: document.getElementById('exportRightPillar'),
            addTimestamp: document.getElementById('addTimestamp'),
            addAudio: document.getElementById('addAudio'),
            saturationSlider: document.getElementById('saturationSlider'),
            contrastSlider: document.getElementById('contrastSlider'),
            brightnessSlider: document.getElementById('brightnessSlider'),
            saturationValue: document.getElementById('saturationValue'),
            contrastValue: document.getElementById('contrastValue'),
            brightnessValue: document.getElementById('brightnessValue'),
            resetColorAdjust: document.getElementById('resetColorAdjust'),
            mergeVideos: document.getElementById('mergeVideos'),
            useLocalFFmpeg: document.getElementById('useLocalFFmpeg'),
            ffmpegOptionRow: document.getElementById('ffmpegOptionRow'),
            clipProgress: document.getElementById('clipProgress'),
            clipProgressBar: document.getElementById('clipProgressBar'),
            clipProgressText: document.getElementById('clipProgressText'),
            startClipBtn: document.getElementById('startClipBtn'),
            cancelClipBtn: document.getElementById('cancelClipBtn'),
            closeClipModalBtn: document.getElementById('closeClipModalBtn'),
            // File path modal elements
            filePathModal: document.getElementById('filePathModal'),
            filePathModalTitle: document.getElementById('filePathModalTitle'),
            filePathInput: document.getElementById('filePathInput'),
            copyPathBtn: document.getElementById('copyPathBtn'),
            copySuccessHint: document.getElementById('copySuccessHint'),
            closeFilePathModalBtn: document.getElementById('closeFilePathModalBtn'),
        };
        this.videoListComponent = new VideoListComponent('fileList', (eventId) => this.playEvent(eventId), this);
        this.multiCameraPlayer = new MultiCameraPlayer();
        this.continuousPlayer = new ContinuousVideoPlayer(this.multiCameraPlayer);
        this.videoControls = new ModernVideoControls(this.continuousPlayer, this);
        this.initializeEventListeners();
        this.initializeFlatpickr();
        this.loadTheme();
        this.loadLanguage();
        this.loadLastTeslaCamPath();
    }

    // Ê∏ÖÁêÜÊóßÊï∞ÊçÆÔºåÈáäÊîæÂÜÖÂ≠ò
    cleanupOldData() {
        // Ê∏ÖÁêÜËßÜÈ¢ëÊí≠ÊîæÂô®
        if (this.multiCameraPlayer) {
            this.multiCameraPlayer.cleanup();
        }
        
        // Ê∏ÖÁêÜÁº©Áï•ÂõæÁöÑ blob URL
        if (this.eventGroups) {
            for (const event of this.eventGroups) {
                if (event.thumbFile && !this.isTauri) {
                    // Web ÁéØÂ¢É‰∏ãÁöÑÁº©Áï•ÂõæÂèØËÉΩÊúâ blob URL ÈúÄË¶ÅÊ∏ÖÁêÜ
                    // ‰ΩÜÂÆûÈôÖ‰∏äÁº©Áï•Âõæ URL Âú® img.onload Êó∂Â∑≤Áªè revoke ‰∫Ü
                }
            }
        }
        
        // Ê∏ÖÁ©∫ÊóßÊï∞ÊçÆÂºïÁî®
        this.allFiles = [];
        this.eventGroups = [];
        this.currentEvent = null;
        
        // Âº∫Âà∂ÂûÉÂúæÂõûÊî∂ÊèêÁ§∫ÔºàÊµèËßàÂô®ÂèØËÉΩ‰ºöÂøΩÁï•Ôºâ
        if (window.gc) {
            window.gc();
        }
        
        console.log('[cleanupOldData] Old data cleaned up');
    }

    initializeEventListeners() {
        const useFileInput = !supportsDirectoryPicker();
        
        this.dom.selectFolderBtn.addEventListener('click', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            
            // Tauri ÁéØÂ¢É‰∏ã‰ΩøÁî® dialog API ÈÄâÊã©ÁõÆÂΩï
            if (this.isTauri) {
                await this.selectTauriDirectory();
                return;
            }
            
            // ‰ºòÂÖà‰ΩøÁî® File System Access APIÔºàÊîØÊåÅÊåÅ‰πÖÂåñÁõÆÂΩïÂè•ÊüÑÔºâ
            if (supportsFileSystemAccess()) {
                await this.selectDirectoryWithFSA();
                return;
            }
            
            if (useFileInput) {
                this.dom.fileInputIOS.click();
            } else {
                this.dom.folderInput.click();
            }
        });
        this.dom.folderInput.addEventListener('change', (e) => this.handleFolderSelection(e.target.files));
        this.dom.fileInputIOS.addEventListener('change', (e) => this.handleIOSFileSelection(e.target.files));

        // Drag & Drop Support
        const dropZone = document.body;
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'copy';
            this.dom.sidebar.classList.add('drag-over');
        });
        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.dom.sidebar.classList.remove('drag-over');
        });
        dropZone.addEventListener('drop', (e) => this.handleDrop(e));

        // Tauri File Drop Support
        if (this.isTauri) {
            const tauri = getTauri();
            if (tauri && tauri.event) {
                console.log('Registering Tauri drag/drop listeners');
                
                // Tauri 2 uses different event names
                const dropEvent = 'tauri://drag-drop';
                const enterEvent = 'tauri://drag-enter';
                const leaveEvent = 'tauri://drag-leave';
                
                tauri.event.listen(enterEvent, (event) => {
                    console.log('Tauri drag enter:', event);
                    this.dom.sidebar.classList.add('drag-over');
                }).catch(err => console.error('Failed to listen to drag-enter', err));
                
                tauri.event.listen(leaveEvent, (event) => {
                    console.log('Tauri drag leave:', event);
                    this.dom.sidebar.classList.remove('drag-over');
                }).catch(err => console.error('Failed to listen to drag-leave', err));
                
                tauri.event.listen(dropEvent, (event) => {
                    console.log('Tauri drag drop event received:', event);
                    this.dom.sidebar.classList.remove('drag-over');
                    const paths = event.payload?.paths || event.payload;
                    if (paths && paths.length > 0) {
                        this.handleTauriDrop(paths);
                    }
                }).catch(err => console.error('Failed to listen to drag-drop', err));
            } else {
                console.warn('Tauri detected but event API not found. window.__TAURI__:', tauri);
            }
        }

        this.dom.eventFilter.addEventListener('change', () => this.filterAndRender());
        this.dom.toggleSidebarBtn.addEventListener('click', () => this.toggleSidebar());
        if (this.dom.openSidebarBtn) {
            this.dom.openSidebarBtn.addEventListener('click', () => this.toggleSidebar(true));
        }
        this.dom.overlay.addEventListener('click', () => this.toggleSidebar(false));
        
        // Mobile swipe gesture support for sidebar
        this.initSwipeGestures();
        
        this.dom.playerArea.addEventListener('click', (e) => {
            const container = e.target.closest('.video-container.is-pip');
            if (container) {
                 this.multiCameraPlayer.setCamera(container.dataset.camera);
            }
        });
        this.dom.themeToggleBtn.addEventListener('click', () => this.toggleTheme());
        this.dom.langToggleBtn.addEventListener('click', () => this.toggleLanguage());
        
        if (this.dom.headerMenuBtn) {
            this.dom.headerMenuBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                this.dom.headerRight.classList.toggle('active');
            });
            
            // ÁÇπÂáªÂ§ñÈÉ®ÂÖ≥Èó≠ËèúÂçï
            document.addEventListener('click', () => {
                if (this.dom.headerRight.classList.contains('active')) {
                    this.dom.headerRight.classList.remove('active');
                }
            });
        }

        document.addEventListener('keydown', (e) => this.handleGlobalKeydown(e));

        window.addEventListener('resize', () => this.handleResize());

        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
            if (!localStorage.getItem('theme')) {
                const isDark = e.matches;
                document.body.classList.toggle('dark-theme', isDark);
                this.updateThemeIcon(isDark);
            }
        });

        // Map Modal Listeners
        this.dom.closeModalBtn.addEventListener('click', () => this.hideMapModal());
        this.dom.mapModal.addEventListener('click', (e) => {
            if (e.target === this.dom.mapModal) {
                this.hideMapModal();
            }
        });
        this.dom.gaodeMapBtn.addEventListener('click', () => this.openMap('gaode'));
        this.dom.googleMapBtn.addEventListener('click', () => this.openMap('google'));
        this.dom.revealFileBtn.addEventListener('click', () => this.revealCurrentFilePath());
        this.dom.downloadFileBtn.addEventListener('click', () => this.downloadCurrentFile());
        this.dom.exportMetadataBtn.addEventListener('click', () => this.exportMetadataToCSV());
        
        // Clip modal listeners
        this.dom.closeClipModalBtn.addEventListener('click', () => this.hideClipModal());
        this.dom.cancelClipBtn.addEventListener('click', () => this.hideClipModal());
        this.dom.startClipBtn.addEventListener('click', () => this.startClipExport());

        // Color adjustment slider listeners
        const bindSlider = (slider, valueEl) => {
            if (slider && valueEl) {
                slider.addEventListener('input', () => { valueEl.textContent = slider.value; });
            }
        };
        bindSlider(this.dom.saturationSlider, this.dom.saturationValue);
        bindSlider(this.dom.contrastSlider, this.dom.contrastValue);
        bindSlider(this.dom.brightnessSlider, this.dom.brightnessValue);
        if (this.dom.resetColorAdjust) {
            this.dom.resetColorAdjust.addEventListener('click', () => {
                this.dom.saturationSlider.value = 100;
                this.dom.contrastSlider.value = 100;
                this.dom.brightnessSlider.value = 100;
                this.dom.saturationValue.textContent = '100';
                this.dom.contrastValue.textContent = '100';
                this.dom.brightnessValue.textContent = '100';
            });
        }

        this.dom.clipModal.addEventListener('click', (e) => {
            if (e.target === this.dom.clipModal) {
                this.hideClipModal();
            }
        });
        
        // File path modal listeners
        this.dom.closeFilePathModalBtn.addEventListener('click', () => this.hideFilePathModal());
        this.dom.copyPathBtn.addEventListener('click', () => this.copyFilePath());
        this.dom.filePathModal.addEventListener('click', (e) => {
            if (e.target === this.dom.filePathModal) {
                this.hideFilePathModal();
            }
        });

        // Initial check for header collapse after DOM is ready
        requestAnimationFrame(() => {
            this.checkHeaderCollapse();
        });
    }

    /**
     * ÊòæÁ§∫ toast ÊèêÁ§∫
     * @param {string} message - ÊèêÁ§∫Ê∂àÊÅØ
     * @param {string} type - Á±ªÂûã: 'success' | 'error' | 'info'
     * @param {number} duration - ÊòæÁ§∫Êó∂Èïø(ms)ÔºåÈªòËÆ§3000
     */
    showToast(message, type = 'success', duration = 3000) {
        let container = document.querySelector('.toast-container');
        if (!container) {
            container = document.createElement('div');
            container.className = 'toast-container';
            document.body.appendChild(container);
        }

        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        container.appendChild(toast);

        // Ëß¶ÂèëÈáçÊéí‰ª•ÂêØÂä®Âä®Áîª
        toast.offsetHeight;
        toast.classList.add('show');

        setTimeout(() => {
            toast.classList.remove('show');
            setTimeout(() => {
                toast.remove();
                if (container.children.length === 0) {
                    container.remove();
                }
            }, 300);
        }, duration);
    }

    initializeFlatpickr() {
        if (!this.dom.dateFilter) return; // Guard clause
        const lang = this.currentLanguage;
        const translations = i18n[lang];
        this.flatpickrInstance = flatpickr(this.dom.dateFilter, {
            dateFormat: "Y-m-d",
            locale: this.currentLanguage === 'zh-TW' ? 'zh' : 'default',
            placeholder: translations.selectDate,
            disableMobile: true, // Force flatpickr on mobile instead of native picker
            onChange: (selectedDates, dateStr, instance) => {
                this.filterAndRender();
                this.updateClearDateButton();
            },
            onReady: (selectedDates, dateStr, instance) => {
                // Guard clause for onReady
                if (instance.calendarContainer) {
                    instance.calendarContainer.classList.add('teslacam-flatpickr');
                }
            }
        });
        
        // Initialize clear date button
        if (this.dom.clearDateBtn) {
            this.dom.clearDateBtn.addEventListener('click', () => this.clearDateFilter());
            this.updateClearDateButton();
        }
    }
    
    clearDateFilter() {
        if (this.flatpickrInstance) {
            this.flatpickrInstance.clear();
            this.filterAndRender();
            this.updateClearDateButton();
        }
    }
    
    updateClearDateButton() {
        if (this.dom.clearDateBtn) {
            const hasValue = this.dom.dateFilter && this.dom.dateFilter.value;
            this.dom.clearDateBtn.classList.toggle('visible', !!hasValue);
        }
    }

    handleGlobalKeydown(e) {
        const activeElement = document.activeElement;
        const isTyping = activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'TEXTAREA' || activeElement.isContentEditable);


        if (e.key === ' ' && !isTyping) {
            e.preventDefault();
            this.videoControls.togglePlayPause();
        }
    }

    handleResize() {
        this.dom.sidebar.style.transition = 'none';
        
        const isCollapsed = this.dom.sidebar.classList.contains('collapsed');
        this.dom.overlay.classList.toggle('active', !isCollapsed && window.innerWidth < 768);

        setTimeout(() => {
            this.dom.sidebar.style.transition = '';
        }, 50);

        // Check if header buttons need to collapse
        this.checkHeaderCollapse();
    }

    checkHeaderCollapse() {
        const mainHeader = this.dom.mainHeader;
        const centerInfo = this.dom.headerCenterInfo;
        const actionsGroup = this.dom.headerActionsGroup;
        const headerRight = this.dom.headerRight;
        
        if (!mainHeader || !centerInfo || !actionsGroup) return;

        // Store current state
        const wasCollapsed = mainHeader.classList.contains('header-collapsed');
        
        // Close dropdown menu during resize to prevent visual glitches
        if (headerRight) {
            headerRight.classList.remove('active');
        }
        
        // Disable transitions and hide actionsGroup during measurement
        mainHeader.style.transition = 'none';
        actionsGroup.style.transition = 'none';
        actionsGroup.style.visibility = 'hidden';
        actionsGroup.style.opacity = '0';
        
        // Temporarily force non-collapsed state to measure true button width
        mainHeader.classList.remove('header-collapsed');
        
        // Force a reflow to get accurate measurements
        void mainHeader.offsetWidth;
        
        // Get bounding rects
        const centerRect = centerInfo.getBoundingClientRect();
        const actionsRect = actionsGroup.getBoundingClientRect();
        
        // Check if there's overlap (with some padding for safety)
        const padding = 16;
        const shouldCollapse = actionsRect.left < (centerRect.right + padding);

        if (shouldCollapse) {
            mainHeader.classList.add('header-collapsed');
        }
        
        // Restore styles after a frame
        requestAnimationFrame(() => {
            mainHeader.style.transition = '';
            actionsGroup.style.transition = '';
            actionsGroup.style.visibility = '';
            actionsGroup.style.opacity = '';
        });
    }

    async handleDrop(e) {
        e.preventDefault();
        e.stopPropagation();
        this.dom.sidebar.classList.remove('drag-over');

        if (this.isTauri) {
            console.log('Tauri drop detected, waiting for tauri://file-drop event');
            return;
        }

        const items = e.dataTransfer.items;
        if (!items) return;

        const files = [];
        const queue = [];

        // Normalize items to entries
        for (let i = 0; i < items.length; i++) {
            const entry = items[i].webkitGetAsEntry ? items[i].webkitGetAsEntry() : null;
            if (entry) {
                queue.push(entry);
            }
        }

        // Recursive scan
        while (queue.length > 0) {
            const entry = queue.shift();
            if (entry.isFile) {
                try {
                    const file = await new Promise((resolve, reject) => entry.file(resolve, reject));
                    // Manually attach webkitRelativePath based on fullPath
                    // entry.fullPath usually starts with /
                    const relativePath = entry.fullPath.startsWith('/') ? entry.fullPath.slice(1) : entry.fullPath;
                    
                    // We need to define property because webkitRelativePath is read-only
                    Object.defineProperty(file, 'webkitRelativePath', {
                        value: relativePath,
                        writable: false
                    });
                    files.push(file);
                } catch (err) {
                    console.error("Error reading file:", entry.name, err);
                }
            } else if (entry.isDirectory) {
                try {
                    const dirReader = entry.createReader();
                    // readEntries might not return all files at once, need to loop
                    const readEntries = async () => {
                        return new Promise((resolve, reject) => {
                            dirReader.readEntries(resolve, reject);
                        });
                    };
                    
                    let entries;
                    do {
                        entries = await readEntries();
                        for (const childEntry of entries) {
                            queue.push(childEntry);
                        }
                    } while (entries.length > 0);
                } catch (err) {
                     console.error("Error reading directory:", entry.name, err);
                }
            }
        }

        if (files.length > 0) {
            this.handleFolderSelection(files);
        }
    }

    async handleTauriDrop(paths) {
        console.log('[Tauri Drop] Received paths:', paths);
        
        // Show loading state
        const loadingDiv = document.createElement('div');
        loadingDiv.id = 'tauri-loading';
        loadingDiv.style.position = 'fixed';
        loadingDiv.style.top = '50%';
        loadingDiv.style.left = '50%';
        loadingDiv.style.transform = 'translate(-50%, -50%)';
        loadingDiv.style.padding = '20px';
        loadingDiv.style.background = 'rgba(0,0,0,0.8)';
        loadingDiv.style.color = 'white';
        loadingDiv.style.borderRadius = '10px';
        loadingDiv.style.zIndex = '9999';
        loadingDiv.innerText = 'Scanning files...';
        document.body.appendChild(loadingDiv);

        try {
            const allFiles = [];
            // ËÆ∞ÂΩïÁ¨¨‰∏Ä‰∏™ÊúâÊïàÁöÑÁõÆÂΩïË∑ØÂæÑÁî®‰∫é‰øùÂ≠ò
            let validDirPath = null;
            
            for (const path of paths) {
                console.log('[Tauri Drop] Scanning path:', path);
                const files = await this.scanTauriFiles(path, path);
                console.log('[Tauri Drop] Found files:', files.length);
                allFiles.push(...files);
                
                // ËÆ∞ÂΩïÁ¨¨‰∏Ä‰∏™Ë∑ØÂæÑ‰Ωú‰∏∫‰øùÂ≠òÁöÑÁõÆÂΩï
                if (!validDirPath && files.length > 0) {
                    validDirPath = path;
                }
            }

            console.log('[Tauri Drop] Total files found:', allFiles.length);
            if (allFiles.length > 0) {
                // Log first few files for debugging
                allFiles.slice(0, 5).forEach(f => {
                    console.log('[Tauri Drop] Sample file:', f.name, 'webkitRelativePath:', f.webkitRelativePath);
                });
                
                // Ê£ÄÊü•ÊòØÂê¶ÊòØÊúâÊïàÁöÑ TeslaCam ÁõÆÂΩï
                const hasTeslaCamSubfolders = allFiles.some(file => 
                    file.webkitRelativePath.includes('RecentClips/') ||
                    file.webkitRelativePath.includes('SavedClips/') ||
                    file.webkitRelativePath.includes('SentryClips/')
                );
                
                if (hasTeslaCamSubfolders && validDirPath) {
                    // ‰øùÂ≠òË∑ØÂæÑÂà∞ÈÖçÁΩÆÊñá‰ª∂Ôºå‰æõ‰∏ãÊ¨°ÂêØÂä®‰ΩøÁî®
                    await this.saveTauriConfig({ lastTeslaCamPath: validDirPath });
                    console.log('[Tauri Drop] Saved path to config:', validDirPath);
                }
                
                this.handleFolderSelection(allFiles);
            } else {
                alert('No files found in the dropped folder.');
            }
        } catch (e) {
            console.error('Tauri drop error:', e);
            alert('Error reading files: ' + e.message);
        } finally {
            if (loadingDiv) loadingDiv.remove();
        }
    }

    async scanTauriFiles(currentPath, rootPath) {
        const tauri = getTauri();
        const files = [];
        
        try {
            let isDir = false;
            let isFile = false;
            
            try {
                const metadata = await tauri.fs.stat(currentPath);
                isDir = metadata.isDirectory;
                isFile = metadata.isFile;
            } catch (e) {
                console.warn('Stat failed for', currentPath, e);
                return [];
            }

            if (isFile) {
                const name = currentPath.split(/[\\/]/).pop();
                files.push(new TauriFile({ name, path: currentPath }, rootPath));
            } else if (isDir) {
                const entries = await tauri.fs.readDir(currentPath);
                for (const entry of entries) {
                     const separator = currentPath.includes('\\') ? '\\' : '/';
                     const fullPath = currentPath + (currentPath.endsWith(separator) ? '' : separator) + entry.name;
                     
                     if (entry.isDirectory) {
                         const subFiles = await this.scanTauriFiles(fullPath, rootPath);
                         files.push(...subFiles);
                     } else if (entry.isFile) {
                         files.push(new TauriFile({ name: entry.name, path: fullPath }, rootPath));
                     }
                }
            }
        } catch (e) {
            console.warn(`Error scanning ${currentPath}:`, e);
        }
        return files;
    }

    async handleFolderSelection(files) {
        // Ê∏ÖÁêÜÊóßÊï∞ÊçÆÔºåÈáäÊîæÂÜÖÂ≠ò
        this.cleanupOldData();
        
        this.allFiles = Array.from(files);
        
        console.log('[handleFolderSelection] Total files:', this.allFiles.length);
        // Log sample paths for debugging
        this.allFiles.slice(0, 5).forEach(f => {
            console.log('[handleFolderSelection] File:', f.name, 'webkitRelativePath:', f.webkitRelativePath);
        });

        const hasTeslaCamSubfolders = this.allFiles.some(file => 
            file.webkitRelativePath.includes('RecentClips/') ||
            file.webkitRelativePath.includes('SavedClips/') ||
            file.webkitRelativePath.includes('SentryClips/')
        );
        
        console.log('[handleFolderSelection] hasTeslaCamSubfolders:', hasTeslaCamSubfolders);

        if (!hasTeslaCamSubfolders) {
            alert(i18n[this.currentLanguage].invalidFolder);
            this.dom.folderInput.value = ''; 
            this.allFiles = [];
            this.showInitialHelpMessage();
            return;
        }

        this.eventGroups = await this.processFiles(this.allFiles);
        console.log('[handleFolderSelection] eventGroups:', this.eventGroups.length);
        this.filterAndRender();
    }

    async handleIOSFileSelection(files) {
        if (!files || files.length === 0) return;
        
        // Convert files to array and add fake webkitRelativePath based on filename
        this.allFiles = Array.from(files).map(file => {
            // TeslaCam filename format: 2024-01-15_12-30-00-front.mp4
            // Create a fake path structure for iOS
            const timestampMatch = file.name.match(/(\d{4}-\d{2}-\d{2}_\d{2}-\d{2})-\d{2}/);
            if (timestampMatch) {
                // Create fake relative path: RecentClips/2024-01-15_12-30/filename.mp4
                const eventFolder = timestampMatch[1].replace(/_/g, '-');
                const fakePath = `RecentClips/${eventFolder}/${file.name}`;
                // Create a new object that mimics the file with webkitRelativePath
                return Object.defineProperty(file, 'webkitRelativePath', {
                    value: fakePath,
                    writable: false
                });
            }
            return file;
        });

        const validFiles = this.allFiles.filter(f => f.webkitRelativePath && f.name.endsWith('.mp4'));
        
        if (validFiles.length === 0) {
            const lang = this.currentLanguage;
            alert(lang === 'zh-TW' 
                ? 'Êú™ÊâæÂà∞ÊúâÊïàÁöÑ TeslaCam ÂΩ±ÁâáÊ™îÊ°à„ÄÇË´ãÈÅ∏ÊìáÊ™îÊ°àÂêçÁ®±Ê†ºÂºèÁÇ∫ "2024-01-15_12-30-00-front.mp4" ÁöÑÂΩ±ÁâáÊ™îÊ°à„ÄÇ'
                : 'No valid TeslaCam video files found. Please select video files with filename format like "2024-01-15_12-30-00-front.mp4".');
            this.dom.fileInputIOS.value = '';
            this.allFiles = [];
            this.showInitialHelpMessage();
            return;
        }

        this.eventGroups = await this.processFiles(this.allFiles);
        this.filterAndRender();
    }

    async processFiles(files) {
        const eventMap = new Map();
        const videoFiles = files.filter(f => f.name.endsWith('.mp4'));
        for (const file of videoFiles) {
            const eventType = this.getEventType(file.webkitRelativePath);
            if (eventType === 'Unknown') continue;
            const timestampMatch = file.name.match(/(\d{4}-\d{2}-\d{2}_\d{2}-\d{2})-\d{2}/);
            if (!timestampMatch) continue;
            const eventId = file.webkitRelativePath.substring(0, file.webkitRelativePath.lastIndexOf('/'));
            if (!eventMap.has(eventId)) eventMap.set(eventId, { eventId, eventType, segments: new Map() });
            const event = eventMap.get(eventId);
            const minuteTimestamp = timestampMatch[1];
            if (!event.segments.has(minuteTimestamp)) event.segments.set(minuteTimestamp, { timestamp: minuteTimestamp, files: {} });
            const segment = event.segments.get(minuteTimestamp);
            const cameraType = this.getCameraType(file.name);
            if (cameraType) segment.files[cameraType] = file;
        }

        const jsonFiles = files.filter(f => f.name === 'event.json');
        console.log('[processFiles] Found event.json files:', jsonFiles.length);
        for (const jsonFile of jsonFiles) {
            const eventId = jsonFile.webkitRelativePath.substring(0, jsonFile.webkitRelativePath.lastIndexOf('/'));
            console.log('[processFiles] Processing event.json, eventId:', eventId, 'exists in map:', eventMap.has(eventId));
            if (eventMap.has(eventId)) {
                try {
                    const textContent = await jsonFile.text();
                    console.log('[processFiles] event.json content preview:', textContent.substring(0, 200));
                    const eventData = JSON.parse(textContent);
                    const eventObj = eventMap.get(eventId);
                    eventObj.city = eventData.city;
                    eventObj.street = eventData.street;
                    eventObj.eventTimestamp = eventData.timestamp;
                    eventObj.lat = eventData.est_lat;
                    eventObj.lon = eventData.est_lon;
                    console.log('[processFiles] Parsed city:', eventObj.city, 'street:', eventObj.street);
                } catch (e) {
                    console.error(`Error parsing event.json for ${eventId}:`, e);
                }
            }
        }

        const thumbFiles = files.filter(f => f.name === 'thumb.png');
        for(const thumb of thumbFiles) {
            const thumbDir = thumb.webkitRelativePath.substring(0, thumb.webkitRelativePath.lastIndexOf('/'));
            if (eventMap.has(thumbDir)) eventMap.get(thumbDir).thumbFile = thumb;
        }
        return Array.from(eventMap.values()).map(event => {
            event.segments = Array.from(event.segments.values()).sort((a, b) => a.timestamp.localeCompare(b.timestamp));
            if (event.segments.length > 0) {
                // Try to get precise start time from the first file of the first segment
                const firstSegment = event.segments[0];
                const firstFile = Object.values(firstSegment.files)[0];
                if (firstFile) {
                    const match = firstFile.name.match(/(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})/);
                    if (match) {
                        event.startTime = match[1];
                    } else {
                        event.startTime = firstSegment.timestamp;
                    }
                } else {
                    event.startTime = firstSegment.timestamp;
                }
            }
            return event;
        }).filter(e => e.segments.length > 0).sort((a, b) => b.startTime.localeCompare(a.startTime));
    }

    filterAndRender() {
        const dateFilter = this.dom.dateFilter.value;
        const eventFilter = this.dom.eventFilter.value;
        const filteredEvents = this.eventGroups.filter(event => 
            (!dateFilter || event.startTime.startsWith(dateFilter)) && 
            (!eventFilter || event.eventType === eventFilter)
        );
        this.videoListComponent.render(filteredEvents);
    }

    async playEvent(eventId) {
        const event = this.eventGroups.find(e => e.eventId === eventId);
        if (!event) return;
        this.currentEvent = event;

        if (this.dom.headerLocationDisplay) {
            if (event.city && event.lat && event.lon) {
                const locationText = event.street ? `${event.city} ¬∑ ${event.street}` : event.city;
                this.dom.headerLocationDisplay.innerHTML = `üìç <span class="city-text">${locationText}</span>`;
                this.dom.headerLocationDisplay.onclick = () => this.showMapModal(event.lat, event.lon);
                this.dom.headerLocationDisplay.style.display = 'block';
            } else {
                this.dom.headerLocationDisplay.innerHTML = '';
                this.dom.headerLocationDisplay.onclick = null;
                this.dom.headerLocationDisplay.style.display = 'none';
            }
        }

        this.dom.playerArea.classList.remove('empty');

        this.videoControls.setEventStartTime(event.startTime);
        
        // Check for pillars and update UI
        const hasPillars = event.segments.some(seg => seg.files.left_pillar || seg.files.right_pillar);
        this.videoControls.updatePillarButtons(hasPillars);

        if (!event.totalDuration || event.totalDuration <= 0) {
            await this.continuousPlayer.calculateEventDurations(event);
        }

        await this.continuousPlayer.loadEvent(event); 
        this.videoControls.setTotalDuration(this.continuousPlayer.getTotalDuration());
        this.videoControls.addEventMarkers(event);
        
        // Load speed graph for entire event (async, don't block playback)
        this.loadSpeedGraphForEvent(event);
        
        // Default to Legacy (PIP) view with Front camera
        this.multiCameraPlayer.setCamera('front');
        this.multiCameraPlayer.setLayout('legacy');
        this.videoControls.updateViewSwitcherUI('legacy');

        await this.multiCameraPlayer.playAll();

        document.querySelectorAll('.video-card.active').forEach(c => c.classList.remove('active'));
        document.querySelector(`.video-card[data-event-id="${eventId}"]`)?.classList.add('active');
        if (window.innerWidth < 768) this.toggleSidebar(false);
    }
    
    /**
     * Load speed data for all segments and draw the speed graph
     */
    async loadSpeedGraphForEvent(event) {
        if (!event || !event.segments || event.segments.length === 0) {
            this.videoControls.clearSpeedGraph();
            return;
        }
        
        try {
            const allSegmentsMetadata = [];
            const segmentDurations = event.segmentDurations || [];
            
            for (let i = 0; i < event.segments.length; i++) {
                const segment = event.segments[i];
                const file = segment.files?.front;
                
                if (!file) {
                    allSegmentsMetadata.push([]);
                    continue;
                }
                
                try {
                    let buffer;
                    if (file instanceof File) {
                        buffer = await file.arrayBuffer();
                    } else if (file instanceof TauriFile) {
                        buffer = await file.arrayBuffer();
                    } else if (file && file.path) {
                        const response = await fetch(getFileUrl(file));
                        buffer = await response.arrayBuffer();
                    } else {
                        allSegmentsMetadata.push([]);
                        continue;
                    }
                    
                    const parser = new DashcamMP4(buffer);
                    const rawMetadata = parser.parseMetadata();
                    
                    if (this.metadataManager && this.metadataManager.SeiMetadata) {
                        const segmentMeta = rawMetadata.map(item => {
                            try {
                                const decoded = this.metadataManager.SeiMetadata.decode(item.data);
                                return {
                                    time: item.time,
                                    data: this.metadataManager.SeiMetadata.toObject(decoded, { enums: String, longs: String })
                                };
                            } catch {
                                return null;
                            }
                        }).filter(Boolean);
                        allSegmentsMetadata.push(segmentMeta);
                    } else {
                        allSegmentsMetadata.push([]);
                    }
                } catch (err) {
                    console.warn(`[SpeedGraph] Failed to load metadata for segment ${i}:`, err);
                    allSegmentsMetadata.push([]);
                }
            }
            
            this.videoControls.drawSpeedGraph(allSegmentsMetadata, segmentDurations);
        } catch (err) {
            console.error('[SpeedGraph] Error loading speed graph:', err);
            this.videoControls.clearSpeedGraph();
        }
    }
    
    /**
     * Export all metadata from the current event to a CSV file
     */
    async exportMetadataToCSV() {
        const lang = this.currentLanguage;
        const translations = i18n[lang];
        
        if (!this.currentEvent || !this.currentEvent.segments) {
            alert(translations.exportMetadataNoData);
            return;
        }
        
        try {
            const allMetadata = [];
            const segmentDurations = this.currentEvent.segmentDurations || [];
            let accumulatedTime = 0;
            
            // Parse event start time for timestamp calculation
            let eventStartDate = null;
            
            // Helper function to parse timestamp
            const parseTimestampStr = (timestamp) => {
                if (!timestamp) return null;
                try {
                    // Parse "2024-01-01_12-00-00" or "2024-01-01_12-00" format
                    const [datePart, timePart] = timestamp.split('_');
                    if (datePart && timePart) {
                        // Handle both HH-MM-SS and HH-MM formats
                        const timeComponents = timePart.split('-');
                        let timeStr;
                        if (timeComponents.length >= 3) {
                            // Has seconds: HH-MM-SS
                            timeStr = `${timeComponents[0]}:${timeComponents[1]}:${timeComponents[2]}`;
                        } else if (timeComponents.length === 2) {
                            // No seconds: HH-MM, add :00
                            timeStr = `${timeComponents[0]}:${timeComponents[1]}:00`;
                        } else {
                            return null;
                        }
                        const result = new Date(`${datePart}T${timeStr}`);
                        console.log(`[ExportCSV] Parsed timestamp: "${timestamp}" -> "${datePart}T${timeStr}" -> ${result}`);
                        return result;
                    }
                } catch (e) {
                    console.warn('[ExportCSV] Failed to parse timestamp:', timestamp, e);
                }
                return null;
            };
            
            // Try event.startTime first
            console.log('[ExportCSV] event.startTime:', this.currentEvent.startTime);
            if (this.currentEvent.startTime) {
                eventStartDate = parseTimestampStr(this.currentEvent.startTime);
            }
            
            // Fallback: try to get timestamp from first segment
            if (!eventStartDate || isNaN(eventStartDate.getTime())) {
                const firstSegment = this.currentEvent.segments[0];
                if (firstSegment?.timestamp) {
                    eventStartDate = parseTimestampStr(firstSegment.timestamp);
                } else if (firstSegment?.files?.front) {
                    // Try to extract from filename (e.g., "2024-01-14_21-13-36-front.mp4")
                    const frontFile = firstSegment.files.front;
                    const filename = frontFile.name || frontFile.path?.split(/[/\\]/).pop() || '';
                    const match = filename.match(/(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})/);
                    if (match) {
                        eventStartDate = parseTimestampStr(match[1]);
                    }
                }
            }
            
            console.log('[ExportCSV] Event start date:', eventStartDate);
            
            // Load metadata from all segments
            for (let i = 0; i < this.currentEvent.segments.length; i++) {
                const segment = this.currentEvent.segments[i];
                const file = segment.files?.front;
                const segmentStartTime = accumulatedTime;
                
                // Get segment-specific timestamp - prioritize filename (has full timestamp with seconds)
                let segmentBaseDate = null;
                
                // First try to extract from filename (most accurate, includes seconds)
                if (file) {
                    const filename = file.name || file.path?.split(/[/\\]/).pop() || '';
                    const match = filename.match(/(\d{4}-\d{2}-\d{2}_\d{2}-\d{2}-\d{2})/);
                    if (match) {
                        segmentBaseDate = parseTimestampStr(match[1]);
                        console.log(`[ExportCSV] Segment ${i} timestamp from filename: ${match[1]}`);
                    }
                }
                
                // Fallback to segment.timestamp if filename parsing failed
                if (!segmentBaseDate && segment.timestamp) {
                    segmentBaseDate = parseTimestampStr(segment.timestamp);
                }
                
                // Final fallback to event start date
                if (!segmentBaseDate) {
                    segmentBaseDate = eventStartDate;
                }
                
                if (file) {
                    try {
                        let buffer;
                        if (file instanceof File) {
                            buffer = await file.arrayBuffer();
                        } else if (file instanceof TauriFile) {
                            buffer = await file.arrayBuffer();
                        } else if (file && file.path) {
                            const response = await fetch(getFileUrl(file));
                            buffer = await response.arrayBuffer();
                        }
                        
                        if (buffer) {
                            const parser = new DashcamMP4(buffer);
                            const rawMetadata = parser.parseMetadata();
                            
                            if (this.metadataManager && this.metadataManager.SeiMetadata) {
                                for (const item of rawMetadata) {
                                    try {
                                        const decoded = this.metadataManager.SeiMetadata.decode(item.data);
                                        const data = this.metadataManager.SeiMetadata.toObject(decoded, { enums: String, longs: String });
                                        const eventTime = segmentStartTime + item.time;
                                        
                                        // Calculate actual timestamp using segment-specific base date
                                        let timestamp = '';
                                        if (segmentBaseDate && !isNaN(segmentBaseDate.getTime())) {
                                            // Use item.time (time within segment) + segment base date
                                            const recordTime = new Date(segmentBaseDate.getTime() + item.time * 1000);
                                            timestamp = this.formatDateTimeForCSV(recordTime);
                                        }
                                        
                                        allMetadata.push({
                                            timestamp,
                                            segmentIndex: i,
                                            segmentTime: item.time,
                                            eventTime,
                                            ...data
                                        });
                                    } catch {
                                        // Skip invalid items
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        console.warn(`[ExportCSV] Failed to load metadata for segment ${i}:`, err);
                    }
                }
                
                accumulatedTime += segmentDurations[i] || 60;
            }
            
            if (allMetadata.length === 0) {
                alert(translations.exportMetadataNoData);
                return;
            }
            
            // Define CSV columns (timestamp first)
            const columns = [
                'timestamp',
                'segmentIndex',
                'segmentTime',
                'eventTime',
                'vehicleSpeedMps',
                'speedKmh',
                'gearState',
                'steeringWheelAngle',
                'acceleratorPedalPosition',
                'brakeApplied',
                'blinkerOnLeft',
                'blinkerOnRight',
                'autopilotState',
                'latitudeDeg',
                'longitudeDeg',
                'headingDeg',
                'linearAccelerationMps2X',
                'linearAccelerationMps2Y',
                'linearAccelerationMps2Z'
            ];
            
            // Build CSV content
            const csvLines = [];
            // Always include timestamp in header
            csvLines.push(columns.join(','));
            
            console.log(`[ExportCSV] Building CSV with ${allMetadata.length} records, first item timestamp: "${allMetadata[0]?.timestamp || 'empty'}"`);
            
            for (const item of allMetadata) {
                const speedKmh = ((item.vehicleSpeedMps || 0) * 3.6).toFixed(2);
                const row = columns.map(col => {
                    if (col === 'speedKmh') return speedKmh;
                    if (col === 'timestamp') return item.timestamp || '';
                    const val = item[col];
                    if (val === undefined || val === null) return '';
                    if (typeof val === 'number') return val.toFixed(6);
                    if (typeof val === 'boolean') return val ? 'true' : 'false';
                    // Escape strings with commas or quotes
                    const str = String(val);
                    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                        return `"${str.replace(/"/g, '""')}"`;
                    }
                    return str;
                });
                csvLines.push(row.join(','));
            }
            
            const csvContent = csvLines.join('\n');
            
            // Generate filename with event timestamp
            const eventTime = this.currentEvent.startTime || new Date().toISOString();
            const safeTimestamp = eventTime.replace(/[:\s]/g, '-').replace(/\//g, '-');
            const filename = `tesla_metadata_${safeTimestamp}.csv`;
            
            // Tauri environment: use Tauri dialog and fs APIs
            if (window.__TAURI__) {
                try {
                    const tauri = window.__TAURI__;
                    const invoke = tauri.core?.invoke || tauri.invoke || (tauri.tauri && tauri.tauri.invoke);
                    
                    if (!invoke) {
                        throw new Error('Tauri invoke not found');
                    }
                    
                    // Use Tauri dialog to get save path
                    const savePath = await invoke('plugin:dialog|save', {
                        options: {
                            defaultPath: filename,
                            filters: [{
                                name: 'CSV File',
                                extensions: ['csv']
                            }]
                        }
                    });
                    
                    const resolvedSavePath = typeof savePath === 'string' ? savePath : savePath?.path;
                    if (!resolvedSavePath) {
                        console.log('[ExportCSV] User cancelled save dialog');
                        return;
                    }
                    
                    // Write CSV content using Tauri fs
                    const fs = tauri.fs;
                    if (fs && fs.writeTextFile) {
                        await fs.writeTextFile(resolvedSavePath, csvContent);
                    } else if (fs && fs.writeFile) {
                        const encoder = new TextEncoder();
                        const uint8Array = encoder.encode(csvContent);
                        await fs.writeFile(resolvedSavePath, uint8Array);
                    } else {
                        // Fallback to custom command
                        const encoder = new TextEncoder();
                        const bytes = Array.from(encoder.encode(csvContent));
                        await invoke('write_binary_file', {
                            path: resolvedSavePath,
                            bytes
                        });
                    }
                    
                    console.log(`[ExportCSV] Exported ${allMetadata.length} metadata records to ${resolvedSavePath}`);
                    this.showToast(translations.exportMetadataSuccess, 'success');
                    return;
                } catch (err) {
                    console.error('[ExportCSV] Tauri save failed:', err);
                    // Fall through to web fallback
                }
            }
            
            // Web environment: Try to use File System Access API for save dialog
            if ('showSaveFilePicker' in window && !window.__TAURI__) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: filename,
                        types: [{
                            description: 'CSV File',
                            accept: { 'text/csv': ['.csv'] }
                        }]
                    });
                    
                    const writable = await fileHandle.createWritable();
                    await writable.write(csvContent);
                    await writable.close();
                    
                    console.log(`[ExportCSV] Exported ${allMetadata.length} metadata records`);
                    return;
                } catch (err) {
                    // User cancelled or API not supported, fall back to download
                    if (err.name === 'AbortError') {
                        console.log('[ExportCSV] User cancelled save dialog');
                        return;
                    }
                    console.warn('[ExportCSV] File System Access API failed, falling back to download:', err);
                }
            }
            
            // Fallback: download the file directly
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            console.log(`[ExportCSV] Exported ${allMetadata.length} metadata records to ${filename}`);
        } catch (err) {
            console.error('[ExportCSV] Error exporting metadata:', err);
            alert(translations.exportFailed + err.message);
        }
    }
    
    /**
     * Format date time for CSV export (YYYY-MM-DD HH:mm:ss)
     */
    formatDateTimeForCSV(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
    }

    switchCamera(viewId) {
        if (!this.currentEvent) return;
        
        if (['grid', 'grid4', 'legacy'].includes(viewId)) {
            this.multiCameraPlayer.setLayout(viewId);
        } else {
            this.multiCameraPlayer.setCamera(viewId);
            this.multiCameraPlayer.setLayout('single');
        }
        this.videoControls.updateViewSwitcherUI(viewId);
    }

    toggleTheme() {
        const isDark = document.body.classList.toggle('dark-theme');
        localStorage.setItem('theme', isDark ? 'dark' : 'light');
        this.updateThemeIcon(isDark);
    }

    loadTheme() {
        const savedTheme = localStorage.getItem('theme');
        let isDark;
        if (savedTheme) {
            isDark = savedTheme === 'dark';
        } else {
            isDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
        }
        document.body.classList.toggle('dark-theme', isDark);
        this.updateThemeIcon(isDark);
    }

    updateThemeIcon(isDark) {
        if (this.dom.themeToggleBtn) {
            const iconEl = this.dom.themeToggleBtn.querySelector('.btn-icon');
            if (iconEl) {
                iconEl.textContent = isDark ? 'üåô' : '‚òÄÔ∏è';
            } else {
                this.dom.themeToggleBtn.textContent = isDark ? 'üåô' : '‚òÄÔ∏è';
            }
            this.dom.themeToggleBtn.title = i18n[this.currentLanguage][isDark ? 'toggleDay' : 'toggleNight'];
        }
    }

    showInitialHelpMessage() {
        const lang = this.currentLanguage;
        const translations = i18n[lang];
        const useFileInput = !supportsDirectoryPicker();
        
        const step1 = useFileInput ? translations.helpStep1IOS : translations.helpStep1;
        const step2 = useFileInput ? translations.helpStep2IOS : translations.helpStep2;
        
        const helpHtml = `
            <div class="empty-state help-text">
                <ol>
                    <li>${step1}</li>
                    <li>${step2}</li>
                </ol>
            </div>
        `;
        this.videoListComponent.container.innerHTML = helpHtml;
    }

    toggleLanguage() {
        const newLang = this.currentLanguage === 'zh-TW' ? 'en' : 'zh-TW';
        this.setLanguage(newLang);
    }

    setLanguage(lang) {
        this.currentLanguage = lang;
        localStorage.setItem('language', lang);
        document.documentElement.lang = lang === 'zh-TW' ? 'zh-TW' : 'en';
        // Guard clause for flatpickr instance and its methods
        if (this.flatpickrInstance && typeof this.flatpickrInstance.set === 'function') {
            const isChinese = lang === 'zh-TW';
            this.flatpickrInstance.set('locale', isChinese ? 'zh' : 'default');
            this.flatpickrInstance.redraw();
        }
        // Guard clause for dateFilter element
        if (this.dom.dateFilter) {
            this.dom.dateFilter.placeholder = i18n[lang].selectDate;
        }
        this.updateAllUIText(lang);
    }

    loadLanguage() {
        let savedLang = localStorage.getItem('language');
        if (savedLang === 'zh') savedLang = 'zh-TW';
        let lang = navigator.language.startsWith('zh') ? 'zh-TW' : 'en';
        if (savedLang) {
            lang = savedLang;
        }
        this.setLanguage(lang);
    }

    /**
     * Ëé∑Âèñ Tauri ÈÖçÁΩÆÊñá‰ª∂Ë∑ØÂæÑ
     */
    async getTauriConfigPath() {
        const tauri = getTauri();
        if (!tauri || !tauri.path) return null;
        
        try {
            // ‰ΩøÁî®Â∫îÁî®Êï∞ÊçÆÁõÆÂΩïÂ≠òÂÇ®ÈÖçÁΩÆ
            const appDataDir = await tauri.path.appDataDir();
            return `${appDataDir}config.json`;
        } catch (e) {
            console.warn('[getTauriConfigPath] Failed to get app data dir:', e);
            return null;
        }
    }

    /**
     * ‰øùÂ≠ò Tauri ÈÖçÁΩÆÂà∞Êú¨Âú∞Êñá‰ª∂
     */
    async saveTauriConfig(config) {
        const tauri = getTauri();
        if (!tauri || !tauri.fs) return;
        
        try {
            const configPath = await this.getTauriConfigPath();
            if (!configPath) return;
            
            // Á°Æ‰øùÁõÆÂΩïÂ≠òÂú®
            const appDataDir = await tauri.path.appDataDir();
            try {
                await tauri.fs.mkdir(appDataDir, { recursive: true });
            } catch (e) {
                // ÁõÆÂΩïÂèØËÉΩÂ∑≤Â≠òÂú®
            }
            
            await tauri.fs.writeTextFile(configPath, JSON.stringify(config, null, 2));
            console.log('[saveTauriConfig] Config saved to:', configPath);
        } catch (e) {
            console.warn('[saveTauriConfig] Failed to save config:', e);
        }
    }

    /**
     * ËØªÂèñ Tauri ÈÖçÁΩÆÊñá‰ª∂
     */
    async loadTauriConfig() {
        const tauri = getTauri();
        if (!tauri || !tauri.fs) return null;
        
        try {
            const configPath = await this.getTauriConfigPath();
            if (!configPath) return null;
            
            const content = await tauri.fs.readTextFile(configPath);
            return JSON.parse(content);
        } catch (e) {
            // Êñá‰ª∂‰∏çÂ≠òÂú®ÊàñËß£ÊûêÂ§±Ë¥•
            console.log('[loadTauriConfig] No config file found or parse error:', e.message);
            return null;
        }
    }

    /**
     * Âä†ËΩΩ‰∏äÊ¨°ÈÄâÊã©ÁöÑ TeslaCam ÁõÆÂΩï
     */
    async loadLastTeslaCamPath() {
        // Tauri ÁéØÂ¢ÉÔºö‰ΩøÁî®Êú¨Âú∞ÈÖçÁΩÆÊñá‰ª∂Â≠òÂÇ®Ë∑ØÂæÑ
        if (this.isTauri) {
            // Á≠âÂæÖ‰∏ÄÂ∞èÊÆµÊó∂Èó¥Á°Æ‰øù Tauri API ÂÆåÂÖ®ÂàùÂßãÂåñ
            await new Promise(resolve => setTimeout(resolve, 100));
            
            const tauri = getTauri();
            if (!tauri || !tauri.fs) {
                console.warn('[loadLastTeslaCamPath] Tauri fs API not available');
                return;
            }
            
            // ‰ªéÈÖçÁΩÆÊñá‰ª∂ËØªÂèñ‰∏äÊ¨°ÁöÑË∑ØÂæÑ
            const config = await this.loadTauriConfig();
            const lastPath = config?.lastTeslaCamPath;
            
            if (!lastPath) {
                console.log('[loadLastTeslaCamPath] No saved path found in config');
                return;
            }
            
            console.log('[loadLastTeslaCamPath] Found saved path:', lastPath);
            
            try {
                // Ê£ÄÊü•ÁõÆÂΩïÊòØÂê¶‰ªçÁÑ∂Â≠òÂú®
                const metadata = await tauri.fs.stat(lastPath);
                if (!metadata.isDirectory) {
                    console.log('[loadLastTeslaCamPath] Path is not a directory');
                    return;
                }
                
                // Ëá™Âä®Âä†ËΩΩËØ•ÁõÆÂΩï
                console.log('[loadLastTeslaCamPath] Auto-loading directory...');
                await this.loadTauriDirectory(lastPath);
            } catch (e) {
                console.warn('[loadLastTeslaCamPath] Failed to load saved path:', e);
            }
            return;
        }
        
        // Web ÁéØÂ¢ÉÔºö‰ΩøÁî® File System Access API Âíå IndexedDB Â≠òÂÇ®ÁõÆÂΩïÂè•ÊüÑ
        if (supportsFileSystemAccess()) {
            try {
                const handle = await getDirectoryHandle();
                if (!handle) {
                    console.log('[loadLastTeslaCamPath] No saved directory handle found');
                    return;
                }
                
                console.log('[loadLastTeslaCamPath] Found saved directory handle:', handle.name);
                
                // ËØ∑Ê±ÇÊùÉÈôêÔºàÁî®Êà∑ÂèØËÉΩÈúÄË¶ÅÈáçÊñ∞ÊéàÊùÉÔºâ
                const permission = await handle.requestPermission({ mode: 'read' });
                if (permission !== 'granted') {
                    console.log('[loadLastTeslaCamPath] Permission denied, clearing saved handle');
                    await clearDirectoryHandle();
                    return;
                }
                
                // Âä†ËΩΩÁõÆÂΩï
                console.log('[loadLastTeslaCamPath] Auto-loading directory from handle...');
                await this.loadDirectoryFromHandle(handle);
            } catch (e) {
                console.warn('[loadLastTeslaCamPath] Failed to load saved directory handle:', e);
                await clearDirectoryHandle();
            }
        } else {
            console.log('[loadLastTeslaCamPath] File System Access API not supported');
        }
    }

    /**
     * ‰ΩøÁî® File System Access API ÈÄâÊã©ÁõÆÂΩïÔºàWeb ÁâàÊú¨Ôºâ
     */
    async selectDirectoryWithFSA() {
        try {
            const handle = await window.showDirectoryPicker({
                id: 'teslacam-directory',
                mode: 'read',
                startIn: 'documents'
            });
            
            console.log('[selectDirectoryWithFSA] Selected directory:', handle.name);
            
            // ‰øùÂ≠òÁõÆÂΩïÂè•ÊüÑÂà∞ IndexedDB
            await saveDirectoryHandle(handle);
            
            // Âä†ËΩΩÁõÆÂΩï
            await this.loadDirectoryFromHandle(handle);
        } catch (e) {
            if (e.name === 'AbortError') {
                console.log('[selectDirectoryWithFSA] User cancelled');
                return;
            }
            console.error('[selectDirectoryWithFSA] Error:', e);
            this.showToast('ÈÄâÊã©ÁõÆÂΩïÂ§±Ë¥•: ' + e.message, 'error');
        }
    }

    /**
     * ‰ªéÁõÆÂΩïÂè•ÊüÑÂä†ËΩΩÊñá‰ª∂ÔºàWeb ÁâàÊú¨Ôºâ
     */
    async loadDirectoryFromHandle(handle) {
        // ÊòæÁ§∫Âä†ËΩΩÁä∂ÊÄÅ
        const loadingDiv = document.createElement('div');
        loadingDiv.id = 'fsa-loading';
        loadingDiv.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:rgba(0,0,0,0.8);color:white;padding:20px 40px;border-radius:8px;z-index:9999;';
        loadingDiv.textContent = this.currentLanguage === 'zh-TW' ? 'Ê≠£Âú®ËºâÂÖ•ÁõÆÈåÑ...' : 'Loading directory...';
        document.body.appendChild(loadingDiv);
        
        try {
            const files = [];
            await this.collectFilesFromHandle(handle, handle.name, files);
            
            console.log('[loadDirectoryFromHandle] Collected files:', files.length);
            
            if (files.length === 0) {
                this.showToast(i18n[this.currentLanguage].invalidFolder, 'error');
                await clearDirectoryHandle();
                return;
            }
            
            // Ê£ÄÊü•ÊòØÂê¶Êúâ TeslaCam Â≠êÊñá‰ª∂Â§π
            const hasTeslaCamSubfolders = files.some(file => 
                file.webkitRelativePath.includes('RecentClips/') ||
                file.webkitRelativePath.includes('SavedClips/') ||
                file.webkitRelativePath.includes('SentryClips/')
            );
            
            if (!hasTeslaCamSubfolders) {
                this.showToast(i18n[this.currentLanguage].invalidFolder, 'error');
                await clearDirectoryHandle();
                return;
            }
            
            // Ê∏ÖÁêÜÊóßÊï∞ÊçÆ
            this.cleanupOldData();
            
            this.allFiles = files;
            this.eventGroups = await this.processFiles(this.allFiles);
            console.log('[loadDirectoryFromHandle] eventGroups:', this.eventGroups.length);
            this.filterAndRender();
            
        } finally {
            loadingDiv.remove();
        }
    }

    /**
     * ÈÄíÂΩíÊî∂ÈõÜÁõÆÂΩï‰∏≠ÁöÑÊâÄÊúâÊñá‰ª∂
     */
    async collectFilesFromHandle(dirHandle, basePath, files) {
        for await (const entry of dirHandle.values()) {
            const entryPath = `${basePath}/${entry.name}`;
            
            if (entry.kind === 'file') {
                // Êî∂ÈõÜËßÜÈ¢ëÊñá‰ª∂„ÄÅÁº©Áï•ÂõæÂíå‰∫ã‰ª∂JSON
                if (entry.name.endsWith('.mp4') || entry.name.endsWith('.png') || entry.name.endsWith('.jpg') || entry.name === 'event.json') {
                    try {
                        const file = await entry.getFile();
                        // Ê∑ªÂä† webkitRelativePath Â±ûÊÄß
                        Object.defineProperty(file, 'webkitRelativePath', {
                            value: entryPath,
                            writable: false
                        });
                        files.push(file);
                    } catch (e) {
                        console.warn('[collectFilesFromHandle] Failed to get file:', entryPath, e);
                    }
                }
            } else if (entry.kind === 'directory') {
                // ÈÄíÂΩíÂ§ÑÁêÜÂ≠êÁõÆÂΩï
                await this.collectFilesFromHandle(entry, entryPath, files);
            }
        }
    }

    /**
     * ‰ΩøÁî® Tauri dialog ÈÄâÊã©ÁõÆÂΩï
     */
    async selectTauriDirectory() {
        const tauri = getTauri();
        if (!tauri) return;
        
        try {
            // Ëé∑Âèñ‰∏äÊ¨°ÈÄâÊã©ÁöÑË∑ØÂæÑ‰Ωú‰∏∫ÈªòËÆ§ÁõÆÂΩï
            const config = await this.loadTauriConfig();
            const lastPath = config?.lastTeslaCamPath;
            
            // ‰ΩøÁî® Tauri dialog API ÈÄâÊã©ÁõÆÂΩï
            let dialog = tauri.dialog;
            if (!dialog && tauri.api) {
                dialog = tauri.api.dialog;
            }
            
            if (!dialog || !dialog.open) {
                console.warn('[selectTauriDirectory] Dialog API not available');
                this.dom.folderInput.click();
                return;
            }
            
            const selected = await dialog.open({
                directory: true,
                multiple: false,
                title: 'Select TeslaCam Directory',
                defaultPath: lastPath || undefined
            });
            
            if (!selected) {
                console.log('[selectTauriDirectory] User cancelled');
                return;
            }
            
            const path = typeof selected === 'string' ? selected : selected[0];
            console.log('[selectTauriDirectory] Selected path:', path);
            
            await this.loadTauriDirectory(path);
        } catch (e) {
            console.error('[selectTauriDirectory] Error:', e);
            this.showToast('ÈÄâÊã©ÁõÆÂΩïÂ§±Ë¥•: ' + e.message, 'error');
        }
    }

    /**
     * Âä†ËΩΩ Tauri ÁõÆÂΩï
     */
    async loadTauriDirectory(path) {
        // Show loading state
        const loadingDiv = document.createElement('div');
        loadingDiv.id = 'tauri-loading';
        loadingDiv.style.position = 'fixed';
        loadingDiv.style.top = '50%';
        loadingDiv.style.left = '50%';
        loadingDiv.style.transform = 'translate(-50%, -50%)';
        loadingDiv.style.padding = '20px';
        loadingDiv.style.background = 'rgba(0,0,0,0.8)';
        loadingDiv.style.color = 'white';
        loadingDiv.style.borderRadius = '10px';
        loadingDiv.style.zIndex = '9999';
        loadingDiv.innerText = 'Scanning files...';
        document.body.appendChild(loadingDiv);

        try {
            console.log('[loadTauriDirectory] Scanning path:', path);
            const files = await this.scanTauriFiles(path, path);
            console.log('[loadTauriDirectory] Found files:', files.length);

            if (files.length > 0) {
                // Log first few files for debugging
                files.slice(0, 5).forEach(f => {
                    console.log('[loadTauriDirectory] Sample file:', f.name, 'webkitRelativePath:', f.webkitRelativePath);
                });
                
                // Ê£ÄÊü•ÊòØÂê¶ÊòØÊúâÊïàÁöÑ TeslaCam ÁõÆÂΩï
                const hasTeslaCamSubfolders = files.some(file => 
                    file.webkitRelativePath.includes('RecentClips/') ||
                    file.webkitRelativePath.includes('SavedClips/') ||
                    file.webkitRelativePath.includes('SentryClips/')
                );
                
                if (hasTeslaCamSubfolders) {
                    // ‰øùÂ≠òË∑ØÂæÑÂà∞ÈÖçÁΩÆÊñá‰ª∂
                    await this.saveTauriConfig({ lastTeslaCamPath: path });
                    console.log('[loadTauriDirectory] Saved path to config file');
                    
                    await this.handleFolderSelection(files);
                } else {
                    this.showToast(i18n[this.currentLanguage].invalidFolder, 'error', 5000);
                }
            } else {
                this.showToast('No files found in the selected folder.', 'error');
            }
        } catch (e) {
            console.error('[loadTauriDirectory] Error:', e);
            this.showToast('Error reading files: ' + e.message, 'error');
        } finally {
            if (loadingDiv) loadingDiv.remove();
        }
    }

    updateAllUIText(lang) {
        const translations = i18n[lang];
        if (!translations) return;

        document.title = translations.pageTitle;
        
        // Update language toggle button text
        const langIconEl = this.dom.langToggleBtn.querySelector('.btn-icon');
        if (langIconEl) {
            langIconEl.textContent = lang === 'zh-TW' ? 'En' : '‰∏≠';
        } else {
            this.dom.langToggleBtn.textContent = lang === 'zh-TW' ? 'En' : '‰∏≠';
        }
        
        this.dom.langToggleBtn.title = translations.toggleLanguage;
        this.dom.themeToggleBtn.title = translations.toggleTheme;
        this.dom.toggleSidebarBtn.title = translations.toggleSidebar;
        this.dom.mapModalTitle.textContent = translations.mapModalTitle;
        this.dom.gaodeMapBtn.textContent = translations.gaodeMap;
        this.dom.googleMapBtn.textContent = translations.googleMap;
        this.dom.revealFileBtn.title = translations.revealFile;
        this.dom.downloadFileBtn.title = translations.downloadFile;
        this.dom.exportMetadataBtn.title = translations.exportMetadata;
        if (this.dom.headerMenuBtn) {
            this.dom.headerMenuBtn.title = translations.moreOptions;
        }

        document.querySelector('.sidebar-header .header-title span').textContent = translations.headerTitle;
        document.querySelector('.filter-group label[for="dateFilter"]').textContent = translations.date;
        document.querySelector('.filter-group label[for="eventFilter"]').textContent = translations.eventType;
        document.querySelector('#eventFilter option[value=""]').textContent = translations.allTypes;
        document.querySelector('#eventFilter option[value="RecentClips"]').textContent = translations.recentClips;
        document.querySelector('#eventFilter option[value="SavedClips"]').textContent = translations.savedClips;
        document.querySelector('#eventFilter option[value="SentryClips"]').textContent = translations.sentryClips;
        
        const useFileInput = !supportsDirectoryPicker();
        document.querySelector('#selectFolderBtn').textContent = useFileInput ? translations.selectFiles : translations.selectFolder;

        // Update View Switcher and other common labels
        document.querySelectorAll('[data-i18n="front"]').forEach(el => el.textContent = translations.front);
        document.querySelectorAll('[data-i18n="back"]').forEach(el => el.textContent = translations.back);
        document.querySelectorAll('[data-i18n="left"]').forEach(el => el.textContent = translations.left);
        document.querySelectorAll('[data-i18n="right"]').forEach(el => el.textContent = translations.right);
        document.querySelectorAll('[data-i18n="leftPillar"]').forEach(el => el.textContent = translations.leftPillar);
        document.querySelectorAll('[data-i18n="rightPillar"]').forEach(el => el.textContent = translations.rightPillar);
        document.querySelectorAll('[data-i18n="grid6"]').forEach(el => el.textContent = translations.grid6);
        document.querySelectorAll('[data-i18n="grid4"]').forEach(el => el.textContent = translations.grid4);
        document.querySelectorAll('[data-i18n="legacy"]').forEach(el => el.textContent = translations.legacy);

        // Update Metadata Panel and Buttons
        const metadataKeys = [
            'metadata', 'metadataDetail', 'loadingMetadata', 'noMetadata', 'speed', 'gear', 'steering', 
            'accelerator', 'brake', 'blinker', 'autopilot', 'gps', 'heading', 'acceleration',
            'revealFile', 'downloadFile', 'toggleTheme', 'toggleLanguage', 'exportMetadata'
        ];
        metadataKeys.forEach(key => {
            document.querySelectorAll(`[data-i18n="${key}"]`).forEach(el => {
                if (translations[key]) el.textContent = translations[key];
            });
        });

        // Update stats overlay title if open
        const statsTitle = document.getElementById('statsTitle');
        if (statsTitle) {
            statsTitle.textContent = translations.driveStats;
        }

        if (this.allFiles.length === 0) {
            this.showInitialHelpMessage();
        } else {
            this.filterAndRender();
        }
        
        this.videoControls.updatePlayState(this.multiCameraPlayer.isPlaying);
        this.videoControls.updateRealTimeClock();
    }

    toggleSidebar(forceState) {
        let isNowCollapsed;
        if (typeof forceState !== 'undefined') {
            isNowCollapsed = !forceState;
            this.dom.sidebar.classList.toggle('collapsed', isNowCollapsed);
        } else {
            isNowCollapsed = this.dom.sidebar.classList.toggle('collapsed');
        }
        
        document.body.classList.toggle('sidebar-collapsed', isNowCollapsed);
        this.dom.toggleSidebarBtn.classList.toggle('collapsed', isNowCollapsed);
        this.dom.overlay.classList.toggle('active', !isNowCollapsed && window.innerWidth < 768);
        
        // Re-check header collapse after sidebar animation completes
        setTimeout(() => this.checkHeaderCollapse(), 350);
    }

    initSwipeGestures() {
        let touchStartX = 0;
        let touchStartY = 0;
        let touchEndX = 0;
        let touchEndY = 0;
        const minSwipeDistance = 50;
        const maxVerticalDistance = 100;
        const edgeThreshold = 30; // Edge area for swipe-to-open

        // Swipe on sidebar to close
        this.dom.sidebar.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        this.dom.sidebar.addEventListener('touchend', (e) => {
            if (window.innerWidth >= 768) return; // Only on mobile
            
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = Math.abs(touchEndY - touchStartY);
            
            // Swipe left to close sidebar
            if (deltaX < -minSwipeDistance && deltaY < maxVerticalDistance) {
                this.toggleSidebar(false);
            }
        }, { passive: true });

        // Swipe from left edge to open sidebar
        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, { passive: true });

        document.addEventListener('touchend', (e) => {
            if (window.innerWidth >= 768) return; // Only on mobile
            
            const isCollapsed = this.dom.sidebar.classList.contains('collapsed');
            if (!isCollapsed) return; // Only handle swipe-to-open when sidebar is hidden
            
            touchEndX = e.changedTouches[0].screenX;
            touchEndY = e.changedTouches[0].screenY;
            
            const deltaX = touchEndX - touchStartX;
            const deltaY = Math.abs(touchEndY - touchStartY);
            
            // Swipe right from left edge to open sidebar
            if (touchStartX < edgeThreshold && deltaX > minSwipeDistance && deltaY < maxVerticalDistance) {
                this.toggleSidebar(true);
            }
        }, { passive: true });
        
        // Initialize view switcher scroll with mouse wheel support
        this.initViewSwitcherScroll();
    }

    initViewSwitcherScroll() {
        const viewSwitcher = document.getElementById('viewSwitcher');
        if (!viewSwitcher) return;

        // Mouse wheel horizontal scroll
        viewSwitcher.addEventListener('wheel', (e) => {
            if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
                e.preventDefault();
                viewSwitcher.scrollLeft += e.deltaY;
            }
        }, { passive: false });
    }

    async revealCurrentFilePath() {
        if (this.multiCameraPlayer.isPlaying || !this.continuousPlayer.currentEvent) {
            return;
        }
    
        const currentSegmentIndex = this.continuousPlayer.currentSegmentIndex;
        const segment = this.continuousPlayer.currentEvent.segments[currentSegmentIndex];
        if (!segment) {
            alert("Could not determine file path.");
            return;
        }
    
        const activeCamera = this.multiCameraPlayer.activeCamera;
        const file = segment.files[activeCamera];
    
        // In Tauri desktop, open file explorer and select the file
        if (this.isTauri && file && file.path) {
            try {
                const tauri = window.__TAURI__;
                const shell = tauri.shell;
                
                // Detect OS and use appropriate command
                const platform = navigator.platform.toLowerCase();
                const isWindows = platform.includes('win');
                const isMac = platform.includes('mac');
                
                if (isWindows) {
                    // Windows: explorer /select,"path" - must be a single argument
                    const normalizedPath = file.path.replace(/\//g, '\\');
                    const command = shell.Command.create('explorer', [`/select,${normalizedPath}`]);
                    await command.execute();
                } else if (isMac) {
                    // macOS: open -R "path"
                    const command = shell.Command.create('open', ['-R', file.path]);
                    await command.execute();
                } else {
                    // Linux: xdg-open parent directory (can't select file directly)
                    const parentDir = file.path.substring(0, file.path.lastIndexOf('/'));
                    const command = shell.Command.create('xdg-open', [parentDir]);
                    await command.execute();
                }
                return;
            } catch (e) {
                console.error('Failed to reveal file in explorer:', e);
                // Fall through to show modal with path
            }
        }
        
        // Fallback: show modal with file path for easy copying
        // Prefer absolute path (file.path) if available, otherwise use webkitRelativePath
        const displayPath = file?.path || file?.webkitRelativePath;
        if (displayPath) {
            this.showFilePathModal(displayPath);
        } else {
            this.showToast(i18n[this.currentLanguage].noFilePath || "Could not determine file path for the active camera.", 'error');
        }
    }
    
    showFilePathModal(filePath) {
        const translations = i18n[this.currentLanguage];
        this.dom.filePathModalTitle.textContent = translations.filePathAlertTitle;
        this.dom.filePathInput.value = filePath;
        this.dom.copySuccessHint.classList.remove('show');
        this.dom.filePathModal.style.display = 'flex';
        requestAnimationFrame(() => {
            this.dom.filePathModal.classList.add('show');
        });
        // Select the text for easy copying
        this.dom.filePathInput.select();
    }
    
    hideFilePathModal() {
        this.dom.filePathModal.classList.remove('show');
        setTimeout(() => {
            this.dom.filePathModal.style.display = 'none';
        }, 300);
    }
    
    async copyFilePath() {
        const filePath = this.dom.filePathInput.value;
        const translations = i18n[this.currentLanguage];
        try {
            await navigator.clipboard.writeText(filePath);
            this.dom.copySuccessHint.textContent = translations.copiedToClipboard;
            this.dom.copySuccessHint.classList.add('show');
            setTimeout(() => {
                this.dom.copySuccessHint.classList.remove('show');
            }, 2000);
        } catch (e) {
            // Fallback for older browsers
            this.dom.filePathInput.select();
            document.execCommand('copy');
            this.dom.copySuccessHint.textContent = translations.copiedToClipboard;
            this.dom.copySuccessHint.classList.add('show');
            setTimeout(() => {
                this.dom.copySuccessHint.classList.remove('show');
            }, 2000);
        }
    }

    async downloadCurrentFile() {
        if (this.multiCameraPlayer.isPlaying || !this.continuousPlayer.currentEvent) {
            return;
        }

        const currentSegmentIndex = this.continuousPlayer.currentSegmentIndex;
        const segment = this.continuousPlayer.currentEvent.segments[currentSegmentIndex];
        if (!segment) {
            return;
        }

        const activeCamera = this.multiCameraPlayer.activeCamera;
        const file = segment.files[activeCamera];
        if (!file) {
            return;
        }

        if (window.__TAURI__) {
            try {
                const invoke = window.__TAURI__.core?.invoke || window.__TAURI__.invoke || (window.__TAURI__.tauri && window.__TAURI__.tauri.invoke);
                if (!invoke) throw new Error('Tauri invoke not found');

                const defaultName = file.name || 'TeslaCam.mp4';
                const savePath = await invoke('plugin:dialog|save', {
                    options: {
                        defaultPath: defaultName,
                        filters: [{
                            name: 'Video',
                            extensions: ['mp4']
                        }]
                    }
                });

                const resolvedSavePath = typeof savePath === 'string' ? savePath : savePath?.path;
                if (!resolvedSavePath) {
                    return;
                }

                const arrayBuffer = await file.arrayBuffer();
                const uint8Array = new Uint8Array(arrayBuffer);

                // Use Tauri fs plugin to write binary file
                const fs = window.__TAURI__.fs;
                if (fs && fs.writeFile) {
                    await fs.writeFile(resolvedSavePath, uint8Array);
                } else {
                    // Fallback to custom command
                    const bytes = Array.from(uint8Array);
                    await invoke('write_binary_file', {
                        path: resolvedSavePath,
                        bytes
                    });
                }

                this.showToast('‰øùÂ≠òÊàêÂäü!', 'success');
            } catch (e) {
                console.error('Tauri download failed:', e);
                const errorMsg = typeof e === 'string' ? e : (e.message || JSON.stringify(e));
                alert('‰øùÂ≠òÂ§±Ë¥•: ' + errorMsg);
            }
            return;
        }

        const a = document.createElement('a');
        const url = getFileUrl(file);
        a.href = url;
        a.download = file.name;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    }

    
    showClipModal() {
        if (!this.videoControls.clipModeActive || 
            this.videoControls.clipStartTime === null || 
            this.videoControls.clipStartTime === undefined || 
            this.videoControls.clipEndTime === null || 
            this.videoControls.clipEndTime === undefined) {
            alert(i18n[this.currentLanguage].selectClipRange);
            return;
        }
        
        const translations = i18n[this.currentLanguage];
        
        // Update modal title and labels
        this.dom.clipModalTitle.textContent = translations.exportClip;
        
        // Update labels
        document.getElementById('selectCamerasLabel').textContent = translations.selectCameras;
        document.getElementById('addTimestampLabel').textContent = translations.addTimestamp;
        document.getElementById('addMetadataLabel').textContent = translations.addMetadata;
        document.getElementById('addAudioLabel').textContent = translations.addBackgroundAudio;
        document.getElementById('colorAdjustLabel').textContent = translations.colorAdjust;
        document.getElementById('saturationLabel').textContent = translations.saturation;
        document.getElementById('contrastLabel').textContent = translations.contrast;
        document.getElementById('brightnessLabel').textContent = translations.brightness;
        document.getElementById('resetColorAdjustLabel').textContent = translations.resetColorAdjust;
        document.getElementById('mergeVideosLabel').textContent = translations.mergeVideos;
        this.dom.startClipBtn.textContent = translations.startExport;
        this.dom.cancelClipBtn.textContent = translations.cancel;
        
        // Update camera labels
        document.querySelectorAll('[data-i18n="front"]').forEach(el => el.textContent = translations.front);
        document.querySelectorAll('[data-i18n="back"]').forEach(el => el.textContent = translations.back);
        document.querySelectorAll('[data-i18n="left"]').forEach(el => el.textContent = translations.left);
        document.querySelectorAll('[data-i18n="right"]').forEach(el => el.textContent = translations.right);
        document.querySelectorAll('[data-i18n="leftPillar"]').forEach(el => el.textContent = translations.leftPillar);
        document.querySelectorAll('[data-i18n="rightPillar"]').forEach(el => el.textContent = translations.rightPillar);
        document.querySelectorAll('[data-i18n="grid6"]').forEach(el => el.textContent = translations.grid6);
        document.querySelectorAll('[data-i18n="grid4"]').forEach(el => el.textContent = translations.grid4);
        document.querySelectorAll('[data-i18n="legacy"]').forEach(el => el.textContent = translations.legacy);

        // Update Metadata Panel
        const metadataKeys = [
            'metadata', 'loadingMetadata', 'noMetadata', 'speed', 'gear', 'steering', 
            'accelerator', 'brake', 'blinker', 'autopilot', 'gps', 'heading', 'acceleration'
        ];
        metadataKeys.forEach(key => {
            document.querySelectorAll(`[data-i18n="${key}"]`).forEach(el => {
                if (translations[key]) el.textContent = translations[key];
            });
        });

        
        // Update clip info labels
        const clipDurationLabel = this.dom.clipDuration.previousElementSibling;
        const clipStartTimeLabel = this.dom.clipStartTime.previousElementSibling;
        const clipEndTimeLabel = this.dom.clipEndTime.previousElementSibling;
        if (clipDurationLabel) clipDurationLabel.textContent = translations.clipDuration;
        if (clipStartTimeLabel) clipStartTimeLabel.textContent = translations.clipStartTime;
        if (clipEndTimeLabel) clipEndTimeLabel.textContent = translations.clipEndTime;
        
        // Calculate duration
        const duration = this.videoControls.clipEndTime - this.videoControls.clipStartTime;
        this.dom.clipDuration.textContent = this.videoControls.formatTime(duration);
        
        // Calculate actual timestamps
        const event = this.continuousPlayer.currentEvent;
        if (event && event.startTime) {
            const startDate = this.parseTimestamp(event.startTime);
            const startTime = new Date(startDate.getTime() + this.videoControls.clipStartTime * 1000);
            const endTime = new Date(startDate.getTime() + this.videoControls.clipEndTime * 1000);
            
            const locale = this.currentLanguage === 'zh-TW' ? 'zh-TW' : 'en-CA';
            this.dom.clipStartTime.textContent = startTime.toLocaleString(locale, {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
            this.dom.clipEndTime.textContent = endTime.toLocaleString(locale, {
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });
        }
        
        // Reset checkboxes
        this.dom.exportFront.checked = true;
        this.dom.exportBack.checked = false;
        this.dom.exportLeft.checked = false;
        this.dom.exportRight.checked = false;
        this.dom.addTimestamp.checked = true;
        this.dom.mergeVideos.checked = false;
        
        // Show FFmpeg option only in Tauri desktop
        if (this.isTauri && this.dom.ffmpegOptionRow) {
            this.dom.ffmpegOptionRow.style.display = 'flex';
            // Check FFmpeg availability
            this.videoClipProcessor.checkFFmpeg().then(hasFFmpeg => {
                if (hasFFmpeg) {
                    this.dom.useLocalFFmpeg.checked = true;
                    this.dom.useLocalFFmpeg.disabled = false;
                    document.getElementById('useLocalFFmpegLabel').textContent = 
                        this.currentLanguage === 'zh-TW' ? '‰ΩøÁî® FFmpeg Ê•µÈÄüÂåØÂá∫' : 'Use FFmpeg Fast Export';
                } else {
                    this.dom.useLocalFFmpeg.checked = false;
                    this.dom.useLocalFFmpeg.disabled = true;
                    document.getElementById('useLocalFFmpegLabel').textContent = 
                        this.currentLanguage === 'zh-TW' ? 'FFmpeg Êú™ÂÆâË£ù' : 'FFmpeg Not Installed';
                }
            });
        } else if (this.dom.ffmpegOptionRow) {
            this.dom.ffmpegOptionRow.style.display = 'none';
        }
        
        // Hide progress
        this.dom.clipProgress.style.display = 'none';
        this.dom.startClipBtn.disabled = false;
        this.dom.startClipBtn.style.display = 'block'; // Ensure visible
        this.dom.cancelClipBtn.disabled = false;
        this.dom.cancelClipBtn.textContent = i18n[this.currentLanguage].cancel; // Reset text
        this.dom.cancelClipBtn.style.display = 'block'; // Ensure visible
        
        // Reset clip info and options state (remove disabled class)
        this.dom.clipInfo.classList.remove('disabled');
        this.dom.clipOptions.classList.remove('disabled');
        
        // Hide download buttons if any
        const downloadButtons = document.getElementById('downloadButtons');
        if (downloadButtons) {
            downloadButtons.style.display = 'none';
            downloadButtons.innerHTML = '';
        }
        
        // Show modal
        this.dom.clipModal.style.display = 'flex';
        setTimeout(() => this.dom.clipModal.classList.add('show'), 10);
    }
    
    hideClipModal() {
        // Cancel any pending export
        if (this.videoClipProcessor) {
            this.videoClipProcessor.cancelExport();
        }
        
        this.dom.clipModal.classList.remove('show');
        setTimeout(() => {
            this.dom.clipModal.style.display = 'none';
            // Reset download buttons
            const downloadButtons = document.getElementById('downloadButtons');
            if (downloadButtons) {
                downloadButtons.style.display = 'none';
                downloadButtons.innerHTML = '';
            }
            
            // Clean up pending export blobs to free memory
            if (this.pendingExportBlobs) {
                console.log('[Memory] Cleaning up pending export blobs...');
                for (const result of this.pendingExportBlobs) {
                    if (result.blob) {
                        // Clear the blob reference
                        result.blob = null;
                    }
                }
                this.pendingExportBlobs = null;
                
                // Suggest garbage collection (browser will do this automatically, but this helps)
                if (window.gc) {
                    window.gc();
                }
                console.log('[Memory] Export blobs cleaned up');
            }
        }, 300);
    }
    
    parseTimestamp(timestamp) {
        // Handles "2024-01-01_12-00-00" format
        const [datePart, timePart] = timestamp.split('_');
        return new Date(`${datePart}T${timePart.replace(/-/g, ':')}`);
    }
    
    async saveVideoFile(blob, filename) {
        try {
            // Check if File System Access API is available (Chrome 86+, Edge 86+)
            if ('showSaveFilePicker' in window) {
                try {
                    const fileHandle = await window.showSaveFilePicker({
                        suggestedName: filename,
                        types: [{
                            description: 'WebM Video',
                            accept: { 'video/webm': ['.webm'] }
                        }]
                    });

                    const writable = await fileHandle.createWritable();
                    await writable.write(blob);
                    await writable.close();

                    console.log('File saved via File System Access API');
                    this.showToast('ÂΩ±ÁâáÂÑ≤Â≠òÊàêÂäü!', 'success');
                } catch (fsError) {
                    // User cancelled the save dialog or API failed
                    if (fsError.name === 'AbortError') {
                        console.log('User cancelled save dialog');
                        return;
                    }
                    throw fsError; // Re-throw other errors to fall back
                }
            } else {
                // Fallback to traditional download for older browsers
                const url = URL.createObjectURL(blob);
                console.log('Created blob URL:', url);

                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);

                await new Promise(resolve => {
                    setTimeout(() => {
                        a.click();
                        console.log('Download link clicked');
                        resolve();
                    }, 100);
                });

                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    console.log('Cleanup completed');
                }, 1000);
                
                this.showToast(`ÂΩ±ÁâáÂ∑≤‰∏ãËºâ: ${filename}`, 'success');
            }
        } catch (downloadError) {
            console.error('Download error:', downloadError);
            alert('‰∏ãËºâÂ§±Êïó: ' + downloadError.message);
        }
    }

    async startClipExport() {
        const translations = i18n[this.currentLanguage];
        
        // Get selected cameras
        const cameras = [];
        if (this.dom.exportFront.checked) cameras.push('front');
        if (this.dom.exportBack.checked) cameras.push('back');
        if (this.dom.exportLeft.checked) cameras.push('left');
        if (this.dom.exportRight.checked) cameras.push('right');
        if (this.dom.exportLeftPillar && this.dom.exportLeftPillar.checked) cameras.push('left_pillar');
        if (this.dom.exportRightPillar && this.dom.exportRightPillar.checked) cameras.push('right_pillar');
        
        if (cameras.length === 0) {
            alert(translations.selectAtLeastOneCamera);
            return;
        }
        
        const addTimestamp = this.dom.addTimestamp.checked;
        const addMetadata = document.getElementById('addMetadata').checked;
        const addLogo = true;
        const addAudio = this.dom.addAudio?.checked || false;
        const mergeGrid = this.dom.mergeVideos.checked && cameras.length > 1;
        const useLocalFFmpeg = this.isTauri && this.dom.useLocalFFmpeg && this.dom.useLocalFFmpeg.checked;
        const colorAdjust = {
            saturation: parseInt(this.dom.saturationSlider?.value || '100', 10),
            contrast: parseInt(this.dom.contrastSlider?.value || '100', 10),
            brightness: parseInt(this.dom.brightnessSlider?.value || '100', 10)
        };

        console.log('[startClipExport] Export options:', { addTimestamp, addMetadata, addLogo, addAudio, mergeGrid, useLocalFFmpeg, colorAdjust, cameras });
        
        // WEB ONLY: Ask for save location upfront to enable streaming
        let fileHandle = null;
        if (!this.isTauri && 'showSaveFilePicker' in window && !useLocalFFmpeg) {
             // Only support streaming for Grid (1 file) or Single Camera (1 file)
             if (mergeGrid || cameras.length === 1) {
                  try {
                      const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                      const camName = mergeGrid ? 'grid' : cameras[0];
                      // Canvas export produces WebM
                      const suggestedName = `TeslaCam_${camName}_${timestamp}.webm`;
                      
                      fileHandle = await window.showSaveFilePicker({
                          suggestedName: suggestedName,
                          types: [{
                              description: 'WebM Video',
                              accept: { 'video/webm': ['.webm'] }
                          }],
                      });
                  } catch (e) {
                      if (e.name === 'AbortError') return; // User cancelled
                      console.error('File picker failed, falling back to memory mode:', e);
                  }
             }
        }

        // Disable start button but KEEP cancel button enabled
        this.dom.startClipBtn.disabled = true;
        if (this.dom.cancelClipBtn) this.dom.cancelClipBtn.disabled = false;
        this.dom.clipInfo.classList.add('disabled');
        this.dom.clipOptions.classList.add('disabled');
        this.dom.clipProgress.style.display = 'block';
        this.dom.clipProgressBar.style.width = '0%';
        this.dom.clipProgressBar.classList.remove('indeterminate');
        this.dom.clipProgressText.textContent = translations.preparing;
        
        // Ensure buttons state
        const downloadButtons = document.getElementById('downloadButtons');
        if (downloadButtons) {
            downloadButtons.style.display = 'none';
            downloadButtons.innerHTML = '';
        }

        try {
            const event = this.continuousPlayer.currentEvent;
            
            // Add duration to segments
            const segmentsWithDuration = event.segments.map((seg, idx) => {
                return {
                    ...seg,
                    duration: event.segmentDurations[idx] || 60
                };
            });
            
            const results = await this.videoClipProcessor.processClip(
                segmentsWithDuration,
                cameras,
                this.videoControls.clipStartTime,
                this.videoControls.clipEndTime,
                addTimestamp,
                addMetadata,
                mergeGrid,
                event.startTime,
                (msg) => {
                    this.dom.clipProgressText.textContent = msg;
                    // Extract real percentage from message if available
                    const percentMatch = msg.match(/(\d+)%/);
                    if (percentMatch) {
                        // Real progress - remove indeterminate animation
                        this.dom.clipProgressBar.classList.remove('indeterminate');
                        const percent = parseInt(percentMatch[1], 10);
                        this.dom.clipProgressBar.style.width = Math.min(95, percent) + '%';
                    } else if (msg.includes('FFmpeg') || msg.includes('Ê•µÈÄüÂåØÂá∫') || msg.includes('ÂØ´ÂÖ•Á£ÅÁ¢ü')) {
                        // FFmpeg export - use indeterminate animation
                        this.dom.clipProgressBar.classList.add('indeterminate');
                    } else {
                        // For other non-percentage messages
                        this.dom.clipProgressBar.classList.remove('indeterminate');
                        const currentWidth = parseFloat(this.dom.clipProgressBar.style.width) || 0;
                        if (currentWidth < 30) {
                            this.dom.clipProgressBar.style.width = Math.min(30, currentWidth + 5) + '%';
                        }
                    }
                },
                useLocalFFmpeg,
                this.currentLanguage,
                fileHandle,
                this.metadataManager,
                addLogo,
                addAudio,
                colorAdjust
            );
            
            this.dom.clipProgressBar.classList.remove('indeterminate');
            
            this.dom.clipProgressBar.style.width = '100%';
            
            if (window.__TAURI__) {
                // Tauri implementation
                this.dom.clipProgressText.textContent = translations.exporting;
                for (const result of results) {
                    // Check if result is from FFmpeg (file path) or Canvas (blob)
                    if (result.isFile && result.path) {
                        const rawPath = result.path;
                        const defaultFilename = rawPath.replace(/\\/g, '/').split('/').pop();
                        const ext = defaultFilename.split('.').pop() || 'mp4';
                        
                        console.log('[Tauri Save] Finalizing export for:', defaultFilename, 'from temp:', rawPath);
                        
                        try {
                            const tauri = window.__TAURI__;
                            const invoke = tauri.core?.invoke || tauri.invoke;
                            const fs = tauri.fs;
                            const dialog = tauri.dialog;
                            
                            let savePath;
                            if (dialog && typeof dialog.save === 'function') {
                                console.log('[Tauri Save] Using dialog.save API');
                                savePath = await dialog.save({
                                    defaultPath: defaultFilename,
                                    filters: [{
                                        name: 'Video',
                                        extensions: [ext]
                                    }]
                                });
                            } else {
                                console.log('[Tauri Save] Falling back to invoke plugin:dialog|save');
                                savePath = await invoke('plugin:dialog|save', {
                                    options: {
                                        defaultPath: defaultFilename,
                                        filters: [{
                                            name: 'Video',
                                            extensions: [ext]
                                        }]
                                    }
                                });
                            }
                            
                            const resolvedSavePath = typeof savePath === 'string' ? savePath : savePath?.path;
                            if (resolvedSavePath && resolvedSavePath !== result.path) {
                                // Copy file to new location
                                await fs.copyFile(result.path, resolvedSavePath);
                                // Remove temp file
                                await fs.remove(result.path);
                                this.showToast('‰øùÂ≠òÊàêÂäü!', 'success');
                            } else if (resolvedSavePath === result.path) {
                                this.showToast('‰øùÂ≠òÊàêÂäü!', 'success');
                            } else {
                                // User cancelled, keep the file in original location
                                this.showToast(`ÂΩ±ÁâáÂ∑≤ÂÑ≤Â≠òÂà∞: ${result.path}`, 'success');
                            }
                        } catch (e) {
                            console.error('File move failed:', e);
                            this.showToast(`ÂΩ±ÁâáÂ∑≤ÂÑ≤Â≠òÂà∞: ${result.path}`, 'success');
                        }
                    } else if (result.blob) {
                        // Canvas export - blob needs to be saved
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                        const filename = `TeslaCam_${result.camera}_${timestamp}.webm`;
                        
                        if (result.blob.size === 0) {
                            console.error('Invalid blob for camera:', result.camera);
                            alert('ÂåØÂá∫Â§±ÊïóÔºöÁî¢ÁîüÁöÑÂΩ±ÁâáÊ™îÊ°àÁÇ∫Á©∫');
                            continue;
                        }
                        
                        try {
                            const invoke = window.__TAURI__.core?.invoke || window.__TAURI__.invoke;
                            const fs = window.__TAURI__.fs;

                            const savePath = await invoke('plugin:dialog|save', {
                                options: {
                                    defaultPath: filename,
                                    filters: [{
                                        name: 'Video',
                                        extensions: ['webm']
                                    }]
                                }
                            });
                            
                            const resolvedSavePath = typeof savePath === 'string' ? savePath : savePath?.path;
                            if (resolvedSavePath) {
                                const arrayBuffer = await result.blob.arrayBuffer();
                                const uint8Array = new Uint8Array(arrayBuffer);
                                
                                // Tauri v2 uses writeFile
                                await fs.writeFile(resolvedSavePath, uint8Array);
                                this.showToast('‰øùÂ≠òÊàêÂäü!', 'success');
                            }
                        } catch (e) {
                            console.error('Tauri save failed:', e);
                            alert('‰øùÂ≠òÂ§±Ë¥•: ' + (e.message || e));
                        }
                    }
                }
                
                this.dom.clipProgressText.textContent = translations.complete;
                setTimeout(() => {
                    this.hideClipModal();
                    this.videoControls.toggleClipMode(); 
                }, 2000);
            } else {
                // Browser download - Show buttons
                this.dom.clipProgressText.textContent = 'ÂΩ±ÁâáÂ∑≤Áî¢ÁîüÔºåË´ãÈªûÊìä‰∏ãÊñπÊåâÈàïÂÑ≤Â≠ò';
                
                // Disable clip info and options since video is already generated
                this.dom.clipInfo.classList.add('disabled');
                this.dom.clipOptions.classList.add('disabled');
                
                // Store results for cleanup when modal closes
                this.pendingExportBlobs = results;
                
                if (downloadButtons) {
                    downloadButtons.style.display = 'flex';
                    
                    for (const result of results) {
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                        const filename = `TeslaCam_${result.camera}_${timestamp}.webm`;
                        const isGrid = result.camera === 'grid';
                        const cameraNameMap = { front: translations.front, back: translations.back, left: translations.left, right: translations.right, left_pillar: translations.leftPillar, right_pillar: translations.rightPillar };
                        const cameraName = isGrid ? (translations.mergeVideos || 'ÂõõÂÆÆÊ†º') : (cameraNameMap[result.camera] || result.camera);
                        const sizeInMB = result.blob.size / (1024 * 1024);
                        const sizeText = sizeInMB >= 1 ? `${sizeInMB.toFixed(1)} MB` : `${(result.blob.size / 1024).toFixed(0)} KB`;
                        
                        const btn = document.createElement('button');
                        btn.className = `download-btn${isGrid ? ' grid-btn' : ''}`;
                        
                        if (result.saved) {
                             btn.disabled = true;
                             btn.innerHTML = `
                                <span class="btn-icon">‚úÖ</span>
                                <span class="btn-text">${cameraName} Â∑≤‰øùÂ≠ò</span>
                            `;
                             if (result.blob && result.blob.size > 0) {
                                 btn.innerHTML += `<span class="btn-size">${sizeText}</span>`;
                             }
                             this.dom.clipProgressText.textContent = translations.complete;
                        } else {
                            btn.innerHTML = `
                                <span class="btn-icon">üíæ</span>
                                <span class="btn-text">ÂÑ≤Â≠ò ${cameraName} ÂΩ±Áâá</span>
                                <span class="btn-size">${sizeText}</span>
                            `;
                            btn.onclick = async () => {
                                await this.saveVideoFile(result.blob, filename);
                                // Mark as downloaded
                                result.downloaded = true;
                                btn.disabled = true;
                                btn.innerHTML = `
                                    <span class="btn-icon">‚úÖ</span>
                                    <span class="btn-text">${cameraName} Â∑≤‰øùÂ≠ò</span>
                                    <span class="btn-size">${sizeText}</span>
                                `;
                            };
                        }
                        downloadButtons.appendChild(btn);
                    }
                }
                
                // Hide both buttons since we have the X close button
                this.dom.cancelClipBtn.style.display = 'none';
                this.dom.startClipBtn.style.display = 'none';
            }
            
        } catch (error) {
            console.error('Clip export error:', error);
            const errorMsg = error?.message || error?.toString?.() || JSON.stringify(error) || 'Êú™Áü•ÈåØË™§';
            alert(translations.exportFailed + errorMsg);
            this.dom.clipProgress.style.display = 'none';
            this.dom.startClipBtn.disabled = false;
            this.dom.cancelClipBtn.disabled = false;
        }
    }

    showMapModal(lat, lon) {
        this.currentMapCoordinates = { lat, lon };
        this.dom.mapModal.style.display = 'flex';
        setTimeout(() => this.dom.mapModal.classList.add('show'), 10);
    }

    hideMapModal() {
        this.dom.mapModal.classList.remove('show');
        setTimeout(() => {
            this.dom.mapModal.style.display = 'none';
            this.currentMapCoordinates = null;
        }, 300);
    }

    async openMap(type) {
        if (!this.currentMapCoordinates) return;
        const { lat, lon } = this.currentMapCoordinates;
        let url;
        if (type === 'gaode') {
            // Convert WGS-84 (GPS) to GCJ-02 (Gaode/AMap) for accuracy
            const gcj02 = wgs84togcj02(parseFloat(lon), parseFloat(lat));
            const gcj_lon = gcj02[0];
            const gcj_lat = gcj02[1];
            // Gaode URI API uses lon,lat order and GCJ-02 coordinates
            url = `https://uri.amap.com/marker?position=${gcj_lon},${gcj_lat}&name=‰∫ã‰ª∂‰ΩçÁΩÆ`;
        } else { // google
            url = `https://www.google.com/maps?q=${lat},${lon}`;
        }
        
        // In Tauri desktop, use shell plugin to open in default browser
        if (this.isTauri && window.__TAURI__) {
            try {
                const tauri = window.__TAURI__;
                // Tauri 2: try different API paths for shell.open
                let openFn = null;
                if (tauri.shell?.open) {
                    openFn = tauri.shell.open;
                } else if (tauri.opener?.open) {
                    openFn = tauri.opener.open;
                }
                
                if (openFn) {
                    await openFn(url);
                } else {
                    // Fallback: use invoke to call shell plugin directly
                    const invoke = tauri.core?.invoke || tauri.invoke || (tauri.tauri && tauri.tauri.invoke);
                    if (invoke) {
                        await invoke('plugin:shell|open', { path: url });
                    } else {
                        window.open(url, '_blank');
                    }
                }
            } catch (e) {
                console.error('Failed to open URL with Tauri shell:', e);
                window.open(url, '_blank');
            }
        } else {
            window.open(url, '_blank');
        }
        this.hideMapModal();
    }

    getEventType(path) {
        if (path.includes('RecentClips/')) return 'RecentClips';
        if (path.includes('SavedClips/')) return 'SavedClips';
        if (path.includes('SentryClips/')) return 'SentryClips';
        return 'Unknown';
    }

    getCameraType(fileName) {
        if (fileName.includes('-front.mp4')) return 'front';
        if (fileName.includes('-back.mp4')) return 'back';
        if (fileName.includes('-left_repeater.mp4')) return 'left';
        if (fileName.includes('-right_repeater.mp4')) return 'right';
        if (fileName.includes('-left_pillar.mp4')) return 'left_pillar';
        if (fileName.includes('-right_pillar.mp4')) return 'right_pillar';
        return null;
    }

    destroy() { if (this.multiCameraPlayer) this.multiCameraPlayer.cleanup(); }
}

// Preload custom font for Canvas rendering (desktop only, non-blocking)
function preloadFonts() {
    // Only load font in Tauri desktop environment
    if (!window.__TAURI__) return;
    
    // Dynamically add @font-face for desktop
    const style = document.createElement('style');
    style.textContent = `
        @font-face {
            font-family: 'Noto Sans SC';
            src: url('https://pub-007d01a7483d4a778c32807e257fedc8.r2.dev/fonts/NotoSansSC-Light.ttf') format('truetype');
            font-weight: 300;
            font-style: normal;
            font-display: swap;
        }
    `;
    document.head.appendChild(style);
    
    if (document.fonts && document.fonts.ready) {
        document.fonts.ready.then(() => {
            console.log('Fonts ready for Canvas rendering');
        }).catch(() => {
            console.warn('Font loading check failed, using fallback');
        });
    }
}

document.addEventListener('DOMContentLoaded', () => {
    try {
        preloadFonts();
        window.viewer = new TeslaCamViewer();
        window.addEventListener('beforeunload', () => { if (window.viewer) window.viewer.destroy(); });
        console.log('TDashcam Studio Initialized');
    } catch (error) {
        console.error("Initialization failed:", error);
        alert("Player initialization failed. Check console for details.");
    }
});